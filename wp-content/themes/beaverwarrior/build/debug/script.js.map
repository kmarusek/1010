{"version":3,"sources":["apolyfill_Array.includes.js","apolyfill_Function.name.js","aPolyfill_promise.min.js","apolyfill_String.endsWith.js","apolyfill_String.includes.js","apolyfill_String.startsWith.js","behaviors.js","functions.js","wow.js","AnimatedBackgrounds/AtlasPlayer.js","AffixColumn/AffixColumn.js","Animations/Animations.js","CollapseContent/collapse_content.js","Depaginate/depaginate.js","GoogleMap/GoogleMap.js","ContentSlider/ContentSlider.js","Offcanvas/betteroffcanvas.js","PageTransition/page_transition.js","ScrollEffects/ScrollEffects.js","SiteHeader/AccountSlideIn.js","SiteHeader/SiteHeader.js","StaffGrid/StaffGrid.js","TabbedContent/tabbed_content.js","UTM/utm_preserve.js","VideoPlayer/VideoPlayer.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtHA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACbA;AACA;AACA;AACA;AACA;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/VA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjsBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/6BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7ZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"script.js","sourcesContent":["// From https://github.com/kevlatus/polyfill-array-includes/blob/master/array-includes.js\r\nif (!Array.prototype.includes) {\r\n    Object.defineProperty(Array.prototype, 'includes', {\r\n        value: function (searchElement, fromIndex) {\r\n            // 1. Let O be ? ToObject(this value).\r\n            if (this == null) {\r\n                throw new TypeError('\"this\" is null or not defined');\r\n            }\r\n\r\n            var o = Object(this);\r\n\r\n            // 2. Let len be ? ToLength(? Get(O, \"length\")).\r\n            var len = o.length >>> 0;\r\n\r\n            // 3. If len is 0, return false.\r\n            if (len === 0) {\r\n                return false;\r\n            }\r\n\r\n            // 4. Let n be ? ToInteger(fromIndex).\r\n            //    (If fromIndex is undefined, this step produces the value 0.)\r\n            var n = fromIndex | 0;\r\n\r\n            // 5. If n â‰¥ 0, then\r\n            //  a. Let k be n.\r\n            // 6. Else n < 0,\r\n            //  a. Let k be len + n.\r\n            //  b. If k < 0, let k be 0.\r\n            var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);\r\n\r\n            function sameValueZero(x, y) {\r\n                return x === y || (typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y));\r\n            }\r\n\r\n            // 7. Repeat, while k < len\r\n            while (k < len) {\r\n                // a. Let elementK be the result of ? Get(O, ! ToString(k)).\r\n                // b. If SameValueZero(searchElement, elementK) is true, return true.\r\n                // c. Increase k by 1.\r\n                if (sameValueZero(o[k], searchElement)) {\r\n                    return true;\r\n                }\r\n                k++;\r\n            }\r\n\r\n            // 8. Return false\r\n            return false;\r\n        }\r\n    });\r\n}","//https://github.com/JamesMGreene/Function.name/blob/master/Function.name.js\r\n(function() {\r\n\r\nvar fnNameMatchRegex = /^\\s*function\\s+([^\\(\\s]*)\\s*/;\r\n\r\nfunction _name() {\r\n  var match, name;\r\n  if (this === Function || this === Function.prototype.constructor) {\r\n    name = \"Function\";\r\n  }\r\n  else if (this !== Function.prototype) {\r\n    match = (\"\" + this).match(fnNameMatchRegex);\r\n    name = match && match[1];\r\n  }\r\n  return name || \"\";\r\n}\r\n\r\n// Inspect the polyfill-ability of this browser\r\nvar needsPolyfill = !(\"name\" in Function.prototype && \"name\" in (function x() {}));\r\nvar canDefineProp = typeof Object.defineProperty === \"function\" &&\r\n  (function() {\r\n    var result;\r\n    try {\r\n      Object.defineProperty(Function.prototype, \"_xyz\", {\r\n        get: function() {\r\n          return \"blah\";\r\n        },\r\n        configurable: true\r\n      });\r\n      result = Function.prototype._xyz === \"blah\";\r\n      delete Function.prototype._xyz;\r\n    }\r\n    catch (e) {\r\n      result = false;\r\n    }\r\n    return result;\r\n  })();\r\nvar canDefineGetter = typeof Object.prototype.__defineGetter__ === \"function\" &&\r\n  (function() {\r\n    var result;\r\n    try {\r\n      Function.prototype.__defineGetter__(\"_abc\", function() {\r\n        return \"foo\";\r\n      });\r\n      result = Function.prototype._abc === \"foo\";\r\n      delete Function.prototype._abc;\r\n    }\r\n    catch (e) {\r\n      result = false;\r\n    }\r\n    return result;\r\n  })();\r\n\r\n\r\n\r\n// Add the \"private\" property for testing, even if the real property can be polyfilled\r\nFunction.prototype._name = _name;\r\n\r\n\r\n// Polyfill it!\r\n// For:\r\n//  * IE >=9 <12\r\n//  * Chrome <33\r\nif (needsPolyfill) {\r\n  // For:\r\n  //  * IE >=9 <12\r\n  //  * Chrome >=5 <33\r\n  if (canDefineProp) {\r\n    Object.defineProperty(Function.prototype, \"name\", {\r\n      get: function() {\r\n        var name = _name.call(this);\r\n\r\n        // Since named function definitions have immutable names, also memoize the\r\n        // output by defining the `name` property directly on this Function\r\n        // instance so that this polyfill will not need to be invoked again\r\n        if (this !== Function.prototype) {\r\n          Object.defineProperty(this, \"name\", {\r\n            value: name,\r\n            configurable: true\r\n          });\r\n        }\r\n\r\n        return name;\r\n      },\r\n      configurable: true\r\n    });\r\n  }\r\n  // For:\r\n  //  * Chrome <5\r\n  else if (canDefineGetter) {\r\n    // NOTE:\r\n    // The snippet:\r\n    //\r\n    //     x.__defineGetter__('y', z);\r\n    //\r\n    // ...is essentially equivalent to:\r\n    //\r\n    //     Object.defineProperty(x, 'y', {\r\n    //       get: z,\r\n    //       configurable: true,  // <-- key difference #1\r\n    //       enumerable: true     // <-- key difference #2\r\n    //     });\r\n    //\r\n    Function.prototype.__defineGetter__(\"name\", function() {\r\n      var name = _name.call(this);\r\n\r\n      // Since named function definitions have immutable names, also memoize the\r\n      // output by defining the `name` property directly on this Function\r\n      // instance so that this polyfill will not need to be invoked again\r\n      if (this !== Function.prototype) {\r\n        this.__defineGetter__(\"name\", function() { return name; });\r\n      }\r\n\r\n      return name;\r\n    });\r\n  }\r\n}\r\n\r\n})();","!function(e){function n(){}function t(e,n){return function(){e.apply(n,arguments)}}function o(e){if(\"object\"!=typeof this)throw new TypeError(\"Promises must be constructed via new\");if(\"function\"!=typeof e)throw new TypeError(\"not a function\");this._state=0,this._handled=!1,this._value=void 0,this._deferreds=[],s(e,this)}function i(e,n){for(;3===e._state;)e=e._value;return 0===e._state?void e._deferreds.push(n):(e._handled=!0,void o._immediateFn(function(){var t=1===e._state?n.onFulfilled:n.onRejected;if(null===t)return void(1===e._state?r:u)(n.promise,e._value);var o;try{o=t(e._value)}catch(i){return void u(n.promise,i)}r(n.promise,o)}))}function r(e,n){try{if(n===e)throw new TypeError(\"A promise cannot be resolved with itself.\");if(n&&(\"object\"==typeof n||\"function\"==typeof n)){var i=n.then;if(n instanceof o)return e._state=3,e._value=n,void f(e);if(\"function\"==typeof i)return void s(t(i,n),e)}e._state=1,e._value=n,f(e)}catch(r){u(e,r)}}function u(e,n){e._state=2,e._value=n,f(e)}function f(e){2===e._state&&0===e._deferreds.length&&o._immediateFn(function(){e._handled||o._unhandledRejectionFn(e._value)});for(var n=0,t=e._deferreds.length;n<t;n++)i(e,e._deferreds[n]);e._deferreds=null}function c(e,n,t){this.onFulfilled=\"function\"==typeof e?e:null,this.onRejected=\"function\"==typeof n?n:null,this.promise=t}function s(e,n){var t=!1;try{e(function(e){t||(t=!0,r(n,e))},function(e){t||(t=!0,u(n,e))})}catch(o){if(t)return;t=!0,u(n,o)}}var a=setTimeout;o.prototype[\"catch\"]=function(e){return this.then(null,e)},o.prototype.then=function(e,t){var o=new this.constructor(n);return i(this,new c(e,t,o)),o},o.all=function(e){var n=Array.prototype.slice.call(e);return new o(function(e,t){function o(r,u){try{if(u&&(\"object\"==typeof u||\"function\"==typeof u)){var f=u.then;if(\"function\"==typeof f)return void f.call(u,function(e){o(r,e)},t)}n[r]=u,0===--i&&e(n)}catch(c){t(c)}}if(0===n.length)return e([]);for(var i=n.length,r=0;r<n.length;r++)o(r,n[r])})},o.resolve=function(e){return e&&\"object\"==typeof e&&e.constructor===o?e:new o(function(n){n(e)})},o.reject=function(e){return new o(function(n,t){t(e)})},o.race=function(e){return new o(function(n,t){for(var o=0,i=e.length;o<i;o++)e[o].then(n,t)})},o._immediateFn=\"function\"==typeof setImmediate&&function(e){setImmediate(e)}||function(e){a(e,0)},o._unhandledRejectionFn=function(e){\"undefined\"!=typeof console&&console&&console.warn(\"Possible Unhandled Promise Rejection:\",e)},o._setImmediateFn=function(e){o._immediateFn=e},o._setUnhandledRejectionFn=function(e){o._unhandledRejectionFn=e},\"undefined\"!=typeof module&&module.exports?module.exports=o:e.Promise||(e.Promise=o)}(this);","if (!String.prototype.endsWith) {\r\n    String.prototype.endsWith = function(search, this_len) {\r\n        if (this_len === undefined || this_len > this.length) {\r\n            this_len = this.length;\r\n        }\r\n        return this.substring(this_len - search.length, this_len) === search;\r\n    };\r\n}","if (!String.prototype.includes) {\r\n    String.prototype.includes = function(search, start) {\r\n        'use strict';\r\n        if (typeof start !== 'number') {\r\n            start = 0;\r\n        }\r\n\r\n        if (start + search.length > this.length) {\r\n            return false;\r\n        } else {\r\n            return this.indexOf(search, start) !== -1;\r\n        }\r\n    };\r\n}","if (!String.prototype.startsWith) {\r\n    String.prototype.startsWith = function(search, pos) {\r\n        return this.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\r\n    };\r\n}","/*global define, window, document*/\r\n\r\n//Polyfill for Object.create.\r\nif (typeof Object.create !== 'function') {\r\n    Object.create = (function () {\r\n        \"use strict\";\r\n        var Temp = function () {};\r\n        return function (prototype) {\r\n            if (arguments.length > 1) {\r\n                throw new Error('Second argument not supported');\r\n            }\r\n            if (typeof prototype !== 'object') {\r\n                throw new TypeError('Argument must be an object');\r\n            }\r\n            Temp.prototype = prototype;\r\n            var result = new Temp();\r\n            Temp.prototype = null;\r\n            return result;\r\n        };\r\n    }());\r\n}\r\n\r\n(function (root, factory) {\r\n    \"use strict\";\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(\"Behaviors\", [\"jquery\"], factory);\r\n    } else {\r\n        root.Behaviors = factory(root.jQuery);\r\n    }\r\n}(this, function ($) {\r\n    \"use strict\";\r\n\r\n    var module = {},\r\n        behavior_registry = {},\r\n        content_ready_listeners = [],\r\n        ElementMissingError = error(\"ElementMissingError\");\r\n    \r\n    /* Throttle an event handler.\r\n     *\r\n     * Returns a function which, no matter how frequently it's called, will\r\n     * only trigger a maximum of once per timeout period. More specifically,\r\n     * the first event will always be processed, then, no events will process\r\n     * until the end of the timeout period. If one or more events occurred\r\n     * during this period, the last event recieved will trigger immediately\r\n     * after the end of the timeout period, as well as restart the throttling\r\n     * period. Any preceding events will be discarded.\r\n     *\r\n     * Not to be confused with a debounce, which only fires the event handler\r\n     * at the end of a string of events spaced closer than the timeout period.\r\n     *\r\n     * The nature of this function means that any passed in function's return\r\n     * value will be discarded.\r\n     */\r\n    function throttle_single(func, timeout) {\r\n        var lastTimeout, afterLastArgs, afterLastThis;\r\n\r\n        function unthrottle() {\r\n            if (afterLastArgs !== undefined) {\r\n                func.apply(afterLastThis, afterLastArgs);\r\n                afterLastArgs = undefined;\r\n                lastTimeout = window.setTimeout(unthrottle, timeout);\r\n            } else {\r\n                lastTimeout = undefined;\r\n            }\r\n        }\r\n\r\n        return function () {\r\n            var myThis = this, myArgs = [], i;\r\n\r\n            for (i = 0; i < arguments.length; i += 1) {\r\n                myArgs.push(arguments[i]);\r\n            }\r\n\r\n            if (lastTimeout === undefined) {\r\n                func.apply(myThis, myArgs);\r\n                lastTimeout = window.setTimeout(unthrottle, timeout);\r\n            } else {\r\n                afterLastArgs = myArgs;\r\n                afterLastThis = myThis;\r\n            }\r\n        };\r\n    }\r\n\r\n    function Behavior(elem) {\r\n        //Do something to elem\r\n        this.$elem = $(elem);\r\n    }\r\n\r\n    /* Find a behavior's markup.\r\n     *\r\n     * The $context argument passed to this function is the jQuery element that\r\n     * will be searched for behaviors. Any additional arguments will be passed\r\n     * to Behavior.locate and ultimately to the behavior's constructor.\r\n     */\r\n    Behavior.find_markup = function ($context) {\r\n        var results = [], i, splitArgs = [], Class = this;\r\n\r\n        for (i = 1; i < arguments.length; i += 1) {\r\n            splitArgs.push(arguments[i]);\r\n        }\r\n        \r\n        function processElem(index, elem) {\r\n            var locateArgs = [elem].concat(splitArgs);\r\n\r\n            results.push(Class.locate.apply(Class, locateArgs));\r\n        }\r\n        \r\n        $context.filter(Class.QUERY).each(processElem);\r\n        $context.find(Class.QUERY).each(processElem);\r\n\r\n        return results;\r\n    };\r\n\r\n    /* Locate a behavior onto an element, returning an instance of that\r\n     * behavior that you can work with.\r\n     *\r\n     * A behavior locates onto an element by instantiating an instance of\r\n     * itself and installing it onto the markup's jQuery data. Therefore, we\r\n     * will only instantiate that behavior once; and further calls to .locate\r\n     * instead return the same object. Thus, it is safe to use .locate as a\r\n     * general accessor - it is idempotent.\r\n     *\r\n     * The elem argument indicates the element that the behavior should locate\r\n     * onto. Further arguments are passed onto the constructor.\r\n     *\r\n     * TODO: Is there a non-jQuery way of handling this?\r\n     */\r\n    Behavior.locate = function (elem) {\r\n        var $elem = $(elem), new_object, i, objectArgs = [elem], Class = this,\r\n            rc = $elem.data(\"behaviors-registered-classes\");\r\n        \r\n        if ($elem.length === 0) {\r\n            throw new ElementMissingError(\"Attempted to locate a Behavior onto an empty element query.\");\r\n        }\r\n\r\n        if (rc === undefined) {\r\n            rc = {};\r\n        }\r\n\r\n        if (rc[Class.name] === undefined) {\r\n            //Grab the other arguments\r\n            for (i = 1; i < arguments.length; i += 1) {\r\n                objectArgs.push(arguments[i]);\r\n            }\r\n\r\n            new_object = Object.create(Class.prototype);\r\n            Class.apply(new_object, objectArgs);\r\n            rc[Class.name] = new_object;\r\n        } else {\r\n            new_object = rc[Class.name];\r\n        }\r\n\r\n        $elem.data(\"behaviors-registered-classes\", rc);\r\n\r\n        return new_object;\r\n    };\r\n\r\n    /* Respond to the presence of new content on the page.\r\n     *\r\n     * By default, we attempt to find markup on all children of the context.\r\n     * Subclasses may do something crazier, like say delay behavior processing\r\n     * until some third-party API is loaded.\r\n     *\r\n     * Consider this roughly equivalent to $(document).ready() callbacks.\r\n     */\r\n    Behavior.content_ready = function ($context) {\r\n        var Class = this;\r\n\r\n        Class.find_markup($context);\r\n    };\r\n    \r\n    /* Respond to the impending removal of content from the page.\r\n     * \r\n     * Most behaviors that only attach event handlers to their own content are\r\n     * safe and do not need to implement content removal support: they will\r\n     * inherently \"fall away\".\r\n     * \r\n     * However, behaviors that run a constant animation kernel or attach event\r\n     * handlers to elements outside of their own ownership must provide a\r\n     * mechanism to detach those event handlers and stop those kernels.\r\n     */\r\n    Behavior.content_removal = function ($context) {\r\n        var Class = this,\r\n            $attached_elems = $context.find(Class.QUERY);\r\n        \r\n        //Iterate through each element and see if our behavior has located upon\r\n        //them. We don't just call .find_markup/.locate since we don't want to\r\n        //risk initializing something just to tear it down one cycle later.\r\n        $attached_elems.each(function (index, attach_elem) {\r\n            var $elem = $(attach_elem),\r\n                rc = $elem.data(\"behaviors-registered-classes\");\r\n            \r\n            if (rc === undefined) {\r\n                return;\r\n            }\r\n            \r\n            if (rc[Class.name] === undefined) {\r\n                return;\r\n            }\r\n            \r\n            if (rc[Class.name].deinitialize === undefined) {\r\n                return;\r\n            }\r\n            \r\n            rc[Class.name].deinitialize();\r\n        });\r\n    };\r\n\r\n    /* Register a behavior so that it can respond to global events such as new\r\n     * content becoming ready.\r\n     *\r\n     * It is not always appropriate to register your behavior to recieve load\r\n     * events. Generally, if this is a behavior you would initialize yourself,\r\n     * perhaps with special arguments, then you should not register that here.\r\n     */\r\n    function register_behavior(Class, name) {\r\n        if (name === undefined) {\r\n            name = Class.name;\r\n        }\r\n\r\n        behavior_registry[name] = Class;\r\n    }\r\n    \r\n    /* Register a function that is called when content is ready.\r\n     * \r\n     * This function should only be used for things that are not a Behavior.\r\n     * Proper behaviors should be registered using register_behavior for future\r\n     * uses. Non-behavior listeners get registered here so that future uses of\r\n     * behavior registration do not conflict with non-Behavior listeners.\r\n     */\r\n    function register_content_listener(func) {\r\n        content_ready_listeners.push(func);\r\n    }\r\n\r\n    /* Indicate that some new content is ready.\r\n     *\r\n     * The given content will be passed onto all registered behaviors.\r\n     *\r\n     * CMS/frameworks with their own ready mechanism will need to ship their\r\n     * own replacement/wrapper for this function that pushes calls to this\r\n     * function over to that mechanism; and calls from that mechanism need to\r\n     * come back here.\r\n     */\r\n    function content_ready($context) {\r\n        var k, i;\r\n        \r\n        function do_later(obj, func) {\r\n            window.setTimeout(func.bind(obj, $context), 0);\r\n        }\r\n        \r\n        for (i = 0; i < content_ready_listeners.length; i += 1) {\r\n            do_later(undefined, content_ready_listeners[i]);\r\n        }\r\n\r\n        for (k in behavior_registry) {\r\n            if (behavior_registry.hasOwnProperty(k)) {\r\n                do_later(behavior_registry[k], behavior_registry[k].content_ready);\r\n            }\r\n        }\r\n    }\r\n    \r\n    /* Indicate that content is about to be removed.\r\n     * \r\n     * Registered behaviors with destructors will be called upon to remove any\r\n     * external event handlers or animation kernels preventing them from being\r\n     * terminated by the JS runtime.\r\n     * \r\n     * TODO: Add content_removal listener functions.\r\n     */\r\n    function content_removal($context) {\r\n        var k, i;\r\n        \r\n        function do_later(obj, func) {\r\n            window.setTimeout(func.bind(obj, $context), 0);\r\n        }\r\n        \r\n        for (k in behavior_registry) {\r\n            if (behavior_registry.hasOwnProperty(k)) {\r\n                do_later(behavior_registry[k], behavior_registry[k].content_removal);\r\n            }\r\n        }\r\n    }\r\n    \r\n    function error(error_class_name, ParentClass) {\r\n        if (error_class_name === undefined) {\r\n            throw new Error(\"Please name your error subclass.\");\r\n        }\r\n\r\n        if (!(ParentClass instanceof Function)) {\r\n            ParentClass = Error;\r\n        }\r\n\r\n        var SubError = function (message) {\r\n            var err = new Error(message);\r\n            err.name = error_class_name;\r\n\r\n            this.name = error_class_name;\r\n            this.message = err.message;\r\n            if (err.stack) {\r\n                this.stack = err.stack;\r\n            }\r\n        };\r\n\r\n        SubError.prototype = new ParentClass(\"u dont c me\");\r\n        SubError.prototype.constructor = SubError;\r\n        SubError.prototype.name = error_class_name;\r\n\r\n        delete SubError.prototype.stack;\r\n\r\n        return SubError;\r\n    }\r\n    \r\n    function inherit(ChildClass, ParentClass) {\r\n        var k;\r\n\r\n        //Use the prototyping system to copy methods from parent to child.\r\n        ChildClass.prototype = Object.create(ParentClass.prototype);\r\n        ChildClass.prototype.constructor = ChildClass;\r\n        ChildClass.prototype.parent = ParentClass.prototype;\r\n\r\n        //Manually copy class-level methods from parent to child.\r\n        for (k in ParentClass) {\r\n            if (ParentClass.hasOwnProperty(k)) {\r\n                ChildClass[k] = ParentClass[k];\r\n            }\r\n        }\r\n    }\r\n\r\n    function init(ChildClass, object, args) {\r\n        ChildClass.prototype.parent.constructor.apply(object, args);\r\n    }\r\n    \r\n    /* By default, report the initial page load to registered behaviors.\r\n     */\r\n    $(document).ready(function () {\r\n        content_ready($(document));\r\n    });\r\n    \r\n    module.ElementMissingError = ElementMissingError;\r\n    module.throttle_single = throttle_single;\r\n    module.Behavior = Behavior;\r\n    module.error = error;\r\n    module.inherit = inherit;\r\n    module.init = init;\r\n    module.register_behavior = register_behavior;\r\n    module.content_ready = content_ready;\r\n    module.content_removal = content_removal;\r\n    module.register_content_listener = register_content_listener;\r\n\r\n    return module;\r\n}));\r\n","/**\r\n * Function used to get the height of the admin bar in pixels.\r\n *\r\n * @return {int} The height of the admin bar (in pixels)\r\n */\r\n function get_wp_admin_bar_height(){\r\n    // Start by getting the admin bar\r\n    var admin_bar = document.getElementById( 'wpadminbar' );\r\n    // If the admin bar doesn't exist, just return zero\r\n    if ( !admin_bar ){\r\n        return 0;\r\n    }\r\n    // Otherwise, get the current height\r\n    else {\r\n        return admin_bar.offsetHeight;\r\n    }\r\n}\r\n\r\n/**\r\n * Function for registering callbacks based on a window resize.\r\n *\r\n * @param     {Function}    callback                 The callback\r\n * @param     {object}      context                  The context for the callback\r\n * @param     {int}         window_resize_timeout    The timeout for the window resize\r\n *\r\n * @return    {void}        \r\n */\r\n function bind_callback_to_window_resize(callback, context, window_resize_timeout){\r\n    if ( !window_resize_timeout ){\r\n        window_resize_timeout = 500;\r\n    }\r\n    // To allow for the timeout\r\n    var id;\r\n    window.addEventListener(\"resize\", function(){\r\n        // Clear the timeout\r\n        clearTimeout(id);\r\n        // Create the function and callback\r\n        id = setTimeout(function(){\r\n            callback.call(context);\r\n        }, window_resize_timeout);\r\n    });\r\n}\r\n\r\n/**\r\n * Function used to get the height of the header in pixels.\r\n *\r\n * @return {int} The height of the header (in pixels)\r\n */\r\n function get_header_height(){\r\n    // Start by getting the header\r\n    var header = document.querySelector( 'header' );\r\n    return header.offsetHeight;\r\n}\r\n\r\n/**\r\n * Function used to determine if the header is sticky or not.\r\n *\r\n * @return {bool} True if the header is sticky\r\n */\r\n function header_is_sticky(){\r\n    // Start by getting the header\r\n    var header = document.querySelector( 'header' );\r\n    // Get the classes attached to the header\r\n    header_classes = header.classList;\r\n    return header_classes.contains( 'fl-theme-builder-header-sticky' );\r\n}","(function() {\r\n  var MutationObserver, Util, WeakMap, getComputedStyle, getComputedStyleRX,\r\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\r\n    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\r\n\r\n  Util = (function() {\r\n    function Util() {}\r\n\r\n    Util.prototype.extend = function(custom, defaults) {\r\n      var key, value;\r\n      for (key in defaults) {\r\n        value = defaults[key];\r\n        if (custom[key] == null) {\r\n          custom[key] = value;\r\n        }\r\n      }\r\n      return custom;\r\n    };\r\n\r\n    Util.prototype.isMobile = function(agent) {\r\n      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(agent);\r\n    };\r\n\r\n    Util.prototype.createEvent = function(event, bubble, cancel, detail) {\r\n      var customEvent;\r\n      if (bubble == null) {\r\n        bubble = false;\r\n      }\r\n      if (cancel == null) {\r\n        cancel = false;\r\n      }\r\n      if (detail == null) {\r\n        detail = null;\r\n      }\r\n      if (document.createEvent != null) {\r\n        customEvent = document.createEvent('CustomEvent');\r\n        customEvent.initCustomEvent(event, bubble, cancel, detail);\r\n      } else if (document.createEventObject != null) {\r\n        customEvent = document.createEventObject();\r\n        customEvent.eventType = event;\r\n      } else {\r\n        customEvent.eventName = event;\r\n      }\r\n      return customEvent;\r\n    };\r\n\r\n    Util.prototype.emitEvent = function(elem, event) {\r\n      if (elem.dispatchEvent != null) {\r\n        return elem.dispatchEvent(event);\r\n      } else if (event in (elem != null)) {\r\n        return elem[event]();\r\n      } else if ((\"on\" + event) in (elem != null)) {\r\n        return elem[\"on\" + event]();\r\n      }\r\n    };\r\n\r\n    Util.prototype.addEvent = function(elem, event, fn) {\r\n      if (elem.addEventListener != null) {\r\n        return elem.addEventListener(event, fn, false);\r\n      } else if (elem.attachEvent != null) {\r\n        return elem.attachEvent(\"on\" + event, fn);\r\n      } else {\r\n        return elem[event] = fn;\r\n      }\r\n    };\r\n\r\n    Util.prototype.removeEvent = function(elem, event, fn) {\r\n      if (elem.removeEventListener != null) {\r\n        return elem.removeEventListener(event, fn, false);\r\n      } else if (elem.detachEvent != null) {\r\n        return elem.detachEvent(\"on\" + event, fn);\r\n      } else {\r\n        return delete elem[event];\r\n      }\r\n    };\r\n\r\n    Util.prototype.innerHeight = function() {\r\n      if ('innerHeight' in window) {\r\n        return window.innerHeight;\r\n      } else {\r\n        return document.documentElement.clientHeight;\r\n      }\r\n    };\r\n\r\n    return Util;\r\n\r\n  })();\r\n\r\n  WeakMap = this.WeakMap || this.MozWeakMap || (WeakMap = (function() {\r\n    function WeakMap() {\r\n      this.keys = [];\r\n      this.values = [];\r\n    }\r\n\r\n    WeakMap.prototype.get = function(key) {\r\n      var i, item, j, len, ref;\r\n      ref = this.keys;\r\n      for (i = j = 0, len = ref.length; j < len; i = ++j) {\r\n        item = ref[i];\r\n        if (item === key) {\r\n          return this.values[i];\r\n        }\r\n      }\r\n    };\r\n\r\n    WeakMap.prototype.set = function(key, value) {\r\n      var i, item, j, len, ref;\r\n      ref = this.keys;\r\n      for (i = j = 0, len = ref.length; j < len; i = ++j) {\r\n        item = ref[i];\r\n        if (item === key) {\r\n          this.values[i] = value;\r\n          return;\r\n        }\r\n      }\r\n      this.keys.push(key);\r\n      return this.values.push(value);\r\n    };\r\n\r\n    return WeakMap;\r\n\r\n  })());\r\n\r\n  MutationObserver = this.MutationObserver || this.WebkitMutationObserver || this.MozMutationObserver || (MutationObserver = (function() {\r\n    function MutationObserver() {\r\n      if (typeof console !== \"undefined\" && console !== null) {\r\n        console.warn('MutationObserver is not supported by your browser.');\r\n      }\r\n      if (typeof console !== \"undefined\" && console !== null) {\r\n        console.warn('WOW.js cannot detect dom mutations, please call .sync() after loading new content.');\r\n      }\r\n    }\r\n\r\n    MutationObserver.notSupported = true;\r\n\r\n    MutationObserver.prototype.observe = function() {};\r\n\r\n    return MutationObserver;\r\n\r\n  })());\r\n\r\n  getComputedStyle = this.getComputedStyle || function(el, pseudo) {\r\n    this.getPropertyValue = function(prop) {\r\n      var ref;\r\n      if (prop === 'float') {\r\n        prop = 'styleFloat';\r\n      }\r\n      if (getComputedStyleRX.test(prop)) {\r\n        prop.replace(getComputedStyleRX, function(_, _char) {\r\n          return _char.toUpperCase();\r\n        });\r\n      }\r\n      return ((ref = el.currentStyle) != null ? ref[prop] : void 0) || null;\r\n    };\r\n    return this;\r\n  };\r\n\r\n  getComputedStyleRX = /(\\-([a-z]){1})/g;\r\n\r\n  this.WOW = (function() {\r\n    WOW.prototype.defaults = {\r\n      boxClass: 'wow',\r\n      animateClass: 'animated',\r\n      offset: 0,\r\n      mobile: true,\r\n      live: true,\r\n      callback: null,\r\n      scrollContainer: null\r\n    };\r\n\r\n    function WOW(options) {\r\n      if (options == null) {\r\n        options = {};\r\n      }\r\n      this.scrollCallback = bind(this.scrollCallback, this);\r\n      this.scrollHandler = bind(this.scrollHandler, this);\r\n      this.resetAnimation = bind(this.resetAnimation, this);\r\n      this.start = bind(this.start, this);\r\n      this.scrolled = true;\r\n      this.config = this.util().extend(options, this.defaults);\r\n      if (options.scrollContainer != null) {\r\n        this.config.scrollContainer = document.querySelector(options.scrollContainer);\r\n      }\r\n      this.animationNameCache = new WeakMap();\r\n      this.wowEvent = this.util().createEvent(this.config.boxClass);\r\n    }\r\n\r\n    WOW.prototype.init = function() {\r\n      var ref;\r\n      this.element = window.document.documentElement;\r\n      if ((ref = document.readyState) === \"interactive\" || ref === \"complete\") {\r\n        this.start();\r\n      } else {\r\n        this.util().addEvent(document, 'DOMContentLoaded', this.start);\r\n      }\r\n      return this.finished = [];\r\n    };\r\n\r\n    WOW.prototype.start = function() {\r\n      var box, j, len, ref;\r\n      this.stopped = false;\r\n      this.boxes = (function() {\r\n        var j, len, ref, results;\r\n        ref = this.element.querySelectorAll(\".\" + this.config.boxClass);\r\n        results = [];\r\n        for (j = 0, len = ref.length; j < len; j++) {\r\n          box = ref[j];\r\n          results.push(box);\r\n        }\r\n        return results;\r\n      }).call(this);\r\n      this.all = (function() {\r\n        var j, len, ref, results;\r\n        ref = this.boxes;\r\n        results = [];\r\n        for (j = 0, len = ref.length; j < len; j++) {\r\n          box = ref[j];\r\n          results.push(box);\r\n        }\r\n        return results;\r\n      }).call(this);\r\n      if (this.boxes.length) {\r\n        if (this.disabled()) {\r\n          this.resetStyle();\r\n        } else {\r\n          ref = this.boxes;\r\n          for (j = 0, len = ref.length; j < len; j++) {\r\n            box = ref[j];\r\n            this.applyStyle(box, true);\r\n          }\r\n        }\r\n      }\r\n      if (!this.disabled()) {\r\n        this.util().addEvent(this.config.scrollContainer || window, 'scroll', this.scrollHandler);\r\n        this.util().addEvent(window, 'resize', this.scrollHandler);\r\n        this.interval = setInterval(this.scrollCallback, 50);\r\n      }\r\n      if (this.config.live) {\r\n        return new MutationObserver((function(_this) {\r\n          return function(records) {\r\n            var k, len1, node, record, results;\r\n            results = [];\r\n            for (k = 0, len1 = records.length; k < len1; k++) {\r\n              record = records[k];\r\n              results.push((function() {\r\n                var l, len2, ref1, results1;\r\n                ref1 = record.addedNodes || [];\r\n                results1 = [];\r\n                for (l = 0, len2 = ref1.length; l < len2; l++) {\r\n                  node = ref1[l];\r\n                  results1.push(this.doSync(node));\r\n                }\r\n                return results1;\r\n              }).call(_this));\r\n            }\r\n            return results;\r\n          };\r\n        })(this)).observe(document.body, {\r\n          childList: true,\r\n          subtree: true\r\n        });\r\n      }\r\n    };\r\n\r\n    WOW.prototype.stop = function() {\r\n      this.stopped = true;\r\n      this.util().removeEvent(this.config.scrollContainer || window, 'scroll', this.scrollHandler);\r\n      this.util().removeEvent(window, 'resize', this.scrollHandler);\r\n      if (this.interval != null) {\r\n        return clearInterval(this.interval);\r\n      }\r\n    };\r\n\r\n    WOW.prototype.sync = function(element) {\r\n      if (MutationObserver.notSupported) {\r\n        return this.doSync(this.element);\r\n      }\r\n    };\r\n\r\n    WOW.prototype.doSync = function(element) {\r\n      var box, j, len, ref, results;\r\n      if (element == null) {\r\n        element = this.element;\r\n      }\r\n      if (element.nodeType !== 1) {\r\n        return;\r\n      }\r\n      element = element.parentNode || element;\r\n      ref = element.querySelectorAll(\".\" + this.config.boxClass);\r\n      results = [];\r\n      for (j = 0, len = ref.length; j < len; j++) {\r\n        box = ref[j];\r\n        if (indexOf.call(this.all, box) < 0) {\r\n          this.boxes.push(box);\r\n          this.all.push(box);\r\n          if (this.stopped || this.disabled()) {\r\n            this.resetStyle();\r\n          } else {\r\n            this.applyStyle(box, true);\r\n          }\r\n          results.push(this.scrolled = true);\r\n        } else {\r\n          results.push(void 0);\r\n        }\r\n      }\r\n      return results;\r\n    };\r\n\r\n    WOW.prototype.show = function(box) {\r\n      this.applyStyle(box);\r\n      box.className = box.className + \" \" + this.config.animateClass;\r\n      if (this.config.callback != null) {\r\n        this.config.callback(box);\r\n      }\r\n      this.util().emitEvent(box, this.wowEvent);\r\n      this.util().addEvent(box, 'animationend', this.resetAnimation);\r\n      this.util().addEvent(box, 'oanimationend', this.resetAnimation);\r\n      this.util().addEvent(box, 'webkitAnimationEnd', this.resetAnimation);\r\n      this.util().addEvent(box, 'MSAnimationEnd', this.resetAnimation);\r\n      return box;\r\n    };\r\n\r\n    WOW.prototype.applyStyle = function(box, hidden) {\r\n      var delay, duration, iteration;\r\n      duration = box.getAttribute('data-wow-duration');\r\n      delay = box.getAttribute('data-wow-delay');\r\n      iteration = box.getAttribute('data-wow-iteration');\r\n      return this.animate((function(_this) {\r\n        return function() {\r\n          return _this.customStyle(box, hidden, duration, delay, iteration);\r\n        };\r\n      })(this));\r\n    };\r\n\r\n    WOW.prototype.animate = (function() {\r\n      if ('requestAnimationFrame' in window) {\r\n        return function(callback) {\r\n          return window.requestAnimationFrame(callback);\r\n        };\r\n      } else {\r\n        return function(callback) {\r\n          return callback();\r\n        };\r\n      }\r\n    })();\r\n\r\n    WOW.prototype.resetStyle = function() {\r\n      var box, j, len, ref, results;\r\n      ref = this.boxes;\r\n      results = [];\r\n      for (j = 0, len = ref.length; j < len; j++) {\r\n        box = ref[j];\r\n        results.push(box.style.visibility = 'visible');\r\n      }\r\n      return results;\r\n    };\r\n\r\n    WOW.prototype.resetAnimation = function(event) {\r\n      var target;\r\n      if (event.type.toLowerCase().indexOf('animationend') >= 0) {\r\n        target = event.target || event.srcElement;\r\n        return target.className = target.className.replace(this.config.animateClass, '').trim();\r\n      }\r\n    };\r\n\r\n    WOW.prototype.customStyle = function(box, hidden, duration, delay, iteration) {\r\n      if (hidden) {\r\n        this.cacheAnimationName(box);\r\n      }\r\n      box.style.visibility = hidden ? 'hidden' : 'visible';\r\n      if (duration) {\r\n        this.vendorSet(box.style, {\r\n          animationDuration: duration\r\n        });\r\n      }\r\n      if (delay) {\r\n        this.vendorSet(box.style, {\r\n          animationDelay: delay\r\n        });\r\n      }\r\n      if (iteration) {\r\n        this.vendorSet(box.style, {\r\n          animationIterationCount: iteration\r\n        });\r\n      }\r\n      this.vendorSet(box.style, {\r\n        animationName: hidden ? 'none' : this.cachedAnimationName(box)\r\n      });\r\n      return box;\r\n    };\r\n\r\n    WOW.prototype.vendors = [\"moz\", \"webkit\"];\r\n\r\n    WOW.prototype.vendorSet = function(elem, properties) {\r\n      var name, results, value, vendor;\r\n      results = [];\r\n      for (name in properties) {\r\n        value = properties[name];\r\n        elem[\"\" + name] = value;\r\n        results.push((function() {\r\n          var j, len, ref, results1;\r\n          ref = this.vendors;\r\n          results1 = [];\r\n          for (j = 0, len = ref.length; j < len; j++) {\r\n            vendor = ref[j];\r\n            results1.push(elem[\"\" + vendor + (name.charAt(0).toUpperCase()) + (name.substr(1))] = value);\r\n          }\r\n          return results1;\r\n        }).call(this));\r\n      }\r\n      return results;\r\n    };\r\n\r\n    WOW.prototype.vendorCSS = function(elem, property) {\r\n      var j, len, ref, result, style, vendor;\r\n      style = getComputedStyle(elem);\r\n      result = style.getPropertyCSSValue(property);\r\n      ref = this.vendors;\r\n      for (j = 0, len = ref.length; j < len; j++) {\r\n        vendor = ref[j];\r\n        result = result || style.getPropertyCSSValue(\"-\" + vendor + \"-\" + property);\r\n      }\r\n      return result;\r\n    };\r\n\r\n    WOW.prototype.animationName = function(box) {\r\n      var animationName;\r\n      try {\r\n        animationName = this.vendorCSS(box, 'animation-name').cssText;\r\n      } catch (_error) {\r\n        animationName = getComputedStyle(box).getPropertyValue('animation-name');\r\n      }\r\n      if (animationName === 'none') {\r\n        return '';\r\n      } else {\r\n        return animationName;\r\n      }\r\n    };\r\n\r\n    WOW.prototype.cacheAnimationName = function(box) {\r\n      return this.animationNameCache.set(box, this.animationName(box));\r\n    };\r\n\r\n    WOW.prototype.cachedAnimationName = function(box) {\r\n      return this.animationNameCache.get(box);\r\n    };\r\n\r\n    WOW.prototype.scrollHandler = function() {\r\n      return this.scrolled = true;\r\n    };\r\n\r\n    WOW.prototype.scrollCallback = function() {\r\n      var box;\r\n      if (this.scrolled) {\r\n        this.scrolled = false;\r\n        this.boxes = (function() {\r\n          var j, len, ref, results;\r\n          ref = this.boxes;\r\n          results = [];\r\n          for (j = 0, len = ref.length; j < len; j++) {\r\n            box = ref[j];\r\n            if (!(box)) {\r\n              continue;\r\n            }\r\n            if (this.isVisible(box)) {\r\n              this.show(box);\r\n              continue;\r\n            }\r\n            results.push(box);\r\n          }\r\n          return results;\r\n        }).call(this);\r\n        if (!(this.boxes.length || this.config.live)) {\r\n          return this.stop();\r\n        }\r\n      }\r\n    };\r\n\r\n    WOW.prototype.offsetTop = function(element) {\r\n      var top;\r\n      while (element.offsetTop === void 0) {\r\n        element = element.parentNode;\r\n      }\r\n      top = element.offsetTop;\r\n      while (element = element.offsetParent) {\r\n        top += element.offsetTop;\r\n      }\r\n      return top;\r\n    };\r\n\r\n    WOW.prototype.isVisible = function(box) {\r\n      var bottom, offset, top, viewBottom, viewTop;\r\n      offset = box.getAttribute('data-wow-offset') || this.config.offset;\r\n      viewTop = (this.config.scrollContainer && this.config.scrollContainer.scrollTop) || window.pageYOffset;\r\n      viewBottom = viewTop + Math.min(this.element.clientHeight, this.util().innerHeight()) - offset;\r\n      top = this.offsetTop(box);\r\n      bottom = top + box.clientHeight;\r\n      return top <= viewBottom && bottom >= viewTop;\r\n    };\r\n\r\n    WOW.prototype.util = function() {\r\n      return this._util != null ? this._util : this._util = new Util();\r\n    };\r\n\r\n    WOW.prototype.disabled = function() {\r\n      return !this.config.mobile && this.util().isMobile(navigator.userAgent);\r\n    };\r\n\r\n    return WOW;\r\n\r\n  })();\r\n\r\n}).call(this);\r\n","/*global define, console, window, HTMLImageElement, Promise*/\r\n\r\n(function (root, factory) {\r\n    \"use strict\";\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(\"AtlasPlayer\", [\"jquery\", \"Behaviors\"], factory);\r\n    } else {\r\n        root.AtlasPlayer = factory(root.jQuery, root.Behaviors);\r\n    }\r\n}(this, function ($, Behaviors) {\r\n    \"use strict\";\r\n    var module = {};\r\n\r\n    /* A Behavior that plays an image atlas on a canvas.\r\n     *\r\n     * Atlas description format is that which is generated by the following\r\n     * Photoshop script: https://github.com/tonioloewald/Layer-Group-Atlas\r\n     */\r\n    function AtlasPlayer() {\r\n        Behaviors.init(AtlasPlayer, this, arguments);\r\n\r\n        this.deinitialize_stop = false;\r\n\r\n        this.$canvas = this.$elem;\r\n        if (!this.$canvas.is(\"canvas\")) {\r\n            this.$canvas = this.$elem.find(\"canvas\");\r\n        }\r\n\r\n        this.context = this.$canvas[0].getContext(\"2d\");\r\n\r\n        this.image = undefined;\r\n        this.atlas_data = undefined;\r\n\r\n        //TODO: Make configurable\r\n        this.anim_player_running = false;\r\n\r\n        this.ready().then(function () {\r\n            $(window).on(\"resize\", this.size_canvas_to_fit.bind(this));\r\n            \r\n            this.anim_length = this.find_anim_length();\r\n            \r\n            if (this.atlas_data.autoplay === true) {\r\n                this.play();\r\n            }\r\n        }.bind(this));\r\n    }\r\n\r\n    Behaviors.inherit(AtlasPlayer, Behaviors.Behavior);\r\n\r\n    AtlasPlayer.QUERY = \"[data-atlasplayer]\";\r\n\r\n    /* Cause AtlasPlayer to ensure it's image and atlas are ready.\r\n     *\r\n     * Returns a promise which resolves when the atlas is ready for playback.\r\n     * Promise will reject if the image is an image tag which has failed to\r\n     * load.\r\n     */\r\n    AtlasPlayer.prototype.ready = function () {\r\n        if (this.ready_promise === undefined) {\r\n            this.ready_promise = new Promise(function (resolve, reject) {\r\n                this.ready_resolve = resolve;\r\n                this.ready_reject = reject;\r\n            }.bind(this));\r\n\r\n            this.find_image();\r\n            this.find_atlas();\r\n            this.is_ready();\r\n        }\r\n\r\n        return this.ready_promise;\r\n    };\r\n\r\n    /* Determine if the atlas is ready for playback.\r\n     *\r\n     * Calling this function also has the side effect of resolving the ready\r\n     * promise if it has not already been done. If this function returns true\r\n     * for the first time, then the promise has been resolved. If it returns\r\n     * false, it may have been rejected (say, if the image fails to load).\r\n     */\r\n    AtlasPlayer.prototype.is_ready = function () {\r\n        var image_ready, atlas_ready, total_ready;\r\n\r\n        if (this.image === undefined) {\r\n            image_ready = false;\r\n        } else if (this.image.constructor === HTMLImageElement) {\r\n            if (this.image.complete) {\r\n                if (this.image.naturalHeight === 0) {\r\n                    //Something has gone horribly wrong\r\n                    this.ready_reject();\r\n                    image_ready = false;\r\n                } else {\r\n                    image_ready = true;\r\n                }\r\n            } else {\r\n                image_ready = false;\r\n            }\r\n        } else {\r\n            //Other drawables are presumed already loaded\r\n            image_ready = true;\r\n        }\r\n\r\n        if (this.atlas_data !== undefined && this.atlas_data.then !== undefined) {\r\n            //Not ready, since a promise was provided\r\n            atlas_ready = false;\r\n        } else {\r\n            atlas_ready = this.atlas_data !== undefined;\r\n        }\r\n\r\n        total_ready = image_ready && atlas_ready;\r\n\r\n        if (total_ready) {\r\n            this.ready_resolve();\r\n        }\r\n\r\n        return total_ready;\r\n    };\r\n\r\n    /* Called to find the image we're drawing our animation from, if present.\r\n     */\r\n    AtlasPlayer.prototype.find_image = function () {\r\n        var image_id = this.$elem.data(\"atlasplayer-image\");\r\n\r\n        if (this.image !== undefined) {\r\n            return;\r\n        }\r\n\r\n        if (image_id !== undefined) {\r\n            this.image = $(image_id)[0];\r\n\r\n            if (this.image.constructor === HTMLImageElement) {\r\n                $(this.image).on(\"load\", this.is_ready.bind(this));\r\n            }\r\n        }\r\n    };\r\n\r\n    /* Called to find and load our atlas data.\r\n     */\r\n    AtlasPlayer.prototype.find_atlas = function () {\r\n        var atlas_data = this.$elem.data(\"atlasplayer-data\");\r\n\r\n        if (this.atlas_data !== undefined) {\r\n            return;\r\n        }\r\n\r\n        if (typeof atlas_data === \"string\") {\r\n            //Atlas data is a URL.\r\n            this.atlas_data = this.load_atlas_data(atlas_data)\r\n                .then(function (data) {\r\n                    this.atlas_data = data;\r\n                    this.is_ready();\r\n                }.bind(this))\r\n                .catch(this.ready_reject);\r\n        } else {\r\n            //Atlas data is immediately provided.\r\n            this.atlas_data = atlas_data;\r\n        }\r\n    };\r\n    \r\n    AtlasPlayer.prototype.find_anim_length = function () {\r\n        var anim_length = this.$elem.data(\"atlasplayer-animlength\");\r\n        \r\n        if (anim_length === undefined) {\r\n            anim_length = this.atlas_data.time;\r\n        }\r\n        \r\n        if (anim_length === undefined) {\r\n            anim_length = \"5s\";\r\n        }\r\n        \r\n        anim_length = parseFloat(anim_length, 10);\r\n        \r\n        if (isNaN(anim_length) || anim_length === 0) {\r\n            anim_length = 5000;\r\n        } else {\r\n            anim_length *= 1000;\r\n        }\r\n        \r\n        return anim_length;\r\n    };\r\n\r\n    /* Load the atlas data.\r\n     *\r\n     * Returns a promise which resolves when the atlas data has loaded.\r\n     */\r\n    AtlasPlayer.prototype.load_atlas_data = function (url) {\r\n        var promiseResolve, promiseReject,\r\n            myPromise = new Promise(function (resolve, reject) {\r\n                promiseResolve = resolve;\r\n                promiseReject = reject;\r\n            });\r\n\r\n        $.ajax({\r\n            \"url\": url,\r\n            \"dataType\": \"json\"\r\n        }).done(function (data) {\r\n            promiseResolve(data);\r\n        }).fail(function (jqXHR, textStatus, errorThrown) {\r\n            promiseReject([textStatus, errorThrown]);\r\n        });\r\n\r\n        return myPromise;\r\n    };\r\n\r\n    /* Cause the canvas to draw a particular atlas frame.\r\n     */\r\n    AtlasPlayer.prototype.draw_frame = function (frame_id) {\r\n        var layerData = this.atlas_data.layers[this.atlas_data.layers.length - frame_id - 1];\r\n        \r\n        if (layerData.width <= 0) {\r\n            return;\r\n        }\r\n        \r\n        if (layerData.height <= 0) {\r\n            return;\r\n        }\r\n\r\n        this.context.drawImage(this.image,\r\n                               //Location of the atlas slice\r\n                               layerData.packedOrigin.x * this.image_x_space,\r\n                               layerData.packedOrigin.y * this.image_y_space,\r\n                               layerData.width * this.image_x_space,\r\n                               layerData.height * this.image_y_space,\r\n                               //Where we want it\r\n                               layerData.left,\r\n                               layerData.top,\r\n                               layerData.width,\r\n                               layerData.height\r\n                              );\r\n    };\r\n    \r\n    /* Size the canvas to fit our data.\r\n     */\r\n    AtlasPlayer.prototype.size_canvas_to_fit = function () {\r\n        //Determine the device-specific pixel size of this AtlasPlayer.\r\n        this.canvas_scale_factor = window.devicePixelRatio;\r\n        this.$canvas[0].width = this.$canvas.width() * this.canvas_scale_factor;\r\n        this.$canvas[0].height = this.$canvas.height() * this.canvas_scale_factor;\r\n        \r\n        //Reset the current canvas transform, if any.\r\n        this.context.setTransform(1, 0, 0, 1, 0, 0);\r\n        \r\n        //Scale down our coordinate space\r\n        this.context.scale(this.canvas_scale_factor, this.canvas_scale_factor);\r\n        \r\n        //Determine if cropping is needed.\r\n        this.css_aspect_ratio = this.$canvas.width() / this.$canvas.height();\r\n        this.atlas_aspect_ratio = this.atlas_data.width / this.atlas_data.height;\r\n        if (this.css_aspect_ratio > this.atlas_aspect_ratio) {\r\n            this.context.translate(0, (this.$canvas.width() / this.atlas_aspect_ratio - this.$canvas.height()) / -2);\r\n            \r\n            this.canvas_transform_scale_factor = this.$canvas.width() / this.atlas_aspect_ratio / this.atlas_data.height;\r\n            this.context.scale(this.canvas_transform_scale_factor, this.canvas_transform_scale_factor);\r\n        } else if (this.css_aspect_ratio < this.atlas_aspect_ratio) {\r\n            this.context.translate((this.$canvas.height() * this.atlas_aspect_ratio - this.$canvas.width()) / -2, 0);\r\n            \r\n            this.canvas_transform_scale_factor = this.$canvas.height() * this.atlas_aspect_ratio / this.atlas_data.width;\r\n            this.context.scale(this.canvas_transform_scale_factor, this.canvas_transform_scale_factor);\r\n        }\r\n        \r\n        //We also need to determine if our atlas image is scaled down and adjust\r\n        //our source coordinate space to match.\r\n        this.image_x_space = this.image.width / this.atlas_data.atlas.width;\r\n        this.image_y_space = this.image.height / this.atlas_data.atlas.height;\r\n        \r\n        //Since we just clared the canvas, if we aren't animated, then we need\r\n        //to manually repopulate ourselves:\r\n        if (this.last_frame_drawn !== undefined) {\r\n            this.draw_frame(this.last_frame_drawn);\r\n        }\r\n    };\r\n\r\n    AtlasPlayer.prototype.animation_krnl = function (time) {\r\n        var step, frame, total_frames;\r\n\r\n        if (this.deinitialize_stop) {\r\n            return;\r\n        }\r\n        \r\n        if (this.playing === false) {\r\n            this.anim_player_running = false;\r\n            \r\n            if (this.on_animation_complete) {\r\n                this.on_animation_complete();\r\n                this.on_animation_complete = undefined;\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (this.anim_first_time === undefined) {\r\n            this.anim_first_time = time;\r\n            window.requestAnimationFrame(this.animation_krnl.bind(this));\r\n            return;\r\n        }\r\n        \r\n        if (this.anim_length === undefined) {\r\n            //Don't animate if we haven't loaded yet\r\n            window.requestAnimationFrame(this.animation_krnl.bind(this));\r\n            return;\r\n        }\r\n\r\n        total_frames = this.atlas_data.layers.length;\r\n        step = this.anim_length / total_frames;\r\n        time = time - this.anim_first_time;\r\n        frame = Math.max(Math.min(Math.round(time / step), total_frames - 1), 0);\r\n\r\n        if (this.reverse) {\r\n            frame = (total_frames - 1) - frame;\r\n        }\r\n\r\n        this.context.clearRect(0,0,this.atlas_data.width, this.atlas_data.height);\r\n        this.draw_frame(frame);\r\n        \r\n        this.last_frame_drawn = frame;\r\n        \r\n        if (time > this.anim_length) {\r\n            if (this.should_loop()) {\r\n                this.anim_first_time = undefined;\r\n            } else {\r\n                this.anim_player_running = false;\r\n                \r\n                if (this.on_animation_complete) {\r\n                    this.on_animation_complete();\r\n                    this.on_animation_complete = undefined;\r\n                }\r\n                return;\r\n            }\r\n        }\r\n        \r\n        window.requestAnimationFrame(this.animation_krnl.bind(this));\r\n    };\r\n\r\n    AtlasPlayer.prototype.update_animation_state = function () {\r\n        if (this.playing && this.anim_player_running === false) {\r\n            if (this.on_animation_complete) {\r\n                this.on_animation_complete();\r\n            }\r\n            \r\n            this.animation_promise = new Promise(function (resolve, reject) {\r\n                this.on_animation_complete = resolve;\r\n            }.bind(this));\r\n            \r\n            this.size_canvas_to_fit();\r\n            this.anim_player_running = true;\r\n            window.requestAnimationFrame(this.animation_krnl.bind(this));\r\n        }\r\n        \r\n        return this.animation_promise;\r\n    };\r\n    \r\n    AtlasPlayer.prototype.play = function () {\r\n        this.playing = true;\r\n        this.reverse = false;\r\n        this.anim_first_time = undefined;\r\n        return this.update_animation_state();\r\n    };\r\n\r\n    AtlasPlayer.prototype.play_reverse = function () {\r\n        this.playing = true;\r\n        this.reverse = true;\r\n        this.anim_first_time = undefined;\r\n        return this.update_animation_state();\r\n    };\r\n    \r\n    /* Request the animation to stop playing on the next frame.\r\n     * \r\n     * This function also resets the animation to play again.\r\n     */\r\n    AtlasPlayer.prototype.stop = function () {\r\n        //A bit of subtlety: We don't clear anim_player_running since we don't\r\n        //cancel the animation frame when you stop the animation. We instead\r\n        //wait for the animation to stop itself.\r\n        this.playing = false;\r\n        this.reverse = false;\r\n        this.anim_first_time = undefined;\r\n        return this.update_animation_state();\r\n    };\r\n    \r\n    AtlasPlayer.prototype.seek = function (frame) {\r\n        if (frame < 0) {\r\n            frame = this.atlas_data.layers.length - frame - 2;\r\n        }\r\n\r\n        this.context.clearRect(0,0,this.atlas_data.width, this.atlas_data.height);\r\n        this.draw_frame(frame);\r\n\r\n        this.last_frame_drawn = frame;\r\n    };\r\n    \r\n    /* Determine if this AtlasPlayer should loop or not.\r\n     */\r\n    AtlasPlayer.prototype.should_loop = function () {\r\n        var loop_force = this.$elem.data(\"atlasplayer-loop\"),\r\n            loop_deny = this.$elem.data(\"atlasplayer-once\");\r\n        \r\n        if (loop_force !== undefined) {\r\n            return true;\r\n        } else if (loop_deny !== undefined) {\r\n            return false;\r\n        } else {\r\n            return this.atlas_data.loop === true;\r\n        }\r\n    };\r\n\r\n    Behaviors.register_behavior(AtlasPlayer);\r\n\r\n    module.AtlasPlayer = AtlasPlayer;\r\n\r\n    return module;\r\n}));\r\n","/*global define, console, document, window*/\r\n/*jslint continue:true*/\r\n(function (root, factory) {\r\n    \"use strict\";\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(\"AffixColumn\", [\"jquery\", \"Behaviors\"], factory);\r\n    } else {\r\n        root.AffixColumn = factory(root.jQuery, root.Behaviors);\r\n    }\r\n}(this, function ($, Behaviors) {\r\n    \"use strict\";\r\n\r\n    var module = {};\r\n    \r\n    function $do(that, target) {\r\n        return function () {\r\n            target.apply(that, arguments);\r\n        };\r\n    }\r\n    \r\n    /* An Affix root is an element which is used to determine the edges of the\r\n     * region that columns stick to. It also provides the core event handlers\r\n     * to drive the AffixColumn and AffixRow behaviors.\r\n     */\r\n    function Affix(elem, scrollElem) {\r\n        Behaviors.init(Affix, this, arguments);\r\n\r\n        this.height = this.$elem.height();\r\n        this.offsetTop = this.$elem.offset().top;\r\n        \r\n        this.columns = [];\r\n        this.$scrollElem = $(scrollElem || document);\r\n        this.$scrollHeightElem = this.$scrollElem;\r\n        \r\n        //weird DOM quirk\r\n        if (this.$scrollElem[0] === document) {\r\n            this.$scrollHeightElem = $(window);\r\n        }\r\n        \r\n        this.$alwaysTopElem = $(this.$elem.data(\"affixcolumn-alwaystop\"));\r\n        this.$alwaysBottomElem = $(this.$elem.data(\"affixcolumn-alwaysbottom\"));\r\n        \r\n        this.bind_event_handlers();\r\n        this.find_columns_and_rows();\r\n        \r\n        this.resized();\r\n        this.scroll_changed();\r\n    }\r\n    \r\n    Behaviors.inherit(Affix, Behaviors.Behavior);\r\n    \r\n    Affix.QUERY = \"[data-affixcolumn='root']\";\r\n    \r\n    Affix.prototype.deinitialize = function () {\r\n        this.unbind_event_handlers();\r\n    };\r\n    \r\n    /* Check our alwaystop/alwaysbottom elements and see if they are floating.\r\n     * If so, add their height to the top and bottom adjustments given to the\r\n     * individual columns.\r\n     */\r\n    Affix.prototype.determine_global_floating_adjustment = function () {\r\n        this.globalTopAdjust = 0;\r\n        \r\n        this.$alwaysTopElem.each(function (index, atelem) {\r\n            var $atelem = $(atelem);\r\n            this.globalTopAdjust += $atelem.height();\r\n        }.bind(this));\r\n        \r\n        this.globalBottomAdjust = 0;\r\n        \r\n        this.$alwaysBottomElem.each(function (index, atelem) {\r\n            var $atelem = $(atelem);\r\n            this.globalBottomAdjust += $atelem.height();\r\n        }.bind(this));\r\n    };\r\n\r\n    Affix.prototype.resized = function () {\r\n        var i, maxColHeight = 0, maxColId, heightSum, disp = 0, topAdjust = 0, bottomAdjust = 0;\r\n        \r\n        this.determine_global_floating_adjustment();\r\n        this.height = this.$elem.height();\r\n        \r\n        if (this.columns.length > 0) {\r\n            //Scan top rows to fix their displacement heights and determine top\r\n            //adjustments.\r\n            for (i = 0; i < this.columns.length; i += 1) {\r\n                //Also, kill floating adjustments plz\r\n                this.columns[i].clear_floating_adjustments();\r\n                \r\n                if (!this.columns[i].has_option(\"top\")) {\r\n                    continue;\r\n                }\r\n                \r\n                //Top rows never get a bottom adjustment.\r\n                this.columns[i].set_floating_adjustments(this.globalTopAdjust, topAdjust, 0, 0);\r\n                \r\n                disp = this.columns[i].displacement_height();\r\n                \r\n                this.columns[i].$height_bearing_element().css(\"min-height\", disp + \"px\");\r\n                topAdjust += disp;\r\n            }\r\n            \r\n            //Scan bottom rows to fix their displacement heights and determine top\r\n            //adjustments. This is done in reverse order so that the bottommost\r\n            //bottom row gets the lowest bottom float adjustment.\r\n            for (i = this.columns.length - 1; i >= 0; i -= 1) {\r\n                if (!this.columns[i].has_option(\"bottom\")) {\r\n                    continue;\r\n                }\r\n                \r\n                //Bottom rows never get a top adjustment.\r\n                this.columns[i].set_floating_adjustments(0, 0, this.globalBottomAdjust, bottomAdjust);\r\n                \r\n                disp = this.columns[i].displacement_height();\r\n                \r\n                this.columns[i].$height_bearing_element().css(\"min-height\", disp + \"px\");\r\n                bottomAdjust += disp;\r\n            }\r\n            \r\n            //Scan columns to select the height-bearing column.\r\n            for (i = 0; i < this.columns.length; i += 1) {\r\n                if (!this.columns[i].has_option(\"column\")) {\r\n                    continue;\r\n                }\r\n                \r\n                //Columns get both the top and bottom adjustment.\r\n                this.columns[i].set_floating_adjustments(this.globalTopAdjust, topAdjust, this.globalBottomAdjust, bottomAdjust);\r\n                \r\n                //Determine which column is height bearing for this Affix.\r\n                if (maxColHeight < this.columns[i].displacement_height() &&\r\n                        !this.columns[i].has_option(\"noheightbearing\")) {\r\n                    maxColHeight = this.columns[i].displacement_height();\r\n                    maxColId = i;\r\n                }\r\n                \r\n                this.columns[i].remove_state(\"tallest\");\r\n            }\r\n            \r\n            if (maxColId !== undefined) {\r\n                this.columns[maxColId].add_state(\"tallest\");\r\n            }\r\n        }\r\n    };\r\n    \r\n    Affix.prototype.scroll_changed = function () {\r\n        var i, maxColHeight = 0, maxColId;\r\n        \r\n        this.height = this.$elem.height();\r\n        this.windowHeight = this.$scrollHeightElem.height();\r\n        this.offsetTop = this.$elem.offset().top;\r\n        this.scrollTop = this.$scrollElem.scrollTop();\r\n        this.offsetBottom = this.offsetTop + this.height;\r\n        this.scrollBottom = this.scrollTop + this.windowHeight;\r\n        \r\n        if (this.columns.length > 0) {\r\n            for (i = 0; i < this.columns.length; i += 1) {\r\n                this.columns[i].viewport_changed(this.height, this.offsetTop, this.offsetBottom, this.scrollTop, this.scrollBottom);\r\n            }\r\n        }\r\n    };\r\n    \r\n    Affix.prototype.unbind_event_handlers = function () {\r\n        if (this.scroll_handler !== undefined) {\r\n            this.$scrollElem.off(\"scroll\", this.scroll_handler);\r\n        }\r\n        \r\n        if (this.resize_handler !== undefined) {\r\n            $(window).off(\"resize\", this.resize_handler);\r\n        }\r\n    };\r\n    \r\n    Affix.prototype.bind_event_handlers = function () {\r\n        this.unbind_event_handlers();\r\n        \r\n        this.scroll_handler = $do(this, this.scroll_changed);\r\n        this.resize_handler = $do(this, this.resized);\r\n        \r\n        this.$scrollElem.on(\"scroll\", this.scroll_handler);\r\n        $(window).on(\"resize\", this.resize_handler);\r\n        $(document).on(\"load\", this.resize_handler);\r\n        $(\"img\").on(\"load\", this.resize_handler);\r\n    };\r\n    \r\n    Affix.prototype.find_columns_and_rows = function () {\r\n        var $likely_columns = this.$elem.find(AffixColumn.QUERY),\r\n            $likely_roots = this.$elem.find(Affix.QUERY);\r\n\r\n        this.columns = [];\r\n        this.roots = [];\r\n\r\n        $likely_columns.each(function (index, lcelem) {\r\n            var $lcelem = $(lcelem),\r\n                $parent_root = $lcelem.parents().filter(Affix.QUERY).first();\r\n\r\n            if ($parent_root[0] === this.$elem) {\r\n                this.columns.push(AffixColumn.locate($lcelem));\r\n            }\r\n        }.bind(this));\r\n\r\n        $likely_roots.each(function (index, lrelem) {\r\n            var $lrelem = $(lrelem),\r\n                $parent_root = $lrelem.parents().filter(Affix.QUERY).first();\r\n\r\n            if ($parent_root[0] === this.$elem) {\r\n                this.roots.push(Affix.locate($lrelem));\r\n            }\r\n        }.bind(this));\r\n    };\r\n    \r\n    /* An AffixColumn is a normally fixed element which sticks to the top or\r\n     * bottom edges of a scrolling viewport (typically the document).\r\n     * \r\n     * AffixColumn itself contains no event handlers. The parent Affix is\r\n     * responsible for propagating viewport scrolling to it's child Columns.\r\n     * \r\n     * Options may be provided which cause the Column to behave differently.\r\n     * Examples of this include the \"noheightbearing\" option, which prevents\r\n     * your AffixColumn from being marked as tallest for the purposes of parent\r\n     * element height preservation. See the parse_option_list function for more\r\n     * information on the option list format, and has_option for what options\r\n     * are available.\r\n     * \r\n     * The name \"AffixColumn\" is a misnomer. \"Columns\" may be configured as rows\r\n     * or columns in CSS. Orientation of the Column is configured with the\r\n     * column/top/bottom options. If neither is active, \"column\" is assumed.\r\n     */\r\n    function AffixColumn(elem) {\r\n        this.$elem = $(elem);\r\n        this.options = this.parse_option_list(this.$elem.data(\"affixcolumn-options\"));\r\n        \r\n        this.top_adjust = 0;\r\n        this.bottom_adjust = 0;\r\n    }\r\n    \r\n    Behaviors.inherit(AffixColumn, Behaviors.Behavior);\r\n    \r\n    AffixColumn.QUERY = \"[data-affixcolumn='column']\";\r\n    \r\n    /* Calculate the height taken up by the AffixColumn if placed in normal\r\n     * document flow.\r\n     * \r\n     * The floating adjustments currently applied to the column may cause\r\n     * invalid displacement height results to occur. For best results, call\r\n     * clear_floating_adjustments to remove them, and then trigger a viewport\r\n     * update from the Affix root once the height has been measured.\r\n     */\r\n    AffixColumn.prototype.displacement_height = function () {\r\n        return this.$elem.height();\r\n    };\r\n    \r\n    /* Change the top/bottom values that this column floats at.\r\n     * \r\n     * Floating adjustments determine the safe area of space that this element\r\n     * may float at without being overlapped or overlapping top or bottom rows.\r\n     * \r\n     * These will override any top/bottom values set via CSS.\r\n     */\r\n    AffixColumn.prototype.set_floating_adjustments = function (globalTop, top, globalBottom, bottom) {\r\n        this.top_adjust = top;\r\n        this.bottom_adjust = bottom;\r\n        \r\n        this.global_top_adjust = globalTop;\r\n        this.global_bottom_adjust = globalBottom;\r\n    };\r\n    \r\n    /* Remove inline CSS applied to make floating adjustments visually present.\r\n     * \r\n     * You must call this method before querying displacement_height, or you\r\n     * will get invalid results. After calling this method, you must trigger a\r\n     * viewport update by calling scroll_changed on the containing Affix root.\r\n     */\r\n    AffixColumn.prototype.clear_floating_adjustments = function () {\r\n        this.$elem.css(\"top\", \"\");\r\n        this.$elem.css(\"bottom\", \"\");\r\n    };\r\n    \r\n    /* Return the element responsible for propagating our displacement height in\r\n     * normal document flow.\r\n     * \r\n     * By default, the height bearing element is our parent element. We do not\r\n     * have a facility to override this currently.\r\n     */\r\n    AffixColumn.prototype.$height_bearing_element = function () {\r\n        return this.$elem.parent();\r\n    };\r\n    \r\n    AffixColumn.prototype.add_state = function (state) {\r\n        this.$elem.addClass(\"is-AffixColumn--\" + state);\r\n    };\r\n    \r\n    AffixColumn.prototype.remove_state = function (state) {\r\n        this.$elem.removeClass(\"is-AffixColumn--\" + state);\r\n    };\r\n    \r\n    /* Determine if an AffixColumn option applies given the current viewport.\r\n     * \r\n     * Valid options include:\r\n     * \r\n     *  - column: AffixColumn to be oriented vertically aside other columns.\r\n     *    The tallest column is marked as \"tallest\" and considered the height\r\n     *    bearing column, whereby it is expected to be positioned in normal\r\n     *    document flow such that the Affix element can grab it's CSS height.\r\n     * \r\n     *  - top: AffixColumn to be oriented above other columns. Top rows are\r\n     *    given a CSS min-height equal to the sum of their childrens' heights\r\n     *    and their children are assumed to float. This minimum height will be\r\n     *    applied as the top value to any following tops or columns.\r\n     *\r\n     *  - bottom: AffixColumn to be oriented below other columns. Bottom rows\r\n     *    are given a CSS min-height in the same fashion as top rows. This\r\n     *    minimum height will be applied as the bottom value to any preceding\r\n     *    bottoms or columns.\r\n     * \r\n     *  - noheightbearing: Column-oriented AffixColumn to be disqualified from\r\n     *    being marked as a height-bearing column.\r\n     */\r\n    AffixColumn.prototype.has_option = function (option_string) {\r\n        var i;\r\n        \r\n        for (i = 0; i < this.options.length; i += 1) {\r\n            if (this.options[i].media === null || window.matchMedia(this.options[i].media).matches) {\r\n                //Column enabled by default\r\n                if (option_string === \"column\" &&\r\n                        this.options[i].options.indexOf(\"top\") === -1 &&\r\n                        this.options[i].options.indexOf(\"bottom\") === -1) {\r\n                    return true;\r\n                }\r\n                \r\n                return this.options[i].options.indexOf(option_string) > -1;\r\n            }\r\n        }\r\n        \r\n        if (option_string === \"column\") {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    };\r\n    \r\n    AffixColumn.MATCH_MEDIA_QUERY_REGEX = /\\(([\\s\\S]*)\\)/g;\r\n    \r\n    /* Parse an option list.\r\n     * \r\n     * The option list determines what options are active on a column. It is\r\n     * comma separated. Each comma indicates a new option list for a particular\r\n     * media query. The first media query to match determines the total option\r\n     * set. The final option set may or may not have a media query; if it does\r\n     * not, then it serves as the default option set.\r\n     * \r\n     * This is very analagous to the sizes attribute of <img> tags in modern\r\n     * browsers. Example format:\r\n     * \r\n     *    (min-width: 450px) column noheightbearing, top\r\n     */\r\n    AffixColumn.prototype.parse_option_list = function (option_list_string) {\r\n        var cases, i, j, rval = [], case_obj = {}, match;\r\n        \r\n        if (option_list_string === undefined) {\r\n            option_list_string = \"\";\r\n        }\r\n        \r\n        cases = option_list_string.split(\",\");\r\n        \r\n        for (i = 0; i < cases.length; i += 1) {\r\n            case_obj = {};\r\n            match = this.constructor.MATCH_MEDIA_QUERY_REGEX.exec(cases[i]);\r\n            \r\n            //Reset the string. Sharing regex objects is dirty...\r\n            this.constructor.MATCH_MEDIA_QUERY_REGEX.lastIndex = 0;\r\n            \r\n            if (match === null || match.length === 0) {\r\n                case_obj.options = cases[i].split(\" \");\r\n                case_obj.media = null;\r\n            } else {\r\n                case_obj.options = cases[i].slice(match[0]).split(\" \");\r\n                case_obj.media = match[0];\r\n            }\r\n            \r\n            //Filter empty options\r\n            for (j = 0; j < case_obj.options.length; j += 0) {\r\n                if (case_obj.options[j] === \"\") {\r\n                    case_obj.options.splice(j, 1);\r\n                } else {\r\n                    j += 1;\r\n                }\r\n            }\r\n            \r\n            rval.push(case_obj);\r\n        }\r\n        \r\n        return rval;\r\n    };\r\n    \r\n    /* Internal method used by Affix to communicate to it's children the new\r\n     * parameters of the scroll viewport.\r\n     */\r\n    AffixColumn.prototype.viewport_changed = function (rootHeight, offsetTop, offsetBottom, scrollTop, scrollBottom) {\r\n        var isTopAnchored = this.has_option(\"column\") || this.has_option(\"top\"),\r\n            isBottomAnchored = this.has_option(\"anchorbottom\") || this.has_option(\"bottom\"),\r\n            bottomStateAdjust = true,\r\n            topStateAdjust = true,\r\n            adjustWithoutGlobal = true;\r\n        \r\n        //Remove existing floating adjustments.\r\n        //Otherwise, our displacement height is incorrect.\r\n        this.clear_floating_adjustments();\r\n        \r\n        //Apply affix states.\r\n        if (isTopAnchored && scrollTop + this.global_top_adjust < offsetTop ||\r\n                isBottomAnchored && scrollBottom - this.displacement_height() < offsetTop) {\r\n            this.add_state(\"top\");\r\n            this.remove_state(\"bottom\");\r\n            bottomStateAdjust = false;\r\n        } else if (isTopAnchored && scrollTop + this.top_adjust + this.global_top_adjust + this.displacement_height() + this.bottom_adjust >= offsetBottom ||\r\n                isBottomAnchored && scrollBottom >= offsetBottom) {\r\n            this.remove_state(\"top\");\r\n            this.add_state(\"bottom\");\r\n            topStateAdjust = false;\r\n        } else {\r\n            this.remove_state(\"top\");\r\n            this.remove_state(\"bottom\");\r\n            adjustWithoutGlobal = false;\r\n        }\r\n        \r\n        //Apply floating adjustments.\r\n        if ((this.has_option(\"column\") || this.has_option(\"top\")) && topStateAdjust) {\r\n            if (adjustWithoutGlobal) {\r\n                this.$elem.css(\"top\", this.top_adjust + \"px\");\r\n            } else {\r\n                this.$elem.css(\"top\", this.top_adjust + this.global_top_adjust + \"px\");\r\n            }\r\n        }\r\n        \r\n        if ((this.has_option(\"column\") || this.has_option(\"bottom\")) && bottomStateAdjust) {\r\n            if (adjustWithoutGlobal) {\r\n                this.$elem.css(\"bottom\", this.bottom_adjust + \"px\");\r\n            } else {\r\n                this.$elem.css(\"bottom\", this.bottom_adjust + this.global_bottom_adjust + \"px\");\r\n            }\r\n        }\r\n    };\r\n    \r\n    Behaviors.register_behavior(Affix);\r\n\r\n    module.Affix = Affix;\r\n    module.AffixColumn = AffixColumn;\r\n\r\n    return module;\r\n}));\r\n","/*global define, console, document, window*/\r\n(function (root, factory) {\r\n    \"use strict\";\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(\"Animations\", [\"jquery\", \"Behaviors\"], factory);\r\n    } else {\r\n        root.Animations = factory(root.jQuery, root.Behaviors);\r\n    }\r\n}(this, function ($, Behaviors) {\r\n    \"use strict\";\r\n    \r\n    var module = {};\r\n\r\n    /* Watches for the start and end of an animation.\r\n     *\r\n     * The .promise attribute stores a promise which resolves whenever the\r\n     * animation has completed or no animation events were detected over a\r\n     * timeout period of 5 second.\r\n     *\r\n     * An important caveat: Animations with delay longer than 5 seconds will\r\n     * fail to fire events and the animation watcher will trigger the timeout\r\n     * behavior instead. You can avoid this behavior by triggering another\r\n     * animation of any kind during the timeout period and keeping it alive\r\n     * until the delayed animation begins.\r\n     */\r\n    function AnimationWatcher($elem) {\r\n        var Class = this.constructor,\r\n            eventSelector = Class.get_unique_id(),\r\n            that = this,\r\n            evtStartNames = \"animationstart.\" + eventSelector +\r\n                      \" webkitAnimationStart.\" + eventSelector +\r\n                      \" oanimationstart.\" + eventSelector +\r\n                      \" MSAnimationStart.\" + eventSelector,\r\n            evtEndNames = \"animationend.\" + eventSelector +\r\n                      \" webkitAnimationEnd.\" + eventSelector +\r\n                      \" oanimationend.\" + eventSelector +\r\n                      \" MSAnimationEnd.\" + eventSelector,\r\n            animation_start = this.animation_start.bind(this),\r\n            animation_end = this.animation_end.bind(this),\r\n            animation_timeout_delay = 5000;\r\n\r\n        this.eventSelector = eventSelector;\r\n\r\n        this.$elem = $elem;\r\n        this.$elem.on(evtStartNames, animation_start);\r\n        this.$elem.on(evtEndNames, animation_end);\r\n\r\n        if (window.Modernizr && window.Modernizr.cssanimations === false) {\r\n            animation_timeout_delay = 0;\r\n        }\r\n\r\n        this.timeout = window.setTimeout(this.abort_animation.bind(this), animation_timeout_delay);\r\n        this.remaining_animations = [];\r\n\r\n        //We remove event handlers after one of the handlers resolves the\r\n        //animation promise.\r\n        this.promise = new Promise(function (resolve, reject) {\r\n            that.resolve = resolve;\r\n            that.reject = reject;\r\n        }).then(function () {\r\n            that.$elem.off(evtStartNames, animation_start);\r\n            that.$elem.off(evtEndNames, animation_end);\r\n        });\r\n\r\n        console.log(\"ANIMATIONWATCHER\" + this.eventSelector + \": Created\");\r\n    }\r\n\r\n    AnimationWatcher.count = 0;\r\n\r\n    AnimationWatcher.get_unique_id = function () {\r\n        var Class = this,\r\n            sel = \".\" + Class.name + \"_\" + Class.count;\r\n\r\n        Class.count += 1;\r\n        return sel;\r\n    };\r\n\r\n    AnimationWatcher.prototype.animation_start = function (evt) {\r\n        console.log(\"ANIMATIONWATCHER\" + this.eventSelector + \": Begun (\" + evt.originalEvent.animationName + \")\");\r\n        if (this.timeout !== null) {\r\n            window.clearTimeout(this.timeout);\r\n            this.timeout = null;\r\n        }\r\n\r\n        this.remaining_animations.push(evt.originalEvent.animationName);\r\n    };\r\n\r\n    AnimationWatcher.prototype.animation_end = function (evt) {\r\n        var loc = this.remaining_animations.indexOf(evt.originalEvent.animationName);\r\n\r\n        console.log(\"ANIMATIONWATCHER\" + this.eventSelector + \": Ended (\" + evt.originalEvent.animationName + \")\");\r\n\r\n        if (loc !== -1) {\r\n            this.remaining_animations.splice(loc, 1);\r\n        }\r\n\r\n        if (this.remaining_animations.length === 0) {\r\n            this.resolve();\r\n        }\r\n    };\r\n\r\n    AnimationWatcher.prototype.abort_animation = function (evt) {\r\n        console.log(\"ANIMATIONWATCHER\" + this.eventSelector + \": Abort timeout triggered\");\r\n\r\n        if (this.remaining_animations.length === 0) {\r\n            this.resolve();\r\n        }\r\n    };\r\n\r\n    module.AnimationWatcher = AnimationWatcher;\r\n\r\n    return module;\r\n}));\r\n","/*global define, console, document, window*/\r\n(function (root, factory) {\r\n    \"use strict\";\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(\"CollapseContent\", [\"jquery\", \"Behaviors\"], factory);\r\n    } else {\r\n        root.CollapseContent = factory(root.jQuery, root.Behaviors);\r\n    }\r\n}(this, function ($, Behaviors) {\r\n    \"use strict\";\r\n\r\n    var module = {};\r\n\r\n    function $do(that, target) {\r\n        return function () {\r\n            target.apply(that, arguments);\r\n        };\r\n    }\r\n\r\n    function CollapseContentRegion(elem) {\r\n        Behaviors.init(CollapseContentRegion, this, arguments);\r\n\r\n        this.$elem = $(elem);\r\n        this.visible = this.$elem.data(\"collapsecontent-region-visible\") !== undefined;\r\n\r\n        this.update_classes();\r\n    }\r\n\r\n    Behaviors.inherit(CollapseContentRegion, Behaviors.Behavior);\r\n\r\n    CollapseContentRegion.QUERY = \"[data-collapsecontent-region]\";\r\n\r\n    CollapseContentRegion.prototype.update_classes = function () {\r\n        this.$elem.find(\"[data-collapsecontent-body]\").each(function (index, body_elem) {\r\n            if (this.visible) {\r\n                $(body_elem).addClass(\"is-CollapseContent--visible\");\r\n                $(body_elem).removeClass(\"is-CollapseContent--hidden\");\r\n            } else {\r\n                $(body_elem).removeClass(\"is-CollapseContent--visible\");\r\n                $(body_elem).addClass(\"is-CollapseContent--hidden\");\r\n            }\r\n        }.bind(this));\r\n\r\n        this.$elem.find(\"[data-collapsecontent-trigger]\").each(function (index, trigger_elem) {\r\n            if (this.visible) {\r\n                $(trigger_elem).addClass(\"is-CollapseContent--visible\");\r\n                $(trigger_elem).removeClass(\"is-CollapseContent--hidden\");\r\n            } else {\r\n                $(trigger_elem).removeClass(\"is-CollapseContent--visible\");\r\n                $(trigger_elem).addClass(\"is-CollapseContent--hidden\");\r\n            }\r\n        }.bind(this));\r\n    };\r\n\r\n    CollapseContentRegion.prototype.make_visible = function () {\r\n        this.visible = true;\r\n        this.update_classes();\r\n    };\r\n\r\n    CollapseContentRegion.prototype.make_hidden = function () {\r\n        this.visible = false;\r\n        this.update_classes();\r\n    };\r\n\r\n    CollapseContentRegion.prototype.toggle = function () {\r\n        this.visible = !this.visible;\r\n        this.update_classes();\r\n\r\n        // Fire custom event when toggles are activated\r\n        newEvent = new $.Event({\r\n            \"type\": \"collapsecontent-toggle\",\r\n            \"visible\": this.visible,\r\n            \"target\": this.$elem,\r\n        });\r\n\r\n        this.$elem.trigger(newEvent);\r\n    };\r\n\r\n    function CollapseContentTrigger(elem) {\r\n        Behaviors.init(CollapseContentTrigger, this, arguments);\r\n\r\n        this.$elem = $(elem);\r\n\r\n        if (this.$elem.data(\"collapsecontent-trigger\") !== undefined) {\r\n            //Mode 1: Trigger explicitly specifies region to toggle.\r\n            this.region = this.set_region($(this.$elem.data(\"collapsecontent-trigger\"))[0]);\r\n        } else if (this.$elem.attr(\"href\") !== undefined) {\r\n            //Mode 1: Trigger explicitly specifies region to toggle, as an href..\r\n            this.region = this.set_region($(this.$elem.data(\"collapsecontent-trigger\"))[0]);\r\n        }\r\n\r\n        if (this.region === undefined) {\r\n            //Mode 2: Find parent element that qualifies as a region.\r\n            this.region = this.set_region(this.$elem.parents().filter(CollapseContentRegion.QUERY)[0]);\r\n        }\r\n\r\n        if (this.region === undefined) {\r\n            console.error(\"There is a CollapseContent trigger that neither points to a valid region nor is a child of a valid region..\");\r\n        }\r\n\r\n        this.$elem.on(\"click\", this.toggle_intent.bind(this));\r\n    }\r\n\r\n    Behaviors.inherit(CollapseContentTrigger, Behaviors.Behavior);\r\n\r\n    CollapseContentTrigger.QUERY = \"[data-collapsecontent-trigger]\";\r\n\r\n    CollapseContentTrigger.prototype.set_region = function (elem) {\r\n        if (elem === undefined) {\r\n            return;\r\n        }\r\n\r\n        return CollapseContentRegion.locate(elem);\r\n    };\r\n\r\n    CollapseContentTrigger.prototype.toggle_intent = function (evt) {\r\n        if (evt) {\r\n            evt.preventDefault();\r\n        }\r\n        \r\n        this.region.toggle();\r\n    };\r\n\r\n    Behaviors.register_behavior(CollapseContentRegion);\r\n    Behaviors.register_behavior(CollapseContentTrigger);\r\n\r\n    module.CollapseContentRegion = CollapseContentRegion;\r\n    module.CollapseContentTrigger = CollapseContentTrigger;\r\n\r\n    return module;\r\n}));\r\n","/* Paginate.js\r\n * A progressively-enhancing infinite scroll library\r\n * Â©2014 HUEMOR Designs All Rights Reserved\r\n */\r\n\r\n/*global jQuery, define, console, window, document*/\r\n(function (root, factory) {\r\n    \"use strict\";\r\n    if (typeof define === 'function' && define.amd) {\r\n        define('depaginate', ['jquery', \"Behaviors\"], factory);\r\n    } else if (root.jQuery) {\r\n        root.PaginateJS = factory(root.jQuery, root.Behaviors);\r\n    } else {\r\n        console.error(\"No jQuery found. Load jQuery before this module or use an AMD-compliant loader.\");\r\n    }\r\n}(this, function ($, Behaviors) {\r\n    \"use strict\";\r\n    \r\n    var module = {};\r\n    \r\n    function Pager(elem, page_select_handler) {\r\n        Behaviors.init(Pager, this, arguments);\r\n        \r\n        this.links = {};\r\n        this.current = null;\r\n        this.$pager = $(elem);\r\n        this.min_page_count = Infinity;\r\n        this.max_page_count = 0;\r\n        \r\n        this.$pager.addClass(\"is-Paginate--managed\");\r\n\r\n        this.page_select_handler = page_select_handler;\r\n\r\n        this.features = this.$pager.data(\"paginate-features\");\r\n\r\n        if (this.features === undefined) {\r\n            this.features = \"replaceState\";\r\n        }\r\n\r\n        console.log(\"Pager Features:\" + this.features);\r\n        this.features = this.features.split(\" \");\r\n    }\r\n    \r\n    Behaviors.inherit(Pager, Behaviors.Behavior);\r\n    \r\n    Pager.QUERY = \"[data-paginate='pager']\";\r\n    \r\n    Pager.DEFAULT_LINK = {\r\n        \"loaded\": false,\r\n        \"requested\": false,\r\n        \"pending\": false,\r\n        \"current\": false\r\n    };\r\n    \r\n    Pager.prototype.is_page_loaded = function (pagenumber) {\r\n        return this.links[pagenumber].loaded;\r\n    };\r\n    \r\n    Pager.prototype.set_current_page = function (pagenumber) {\r\n        var i = 0, pageid;\r\n        \r\n        if (this.current === pagenumber) {\r\n            return;\r\n        }\r\n        \r\n        this.current = pagenumber;\r\n        this.links[pagenumber] = this.links[pagenumber] || $.extend({}, Pager.DEFAULT_LINK);\r\n        \r\n        for (pageid in this.links) {\r\n            if (this.links.hasOwnProperty(pageid)) {\r\n                this.links[pageid].current = pageid === pagenumber;\r\n            }\r\n        }\r\n        \r\n        if (this.links[pagenumber].$pagerContents !== undefined) {\r\n            this.$pager.children().detach();\r\n            this.$pager.append(this.links[pagenumber].$pagerContents);\r\n        }\r\n        \r\n        if (this.links[pagenumber].href !== undefined) {\r\n            if (this.features.indexOf(\"replaceState\") > -1 && window.history.replaceState) {\r\n                window.history.replaceState({transition: true, url: this.links[pagenumber].href}, \"\", this.links[pagenumber].href);\r\n            }\r\n        }\r\n    };\r\n    \r\n    Pager.prototype.read_pager = function (pagerElem) {\r\n        var $newPager = $(pagerElem),\r\n            pagerThis = this;\r\n        \r\n        $newPager.find(\"[data-paginate='page']\").each(function (index, pageElem) {\r\n            var $newPage = $(pageElem),\r\n                page = $newPage.data(\"paginate-page\"),\r\n                isCurrent = $newPage.data(\"paginate-current\") !== undefined,\r\n                href = $newPage.attr(\"href\");\r\n            \r\n            pagerThis.links[page] = pagerThis.links[page] || $.extend({}, Pager.DEFAULT_LINK);\r\n            \r\n            pagerThis.links[page].href = href || pagerThis.links[page].href;\r\n            pagerThis.links[page].current = isCurrent;\r\n            \r\n            if (isCurrent) {\r\n                pagerThis.current = page;\r\n            }\r\n            \r\n            if (pagerThis.links[page].pending) {\r\n                pagerThis.load_page(page);\r\n            }\r\n            \r\n            if (page > pagerThis.max_page_count) {\r\n                pagerThis.max_page_count = page;\r\n            }\r\n            \r\n            if (page < pagerThis.min_page_count) {\r\n                pagerThis.min_page_count = page;\r\n            }\r\n\r\n            $newPage.on(\"click\", function (evt) {\r\n                evt.preventDefault();\r\n\r\n                if (pagerThis.page_select_handler) {\r\n                    pagerThis.page_select_handler(pagerThis, page);\r\n                }\r\n            });\r\n        });\r\n        \r\n        this.links[this.current] = this.links[this.current] || $.extend({}, Pager.DEFAULT_LINK);\r\n        this.links[this.current].$pagerContents = $newPager.children();\r\n        \r\n        if (this.links[this.current].$pagerContents !== undefined) {\r\n            this.$pager.children().detach();\r\n            this.$pager.append(this.links[this.current].$pagerContents);\r\n        }\r\n    };\r\n    \r\n    Pager.prototype.load_page = function (pagenumber, on_success, on_failure) {\r\n        var paginateThis = this;\r\n        \r\n        if (this.links[pagenumber] === undefined || this.links[pagenumber].href === undefined) {\r\n            this.links[pagenumber] = $.extend({}, this.links[pagenumber], Pager.DEFAULT_LINK);\r\n            this.links[pagenumber].pending = true;\r\n            this.links[pagenumber].on_success = on_success || this.links[pagenumber].on_success;\r\n            this.links[pagenumber].on_failure = on_failure || this.links[pagenumber].on_failure;\r\n            \r\n            return;\r\n        }\r\n        \r\n        if (this.links[pagenumber].requested || this.links[pagenumber].loaded) {\r\n            return;\r\n        }\r\n        \r\n        this.links[pagenumber].pending = false;\r\n        this.links[pagenumber].requested = true;\r\n        \r\n        $.ajax({\r\n            \"url\": this.links[pagenumber].href,\r\n            \"dataType\": \"html\"\r\n        }).done(function (data, textStatus, jqXHR) {\r\n            if (paginateThis.links[pagenumber].on_success !== undefined) {\r\n                paginateThis.links[pagenumber].on_success(data, textStatus, jqXHR);\r\n            }\r\n            \r\n            if (on_success !== undefined) {\r\n                on_success(data, textStatus, jqXHR);\r\n            }\r\n            \r\n            paginateThis.links[pagenumber].loaded = true;\r\n        }).fail(function (jqXHR, textStatus, errorThrown) {\r\n            if (paginateThis.links[pagenumber].on_failure !== undefined) {\r\n                paginateThis.links[pagenumber].on_failure(jqXHR, textStatus, errorThrown);\r\n            }\r\n            \r\n            if (on_failure !== undefined) {\r\n                on_failure(jqXHR, textStatus, errorThrown);\r\n            }\r\n        });\r\n    };\r\n    \r\n    Pager.prototype.is_first_page = function (test_page) {\r\n        return (test_page !== null && test_page === this.min_page_count);\r\n    };\r\n    \r\n    Pager.prototype.is_last_page = function (test_page) {\r\n        return (test_page !== null && test_page === this.max_page_count);\r\n    };\r\n    \r\n    module.Pager = Pager;\r\n    \r\n    function Region(elem, on_region_scrolled) {\r\n        var $extantRegion = $(elem);\r\n        Behaviors.init(Region, this, arguments);\r\n        \r\n        this.name = $extantRegion.data(\"paginate-region\");\r\n\r\n        this.load_methods = $extantRegion.data(\"paginate-methods\");\r\n\r\n        if (this.load_methods === undefined) {\r\n            this.load_methods = \"scroll\";\r\n        }\r\n\r\n        console.log(\"LoadMethods:\" + this.load_methods);\r\n        this.load_methods = this.load_methods.split(\" \");\r\n\r\n        this.features = $extantRegion.data(\"paginate-features\");\r\n\r\n        if (this.features === undefined) {\r\n            this.features = \"scrollOnLoad\";\r\n        }\r\n\r\n        console.log(\"Region Features:\" + this.features);\r\n        this.features = this.features.split(\" \");\r\n        \r\n        this.pages = {};\r\n        this.pagenumbers = [];\r\n        \r\n        this.min_page_loaded = Infinity;\r\n        this.max_page_loaded = 0;\r\n        \r\n        this.$region = $extantRegion;\r\n        \r\n        this.$parentScroller = null;\r\n        this.lastScrollTop = 0;\r\n        \r\n        this.on_region_scrolled = on_region_scrolled;\r\n        \r\n        this.$region.addClass(\"is-Paginate--managed\");\r\n    }\r\n    \r\n    Behaviors.inherit(Region, Behaviors.Behavior);\r\n    \r\n    Region.QUERY = \"[data-paginate='region']\";\r\n    \r\n    /* Called to append a new page to the region.\r\n     * \r\n     * Region contents will be extracted from the given region element and\r\n     * appended to the existing region, such that any existing content belonging\r\n     * to pages marked with a lower page number will appear before your page\r\n     * content, and any existing content belonging to pages marked with a higher\r\n     * page number will appear after your page content.\r\n     * \r\n     * Already inserted pages will not be reinserted into the region.\r\n     * \r\n     * As this function inserts content into the page, it will be presented to\r\n     * Behaviors to ensure any Behaviors on the new page content can locate\r\n     * correctly.\r\n     * \r\n     * An event will be fired from the region's element called depaginate_load\r\n     * which serves to indicate when a new page has loaded. Do not use this\r\n     * event to check if new content has been added to the page, use Behaviors'\r\n     * register_behavior or register_content_listener functions instead. This\r\n     * event will be called before behaviors have been located on their\r\n     * elements.\r\n     */\r\n    Region.prototype.read_page_region = function (pageNumber, regionElem) {\r\n        var $newRegion = $(regionElem),\r\n            itemSelector = $newRegion.data(\"paginate-selector\") || \"> *\",\r\n            prevPageNumberId = 0,\r\n            nextPageNumberId = this.pagenumbers.length,\r\n            nextPageNumber,\r\n            prevPageNumber,\r\n            pageAlreadyExists = false,\r\n            i = 0,\r\n            $newItems = $newRegion.find(itemSelector),\r\n            $firstItem = $newItems.first(),\r\n            $lastItem = $newItems.last(),\r\n            oldPageTop = 0,\r\n            newPageTop = 0,\r\n            evt;\r\n        \r\n        if (this.firstVisiblePage !== undefined) {\r\n            oldPageTop = this.page_top_position(this.firstVisiblePage);\r\n        }\r\n\r\n        for (i = 0; i < this.pagenumbers.length; i += 1) {\r\n            if (this.pagenumbers[i] < pageNumber) {\r\n                prevPageNumberId = i;\r\n                prevPageNumber = this.pagenumbers[i];\r\n            } else if (this.pagenumbers[i] === pageNumber) {\r\n                pageAlreadyExists = true;\r\n            } else {\r\n                nextPageNumber = this.pagenumbers[i];\r\n                nextPageNumberId = i;\r\n                break;\r\n            }\r\n        }\r\n        \r\n        if (!pageAlreadyExists) {\r\n            this.pagenumbers.splice(nextPageNumberId, 0, pageNumber);\r\n            \r\n            if (this.pages[prevPageNumber] !== undefined) {\r\n                $newItems = $newItems.insertAfter(this.pages[prevPageNumber].$lastItem);\r\n            } else if (this.pages[nextPageNumber] !== undefined) {\r\n                $newItems = $newItems.insertBefore(this.pages[nextPageNumber].$firstItem);\r\n            } //else do nothing since this obviously must be the original region\r\n            \r\n            $firstItem = $newItems.first();\r\n            $lastItem = $newItems.last();\r\n            \r\n            this.pages[pageNumber] = this.pages[pageNumber] || {};\r\n            this.pages[pageNumber].$newItems = $newItems;\r\n            this.pages[pageNumber].$firstItem = $firstItem;\r\n            this.pages[pageNumber].$lastItem = $lastItem;\r\n\r\n            evt = jQuery.Event(\"depaginate_load\");\r\n            evt.region = this;\r\n            evt.target = this.$region[0];\r\n            evt.$newItems = $newItems;\r\n\r\n            this.$region.trigger(evt);\r\n            \r\n            Behaviors.content_ready($newItems);\r\n        }\r\n        \r\n        if (pageNumber < this.min_page_loaded) {\r\n            this.min_page_loaded = pageNumber;\r\n        }\r\n        \r\n        if (pageNumber > this.max_page_loaded) {\r\n            this.max_page_loaded = pageNumber;\r\n        }\r\n\r\n        if (this.firstVisiblePage !== undefined) {\r\n            newPageTop = this.page_top_position(this.firstVisiblePage);\r\n\r\n            if (this.features.indexOf(\"scrollOnLoad\") > -1) {\r\n                window.setTimeout(\r\n                    this.scroll_by_delta.bind(this, newPageTop - oldPageTop),\r\n                    50\r\n                );\r\n            }\r\n        }\r\n    };\r\n    \r\n    Region.prototype.register_scroll_handler = function () {\r\n        var cssOverflowX,\r\n            regionThis = this;\r\n        \r\n        if (this.$parentScroller !== null) {\r\n            this.$parentScroller.off(\"scroll.paginate\");\r\n        }\r\n\r\n        this.$parentScroller = this.$region;\r\n\r\n        while (this.$parentScroller.length !== 0 && this.$parentScroller.get(0) !== document) {\r\n            cssOverflowX = this.$parentScroller.css(\"overflow-x\");\r\n\r\n            if (cssOverflowX === \"visible\" || cssOverflowX === \"hidden\") {\r\n                this.$parentScroller = this.$parentScroller.parent();\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        \r\n        regionThis.on_scroll({\"target\": this.$parentScroller[0]});\r\n        this.$parentScroller.on(\"scroll.paginate\", function (evt) {\r\n            regionThis.on_scroll(evt);\r\n        });\r\n\r\n        this.lastScrollTop = this.$parentScroller.scrollTop();\r\n    };\r\n    \r\n    Region.prototype.on_scroll = function (evt) {\r\n        var $target = $(evt.target),\r\n            scrollTop = $target.scrollTop(),\r\n            scrollBottom = scrollTop + (evt.target !== document ? $target.height() : $(window).height()),\r\n            targetTop = evt.target !== document ? $target.position().top : 0,\r\n            targetAdjust = evt.target !== document ? scrollTop : 0,\r\n            i = 0,\r\n            firstVisibleTop = null,\r\n            firstVisiblePage = null,\r\n            lastVisiblePage = null,\r\n            lastVisibleBottom = null,\r\n            scrollDelta = scrollTop - this.lastScrollTop,\r\n            stopOuterLoopSentinel = false,\r\n            regionThis = this;\r\n        \r\n        this.lastScrollTop = scrollDelta;\r\n        \r\n        function pageEach(index, itemElem) {\r\n            var $itemElem = $(itemElem),\r\n                itemTop = targetAdjust + $itemElem.position().top - targetTop,\r\n                itemBottom = itemTop + $itemElem.height(),\r\n                isVisible = (scrollTop <= itemTop && itemTop <= scrollBottom) ||\r\n                            (scrollTop <= itemBottom && itemBottom <= scrollBottom) ||\r\n                            (itemTop <= scrollTop && scrollBottom <= itemBottom);\r\n            \r\n            if (!isVisible) {\r\n                if (lastVisiblePage !== null) {\r\n                    stopOuterLoopSentinel = true;\r\n                }\r\n\r\n                return true;\r\n            }\r\n\r\n            if (firstVisiblePage === null) {\r\n                firstVisiblePage = regionThis.pagenumbers[i];\r\n                firstVisibleTop = itemTop;\r\n            }\r\n            \r\n            lastVisiblePage = regionThis.pagenumbers[i];\r\n            lastVisibleBottom = itemTop + $itemElem.height();\r\n\r\n            return false;\r\n        }\r\n        \r\n        //Determine what pages are visible now\r\n        if (this.pagenumbers.length === 0) {\r\n            console.log(\"There are no page numbers.\");\r\n        }\r\n        \r\n        for (i = 0; i < this.pagenumbers.length; i += 1) {\r\n            if (this.pages[this.pagenumbers[i]].$newItems === 0) {\r\n                console.log(\"There are no pages within page \" + this.pagenumbers[i]);\r\n            }\r\n            \r\n            this.pages[this.pagenumbers[i]].$newItems.each(pageEach);\r\n            \r\n            if (stopOuterLoopSentinel) {\r\n                stopOuterLoopSentinel = false;\r\n                break;\r\n            }\r\n        }\r\n        \r\n        if (firstVisiblePage === null) {\r\n            console.log(\"First visible page did NOT get set. Dropping the scroll event.\");\r\n            return;\r\n        }\r\n        \r\n        this.firstVisiblePage = firstVisiblePage;\r\n        this.lastVisiblePage = lastVisiblePage;\r\n        this.firstVisibleTop = firstVisibleTop;\r\n        this.lastVisibleBottom = lastVisibleBottom;\r\n\r\n        if (this.load_methods.indexOf(\"scroll\") > -1) {\r\n            this.on_region_scrolled(this, scrollTop, scrollBottom, scrollDelta, firstVisiblePage, lastVisiblePage, firstVisibleTop, lastVisibleBottom);\r\n        }\r\n    };\r\n    \r\n    Region.prototype.first_loaded_page = function () {\r\n        return this.min_page_loaded;\r\n    };\r\n    \r\n    Region.prototype.last_loaded_page = function () {\r\n        return this.max_page_loaded;\r\n    };\r\n    \r\n    Region.prototype.set_additional_content_indicators = function (has_next_page, has_prev_page) {\r\n        if (has_next_page) {\r\n            this.$region.addClass(\"is-Paginate--has_next_page\");\r\n            this.$region.removeClass(\"is-Paginate--no_next_page\");\r\n        } else {\r\n            this.$region.removeClass(\"is-Paginate--has_next_page\");\r\n            this.$region.addClass(\"is-Paginate--no_next_page\");\r\n        }\r\n        \r\n        if (has_prev_page) {\r\n            this.$region.addClass(\"is-Paginate--has_prev_page\");\r\n            this.$region.removeClass(\"is-Paginate--no_prev_page\");\r\n        } else {\r\n            this.$region.removeClass(\"is-Paginate--has_prev_page\");\r\n            this.$region.addClass(\"is-Paginate--no_prev_page\");\r\n        }\r\n    };\r\n    \r\n    /* Returns the position of the top of a particular page.\r\n     */\r\n    Region.prototype.page_top_position = function (pagenumber) {\r\n        var page = this.pages[pagenumber],\r\n            $firstItem,\r\n            measuredOffset,\r\n            $parentScroller = this.$parentScroller,\r\n            scrollerOffset = 0,\r\n            encounteredScroller = false;\r\n        \r\n        if (page === undefined) {\r\n            console.log(\"Missing page: \" + pagenumber);\r\n            console.log(this.pages);\r\n            \r\n            if (pagenumber < this.min_page_loaded || pagenumber === null) {\r\n                pagenumber = this.min_page_loaded;\r\n            }\r\n            \r\n            if (pagenumber > this.max_page_loaded) {\r\n                pagenumber = this.max_page_loaded;\r\n            }\r\n            \r\n            page = this.pages[pagenumber];\r\n        }\r\n        \r\n        $firstItem = page.$firstItem;\r\n        measuredOffset = $firstItem.offset().top;\r\n        if ($parentScroller[0] !== document) {\r\n            scrollerOffset = $parentScroller.offset().top;\r\n        }\r\n        \r\n        return measuredOffset - scrollerOffset;\r\n    };\r\n    \r\n    /* Scroll the region by a particular delta. */\r\n    Region.prototype.scroll_by_delta = function (scrollDelta) {\r\n        var $parentScroller = this.$parentScroller;\r\n        \r\n        $parentScroller.scrollTop($parentScroller.scrollTop() + scrollDelta);\r\n    };\r\n    \r\n    Region.prototype.scroll_absolutely = function (scrollAbs) {\r\n        var $parentScroller = this.$parentScroller;\r\n        \r\n        $parentScroller.scrollTop(scrollAbs);\r\n    };\r\n    \r\n    module.Region = Region;\r\n    \r\n    function Paginate(elem) {\r\n        var $extantPager = $(elem).find(Pager.QUERY),\r\n            $extantRegions = $(elem).find(Region.QUERY),\r\n            currentPage = $(elem).data(\"paginate-page\"),\r\n            paginateThis = this;\r\n        \r\n        Behaviors.init(Paginate, this, arguments);\r\n        \r\n        if ($extantPager.length === 0) {\r\n            console.error(\"No pager was found in this paginage instance.\");\r\n            return;\r\n        }\r\n        \r\n        if (this.$elem.attr('id') === undefined) {\r\n            console.error(\"This paginate needs an id before it can be used.\");\r\n            return;\r\n        }\r\n        \r\n        console.log(\"page: \" + currentPage);\r\n        \r\n        this.$context = $(elem);\r\n        this.id = this.$context.attr(\"id\");\r\n        \r\n        function pshClosure() {\r\n            paginateThis.page_select_handler.apply(paginateThis, arguments);\r\n        }\r\n\r\n        this.pager = Pager.locate($extantPager.get(0), pshClosure);\r\n        \r\n        if ($extantPager.data(\"paginate-count\") === 1) {\r\n            console.log(\"Not activating depaginate on a region with only one page.\");\r\n            return;\r\n        }\r\n        \r\n        this.pager.set_current_page(currentPage);\r\n        this.pager.read_pager($extantPager.get(0));\r\n        \r\n        this.regions = {};\r\n        this.regionNames = [];\r\n        \r\n        this.currentPage = currentPage;\r\n        \r\n        function orsClosure() {\r\n            paginateThis.on_region_scrolled.apply(paginateThis, arguments);\r\n        }\r\n        \r\n        this.features = $extantPager.data(\"paginate-features\");\r\n\r\n        if (this.features === undefined) {\r\n            this.features = \"backScroll\";\r\n        }\r\n\r\n        console.log(\"Paginate Features:\" + this.features);\r\n        this.features = this.features.split(\" \");\r\n\r\n        $extantRegions.each(function (index, elem) {\r\n            var $extantRegion = $(elem),\r\n                regionName = $extantRegion.data(\"paginate-region\"),\r\n                region,\r\n                currentPage = paginateThis.currentPage;\r\n            \r\n            console.log(\"page: \" + currentPage);\r\n            \r\n            function scrollBack() {\r\n                console.log(\"Scrolling back the user to \" + region.page_top_position(currentPage) + \" (page: \" + currentPage + \")\");\r\n                region.scroll_absolutely(region.page_top_position(currentPage));\r\n            }\r\n            \r\n            paginateThis.regionNames.push(regionName);\r\n            \r\n            region = paginateThis.regions[regionName] || Region.locate(elem, orsClosure);\r\n            paginateThis.regions[regionName] = region;\r\n            \r\n            region.read_page_region(currentPage, elem);\r\n            region.register_scroll_handler();\r\n            \r\n            paginateThis.update_region_indicators(region);\r\n            \r\n            if (!paginateThis.pager.is_first_page(currentPage) && paginateThis.features.indexOf(\"backScroll\") > -1) {\r\n                //User pressed back button, scroll the region into view\r\n                \r\n                $(document).ready(scrollBack);\r\n                $(window).on(\"load\", function () {\r\n                    window.setTimeout(scrollBack, 1500);\r\n                });\r\n            }\r\n        });\r\n    }\r\n    \r\n    Behaviors.inherit(Paginate, Behaviors.Behavior);\r\n    \r\n    Paginate.QUERY = \"[data-paginate='paginate']\";\r\n    \r\n    Paginate.prototype.page_load_success = function (data, textStatus, jqXHR) {\r\n        var $data = $(data),\r\n            i = 0,\r\n            $dataPaginate,\r\n            $dataRegion,\r\n            $dataPager,\r\n            region = null,\r\n            paginateThis = this,\r\n            next_page = 0;\r\n\r\n        $dataPaginate = $data.find(\"#\" + this.id);\r\n        \r\n        if ($dataPaginate.length === 0) {\r\n            $dataPaginate = $data.filter(\"#\" + this.id);\r\n        }\r\n        \r\n        if ($dataPaginate.length === 0) {\r\n            console.error(\"DEPAGINATE: The paginate context with ID \" + this.id + \" could not be found in the loaded page. Errors may result.\");\r\n        }\r\n        \r\n        next_page = $dataPaginate.data(\"paginate-page\");\r\n\r\n        for (i = 0; i < this.regionNames.length; i += 1) {\r\n            $dataRegion = $dataPaginate.find(\"[data-paginate-region='\" + this.regionNames[i] + \"']\");\r\n\r\n            if ($dataRegion.length > 0) {\r\n                region = this.regions[this.regionNames[i]];\r\n                region.read_page_region(next_page, $dataRegion[0]);\r\n            }\r\n        }\r\n\r\n        $dataPager = $dataPaginate.find(Pager.QUERY);\r\n        $dataPager.each(function (index, pagerElem) {\r\n            paginateThis.pager.read_pager(pagerElem);\r\n        });\r\n\r\n        this.pager.set_current_page(next_page);\r\n        this.update_region_indicators(region);\r\n    };\r\n\r\n    Paginate.prototype.page_select_handler = function (pager, pagenumber) {\r\n        var paginateThis = this;\r\n        if (this.pager.is_page_loaded(pagenumber)) {\r\n            return;\r\n        }\r\n\r\n        function on_success() {\r\n            paginateThis.page_load_success.apply(paginateThis, arguments);\r\n        }\r\n\r\n        this.pager.load_page(pagenumber, on_success);\r\n    };\r\n\r\n    Paginate.prototype.on_region_scrolled = function (region, scrollTop, scrollBottom, scrollDelta, firstVisiblePage, lastVisiblePage, firstVisibleTop, lastVisibleBottom) {\r\n        var visible_range = lastVisibleBottom - firstVisibleTop,\r\n            visible_pagerange = lastVisiblePage - firstVisiblePage,\r\n            average_page_size = visible_range / visible_pagerange,\r\n            scroll_direction_down = scrollDelta > 0,\r\n            should_load_page,\r\n            next_page,\r\n            paginateThis = this;\r\n        \r\n        function on_success() {\r\n            paginateThis.page_load_success.apply(paginateThis, arguments);\r\n        }\r\n        \r\n        if (scroll_direction_down) {\r\n            should_load_page = scrollBottom + scrollDelta >= lastVisibleBottom;\r\n            next_page = lastVisiblePage + 1;\r\n            \r\n            this.pager.set_current_page(lastVisiblePage);\r\n        } else {\r\n            should_load_page = scrollTop + scrollDelta < firstVisibleTop;\r\n            next_page = firstVisiblePage - 1;\r\n            \r\n            this.pager.set_current_page(firstVisiblePage);\r\n        }\r\n        \r\n        if (next_page < 0) {\r\n            return;\r\n        }\r\n        \r\n        if (should_load_page) {\r\n            this.pager.load_page(next_page, on_success);\r\n        }\r\n    };\r\n    \r\n    Paginate.prototype.update_region_indicators = function (region) {\r\n        region.set_additional_content_indicators(\r\n            !this.pager.is_last_page(region.last_loaded_page()),\r\n            !this.pager.is_first_page(region.first_loaded_page())\r\n        );\r\n    };\r\n    \r\n    module.Paginate = Paginate;\r\n    \r\n    Behaviors.register_behavior(Paginate);\r\n    \r\n    return module;\r\n}));","/*global define,google,Promise*/\r\n(function (root, factory) {\r\n    \"use strict\";\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(\"GoogleMap\", [\"jquery\", \"Behaviors\"], factory);\r\n    } else {\r\n        root.GoogleMap = factory(root.jQuery, root.Behaviors);\r\n    }\r\n}(this, function ($, Behaviors) {\r\n    \"use strict\";\r\n    \r\n    var module = {};\r\n    \r\n    function GoogleMap() {\r\n        Behaviors.init(GoogleMap, this, arguments);\r\n        \r\n        this.load_gmaps().then(this.render_map.bind(this));\r\n    }\r\n    \r\n    Behaviors.inherit(GoogleMap, Behaviors.Behavior);\r\n    \r\n    GoogleMap.QUERY = \"[data-googlemap]\";\r\n    \r\n    GoogleMap.prototype.center_specified_by_markup = function () {\r\n        return this.$elem.data(\"googlemap-lat\") !== undefined && this.$elem.data(\"googlemap-lng\") !== undefined;\r\n    };\r\n    \r\n    GoogleMap.prototype.determine_default_args = function () {\r\n        var args = {\r\n            center: {lat: 0, lng: 0},\r\n            mapTypeId: google.maps.MapTypeId.ROADMAP,\r\n            disableDefaultUI: true,\r\n            draggable: false,\r\n            scrollwheel: false,\r\n            zoom: 15\r\n        };\r\n        \r\n        if (this.$elem.data(\"googlemap-draggable\") !== undefined) {\r\n            args.draggable = true;\r\n        }\r\n        \r\n        if (this.$elem.data(\"googlemap-scrollzoom\") !== undefined) {\r\n            args.scrollwheel = true;\r\n        }\r\n        \r\n        if (this.center_specified_by_markup()) {\r\n            args.center = {lat: this.$elem.data(\"googlemap-lat\"),\r\n                           lng: this.$elem.data(\"googlemap-lng\")};\r\n        }\r\n        \r\n        if (this.$elem.data(\"googlemap-zoom\") !== undefined) {\r\n            args.zoom = this.$elem.data(\"googlemap-zoom\");\r\n        }\r\n        \r\n        return args;\r\n    };\r\n    \r\n    GoogleMap.prototype.load_gmaps = function () {\r\n        return Promise.resolve().then(function () {\r\n            if (window.google) {\r\n                return;\r\n            } else {\r\n                //TODO: Autoload Gmaps API\r\n                throw new Error(\"Google Maps API not loaded at time of initialization.\");\r\n            }\r\n        });\r\n    };\r\n    \r\n    GoogleMap.prototype.render_map = function () {\r\n        var $markers = this.$elem.find('[data-googlemap-marker]'), i;\r\n        \r\n        // create map\r\n        this.map = new google.maps.Map(this.$elem[0], this.determine_default_args());\r\n        \r\n        this.map.markers = [];\r\n        for (i = 0; i < $markers.length; i += 1) {\r\n            this.add_marker($($markers[i]), this.map);\r\n        }\r\n        \r\n        // center map\r\n        this.center_map();\r\n    };\r\n    \r\n    GoogleMap.prototype.add_marker = function ($marker) {\r\n        var latlng = new google.maps.LatLng($marker.data('googlemap-lat'), $marker.data('googlemap-lng')),\r\n            marker = new google.maps.Marker({\r\n                position: latlng,\r\n                map: this.map\r\n            }),\r\n            infowindow;\r\n        \r\n        this.map.markers.push(marker);\r\n        \r\n        // if marker contains HTML, add it to an infoWindow\r\n        if ($marker.html()) {\r\n            infowindow = new google.maps.InfoWindow({\r\n                content\t\t: $marker.html()\r\n            });\r\n            \r\n            google.maps.event.addListener(marker, 'click', this.marker_click_intent.bind(this, marker, infowindow));\r\n        }\r\n    };\r\n    \r\n    GoogleMap.prototype.marker_click_intent = function (marker, infowindow) {\r\n        infowindow.open(this.map, marker);\r\n    };\r\n    \r\n    GoogleMap.prototype.center_map = function () {\r\n        var i, marker, latlng, bounds = new google.maps.LatLngBounds();\r\n        \r\n        // loop through all markers and create bounds\r\n        for (i = 0; i < this.map.markers.length; i += 1) {\r\n            marker = this.map.markers[i];\r\n            latlng = new google.maps.LatLng(marker.position.lat(), marker.position.lng());\r\n            bounds.extend(latlng);\r\n        }\r\n        \r\n        if (!this.center_specified_by_markup()) {\r\n            if (this.map.markers.length === 1) {\r\n                this.map.setCenter(bounds.getCenter());\r\n            } else {\r\n                this.map.fitBounds(bounds);\r\n            }\r\n        }\r\n    };\r\n    \r\n    Behaviors.register_behavior(GoogleMap);\r\n    \r\n    module.GoogleMap = GoogleMap;\r\n    \r\n    return module;\r\n}));","(function (root, factory) {\r\n    \"use strict\";\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(\"ContentSlider\", [\"jquery\", \"Behaviors\"], factory);\r\n    } else {\r\n        root.ContentSlider = factory(root.jQuery, root.Behaviors);\r\n    }\r\n}(window, function ($, Behaviors) {\r\n    //TODO: Move this file out of `frontend.prebuilt.js` and into the global script pack\r\n    \"use strict\";\r\n    var module = {};\r\n    \r\n    function ContentSlider() {\r\n        Behaviors.init(ContentSlider, this, arguments);\r\n        this.element = this.$elem[0];\r\n        this.left_arrow = this.$elem.data(\"contentslider-leftarrow\");\r\n        this.right_arrow = this.$elem.data(\"contentslider-rightarrow\");\r\n        this.dots = this.$elem.data(\"contentslider-dots\");\r\n        this.dots_icon = this.$elem.data(\"contentslider-dotsicon\");\r\n        this.autoplay_timeout = this.$elem.data(\"contentslider-autoplay\");\r\n        this.has_autoplay = this.autoplay_timeout !== undefined;\r\n        this.has_hoverpause = this.$elem.data(\"contentslider-hoverpause\") !== undefined;\r\n        this.has_dots = this.dots !== \"none\";\r\n        this.has_nav = false;\r\n        if (this.left_arrow) {\r\n            this.has_nav = true;\r\n        }\r\n        \r\n        if (this.right_arrow) {\r\n            this.has_nav = true;\r\n        }\r\n        this.initOwlCarousel();\r\n    };\r\n    \r\n    Behaviors.inherit(ContentSlider, Behaviors.Behavior);\r\n    \r\n    ContentSlider.QUERY = \"[data-contentslider]\";\r\n    \r\n    ContentSlider.ELEMENTS = {\r\n        heightContainer: \".scrollContainerHeight\",\r\n        widthContainer: \".scrollContainerWidth\",\r\n        sliderContents: \".horizontalContents\",\r\n        section: \".section\",\r\n        progressBar: \".progressBarFill\",\r\n        progressBall: \".progressBall\",\r\n        carousel: \".owl-carousel\"\r\n    };\r\n    \r\n    ContentSlider.prototype.dots_class = function () {\r\n        return \"owl-dots ContentSlider-dots ContentSlider-dots--style_\" + this.dots;\r\n    };\r\n    \r\n    ContentSlider.prototype.dot_class = function () {\r\n        if (this.dots_icon) {\r\n            return \"ContentSlider-dot ContentSlider-dot--style_\" + this.dots + \" \" + this.dots_icon;\r\n        } else {\r\n            return \"ContentSlider-dot ContentSlider-dot--style_\" + this.dots;\r\n        }\r\n    };\r\n    \r\n    ContentSlider.prototype.initOwlCarousel = function() {\r\n        this.carousel = this.$elem.find(ContentSlider.ELEMENTS.carousel).owlCarousel({\r\n            loop: false,\r\n            center: true,\r\n            dots: this.has_dots,\r\n            dotsClass: this.dots_class(),\r\n            dotClass: this.dot_class(),\r\n            //margin: 50,\r\n            items: 1, \r\n            nav: this.has_nav,\r\n            navClass: [\"owl-prev \" + this.left_arrow, \"owl-next \" + this.right_arrow],\r\n            //onDragged: self.updatePagination.bind(self),\r\n            autoplay: this.has_autoplay,\r\n            autoplayTimeout: this.autoplay_timeout,\r\n            autoplayHoverPause: this.has_hoverpause\r\n        });\r\n        //self.updateNav(0);\r\n    };\r\n\r\n    \r\n    \r\n    ContentSlider.prototype.init = function () {\r\n        this.fixed = false;\r\n        //this.setHeight();\r\n        //this.handleScroll();\r\n        //this.handleResize();\r\n        this.initMobileSlider();\r\n        //this.handleDrag();\r\n        //this.element.querySelector(\".currentSlide\").innerHTML = \"01\";\r\n        //this.element.querySelector(\".maxSlide\").innerHTML = \"0\".concat(this.sectionNumber);\r\n        //this.setTitlePos();\r\n    };\r\n    \r\n    ContentSlider.prototype.setHeight = function () {\r\n        this.elementHeight = this.element.querySelector(ContentSlider.ELEMENTS.section).offsetHeight;\r\n        this.sectionNumber = this.element.querySelectorAll(ContentSlider.ELEMENTS.section).length;\r\n        var width = this.element.querySelector(ContentSlider.ELEMENTS.section).offsetWidth;\r\n        this.height = (this.sectionNumber - 1) * (width * 3) + this.elementHeight;\r\n        this.element.querySelector(ContentSlider.ELEMENTS.heightContainer).style.height = \"\".concat(this.height, \"px\");\r\n    };\r\n    \r\n    ContentSlider.prototype.handleScroll = function () {\r\n        var self = this;\r\n        wContainer = self.element.querySelector(ContentSlider.ELEMENTS.widthContainer), sContents = self.element.querySelector(ContentSlider.ELEMENTS.sliderContents), pBar = self.element.querySelector(ContentSlider.ELEMENTS.progressBar);\r\n        pBall = self.element.querySelector(ContentSlider.ELEMENTS.progressBall);\r\n        window.addEventListener(\"scroll\", function () {\r\n            self.scrollHandler.call(self, wContainer, sContents, pBar, pBall);\r\n        });\r\n    };\r\n    \r\n    ContentSlider.prototype.scrollHandler = function(wContainer, sContents, pBar, pBall) {\r\n        var self = this;\r\n        var s = self.getOffsetTop(self.element) - window.scrollY;\r\n        self.currentScroll = window.scrollY;\r\n        var pFill = s * -1 / (self.height - self.elementHeight) * 100;\r\n\r\n        if (s <= 0 && s >= (self.height - self.elementHeight) * -1 && self.fixed === false) {\r\n            document.body.style.overscrollBehaviorX = 'none';\r\n            wContainer.style.position = \"fixed\";\r\n            self.fixed = true;\r\n        } else if (s > 0) {\r\n            wContainer.style.position = \"absolute\";\r\n            wContainer.classList.add('top');\r\n            wContainer.classList.remove('bottom');\r\n            sContents.style.transform = \"translate3d(0px, 0px, 0px)\";\r\n            pBar.style.width = \"0%\";\r\n            pBall.style.left = \"0%\";\r\n            self.fixed = false;\r\n        } else if (s <= (self.height - self.elementHeight) * -1) {\r\n            var height = (self.height - self.elementHeight) * -1 / 3;\r\n            wContainer.style.position = \"absolute\";\r\n            wContainer.classList.add('bottom');\r\n            wContainer.classList.remove('top');\r\n            sContents.style.transform = \"translate3d(\".concat(height, \"px, 0px, 0px)\");\r\n            pBar.style.width = \"100%\";\r\n            pBall.style.left = \"100%\";\r\n            document.body.style.overscrollBehaviorX = 'auto';\r\n            self.fixed = false;\r\n        }\r\n\r\n        if (self.fixed) {\r\n            var ns = s / 3;\r\n            self.ns = ns;\r\n            var wScroll = s * -1;\r\n\r\n            var _height = (self.height - self.elementHeight) * -1 / 3;\r\n\r\n            if (ns) sContents.style.transform = \"translate3d(\".concat(ns, \"px, 0px, 0px)\");\r\n            pBar.style.width = \"\".concat(pFill, \"%\");\r\n            pBall.style.left = \"\".concat(pFill, \"%\");\r\n            var newIndex = Math.floor(self.sectionNumber * (pFill / 100)) + 1;\r\n\r\n            if (newIndex < 10) {\r\n                newIndex = \"0\".concat(newIndex);\r\n            }\r\n\r\n            var maxIndex = self.sectionNumber;\r\n\r\n            if (maxIndex < 10) {\r\n                maxIndex = \"0\".concat(maxIndex);\r\n            }\r\n\r\n            self.element.querySelector(\".currentSlide\").innerHTML = newIndex;\r\n            self.element.querySelector(\".maxSlide\").innerHTML = maxIndex; // if(pFill >= 90 && !self.circleOpen){\r\n            //         self.toggleProgressCircle('open');\r\n            // }else if(pFill < 90 && self.circleOpen){\r\n            //         self.toggleProgressCircle('close');\r\n            // }\r\n            // if(newIndex > self.sectionNum - 1){\r\n            //         return;\r\n            // }else if(newIndex !== self.currentIndex){\r\n            //         self.currentIndex = newIndex;\r\n            // }\r\n            // self.changeImageOpacity();\r\n        }\r\n\r\n        self.scrollPos = s;\r\n    };\r\n    \r\n    ContentSlider.prototype.handleDrag = function() {\r\n        var self = this;\r\n        var wee = self.element.querySelector(ContentSlider.ELEMENTS.sliderContents);\r\n        wee.addEventListener('mousedown', function (e) {\r\n            self.mousedown = true;\r\n            self.x = e.clientX;\r\n        });\r\n        wee.addEventListener('mouseup', function (e) {\r\n            self.mousedown = false;\r\n        });\r\n        wee.addEventListener('mousemove', function (e) {\r\n            if (self.mousedown === true && self.scrollPos < +30 && self.scrollPos > (self.height - self.elementHeight) * -1 - 30) {\r\n                var ws = window.scrollY,\r\n                        change = (self.x - e.clientX) * 3,\r\n                        newPos = ws += change;\r\n                window.scrollTo(0, newPos);\r\n                self.x = e.clientX;\r\n            }\r\n        });\r\n    };\r\n    \r\n    ContentSlider.prototype.getOffsetTop = function(ele) {\r\n        var offsetTop = 0;\r\n\r\n        while (ele) {\r\n            offsetTop += ele.offsetTop;\r\n            ele = ele.offsetParent;\r\n        }\r\n\r\n        return offsetTop;\r\n    };\r\n    \r\n    ContentSlider.prototype.setTitlePos = function() {\r\n        var width = this.element.querySelector(\".fl-row-content\").offsetWidth,\r\n                title = this.element.querySelector(\".sliderLabel\"),\r\n                prog = this.element.querySelector(\".progressBarContainer\");\r\n        var leftPos = (window.innerWidth - width) / 2;\r\n        title.style.left = \"\".concat(leftPos, \"px\");\r\n        prog.style.left = \"\".concat(leftPos, \"px\");\r\n    };\r\n    \r\n    ContentSlider.prototype.handleResize = function() {\r\n        var self = this,\r\n                wContainer = self.element.querySelector(ContentSlider.ELEMENTS.widthContainer),\r\n                sContents = self.element.querySelector(ContentSlider.ELEMENTS.sliderContents),\r\n                pBar = self.element.querySelector(ContentSlider.ELEMENTS.progressBar),\r\n                pBall = self.element.querySelector(ContentSlider.ELEMENTS.progressBall);\r\n        window.addEventListener(\"resize\", function () {\r\n            self.setHeight();\r\n            self.setTitlePos();\r\n            self.scrollHandler.call(self, wContainer, sContents, pBar, pBall);\r\n            this.setTimeout(function () {\r\n                self.setMobileOffset();\r\n            }, 500);\r\n        });\r\n    };\r\n    \r\n    ContentSlider.prototype.setMobileOffset = function() {\r\n        var offset = $(\".owl-stage\").offset().left;\r\n        $(\".sliderLabel\").css(\"margin-left\", \"\".concat(offset, \"px\"));\r\n        $(\".progressBarContainerMobile\").css(\"margin-left\", \"\".concat(offset, \"px\"));\r\n    };\r\n    \r\n    ContentSlider.prototype.updatePagination = function(event) {\r\n        var index = event.item.index;\r\n        this.updateNav(index);\r\n    };\r\n    \r\n    ContentSlider.prototype.updateNav = function(index) {\r\n        var current = this.element.querySelector(\".currentSlideMobile\");\r\n        var slideMax = this.element.querySelector(\".maxSlideMobile\");\r\n        var max = this.element.querySelectorAll(\".mobile-slider-item\").length;\r\n        index++;\r\n\r\n        if (index < 10) {\r\n            index = \"0\".concat(index);\r\n        }\r\n\r\n        if (max < 10) {\r\n            max = \"0\".concat(max);\r\n        }\r\n\r\n        current.innerHTML = index;\r\n        slideMax.innerHTML = max;\r\n        var percent = index / max * 100;\r\n        var ball = this.element.querySelector(\".progressBallMobile\");\r\n        var fill = this.element.querySelector(\".progressBarFillMobile\");\r\n        ball.style.left = \"\".concat(percent, \"%\");\r\n        fill.style.width = \"\".concat(percent, \"%\");\r\n    };\r\n    \r\n    Behaviors.register_behavior(ContentSlider);\r\n    \r\n    module.ContentSlider = ContentSlider;\r\n    \r\n    return module;\r\n}));","/*global define, console*/\r\n/*jslint bitwise: true */\r\n/* updated 9/14/2016 */\r\n\r\nif (!Array.prototype.indexOf) {\r\n    Array.prototype.indexOf = function (elt) { /*, from*/\r\n        \"use strict\";\r\n        var len = this.length >>> 0, from = Number(arguments[1]) || 0, derparam;\r\n        from = (from < 0) ? Math.ceil(from) : Math.floor(from);\r\n        if (from < 0) {\r\n            from += len;\r\n        }\r\n\r\n        for (derparam; from < len; from += 1) {\r\n            if (from in this && this[from] === elt) {\r\n                return from;\r\n            }\r\n        }\r\n        return -1;\r\n    };\r\n}\r\n\r\n(function (root, factory) {\r\n    \"use strict\";\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(\"betteroffcanvas\", [\"jquery\"], factory);\r\n    } else {\r\n        // Browser globals\r\n        root.betteroffcanvas = factory(root.jQuery);\r\n    }\r\n}(this, function ($) {\r\n    //BetterOffcanvas\r\n    //Works like this:\r\n    /*\r\n    *  <button type=\"button\" data-toggle=\"offcanvas\" data-target=\"#any-selector\">\r\n    */\r\n\r\n    \"use strict\";\r\n\r\n    var $openTarget = null, currentLevel = 0, module = {}, isInDebounce = false,\r\n        target_has_touch = false,\r\n        focus_click_inquiry = false, click_keydown_inquiry = false,\r\n        eligibleTouches = {},\r\n        logger;\r\n    \r\n    /* Logger that throws away all data (default)\r\n     */\r\n    function null_logging() {\r\n        return;\r\n    }\r\n    \r\n    /* Logger that sends all logged data to the JS console.\r\n     */\r\n    function console_logging(log_data) {\r\n        return console.log(log_data);\r\n    }\r\n    \r\n    function switchLoggingMode(mode) {\r\n        switch (mode) {\r\n        case \"console\":\r\n            logger = console_logging;\r\n            break;\r\n        default:\r\n            logger = null_logging;\r\n            break;\r\n        }\r\n    }\r\n    \r\n    //Inform the user they can enable console logging\r\n    console.log(\"Offcanvas: You can enable detailed event logging by typing betteroffcanvas.switchLoggingMode('console').\");\r\n    switchLoggingMode(\"null\");\r\n\r\n    function initOffcanvasToggle($theToggle) {\r\n        var $theTarget = $($theToggle.data(\"target\")), toggleOptions = $theToggle.data(\"toggle-options\"),\r\n            state;\r\n\r\n        if ($theTarget.data(\"offcanvas-state\") === undefined) {\r\n            $theTarget.data(\"offcanvas-state\", {\"open\": false, \"parents\": null, \"$openChild\": null, \"openChildLvl\": 0, \"toggleOptions\": []});\r\n        }\r\n\r\n        state = $theTarget.data(\"offcanvas-state\");\r\n\r\n        if (state.toggleOptions === undefined) {\r\n            state.toggleOptions = [];\r\n        }\r\n\r\n        if (toggleOptions !== undefined) {\r\n            state.toggleOptions.push.apply(state.toggleOptions, toggleOptions.split(\" \"));\r\n        }\r\n\r\n        $theTarget.data(\"offcanvas-state\", state);\r\n\r\n        return $theTarget;\r\n    }\r\n\r\n    function findParentLevels($theTarget) {\r\n        var parents = [], tgtState = $theTarget.data(\"offcanvas-state\");\r\n\r\n        if (tgtState.parents === null) {\r\n            $theTarget.parents().each(function (index, pelem) {\r\n                var $pelem = $(pelem),\r\n                    parState = $pelem.data(\"offcanvas-state\"),\r\n                    $parTgl;\r\n\r\n                if (parState === undefined) {\r\n                    if ($pelem.attr(\"id\") !== undefined) {\r\n                        $parTgl = $(\"[data-toggle='offcanvas'][data-target='#\" + $pelem.attr(\"id\") + \"']\");\r\n                        if ($parTgl.length > 0) {\r\n                            initOffcanvasToggle($parTgl);\r\n                            parents.push(pelem);\r\n                        }\r\n                    }\r\n                } else {\r\n                    parents.push(pelem);\r\n                }\r\n            });\r\n\r\n            tgtState.parents = parents;\r\n            $theTarget.data(\"offcanvas-state\", tgtState);\r\n\r\n            $(tgtState.parents).each(function (index, pelem) {\r\n                findParentLevels($(pelem));\r\n            });\r\n        }\r\n    }\r\n\r\n    function initOffcanvas($theTarget, toggleOptions) {\r\n        if (toggleOptions === undefined) {\r\n            toggleOptions = [];\r\n        }\r\n        \r\n        if ($theTarget.data(\"offcanvas-state\") === undefined) {\r\n            $theTarget.data(\"offcanvas-state\", {\"open\": false, \"parents\": null, \"$openChild\": null, \"openChildLvl\": 0, \"toggleOptions\": toggleOptions});\r\n        }\r\n\r\n        findParentLevels($theTarget);\r\n    }\r\n\r\n    function isOffcanvas($theTargetList) {\r\n        var truth = true;\r\n\r\n        $theTargetList.each(function (index, elem) {\r\n            var $theTarget = $(elem), $toggles;\r\n\r\n            if ($theTarget.data(\"offcanvas-state\") !== undefined) {\r\n                truth = truth & true;\r\n                return;\r\n            }\r\n\r\n            $toggles = $(\"[data-toggle='offcanvas'][data-target='#\" + $theTarget.attr(\"id\") + \"']\");\r\n\r\n            if ($toggles.length > 0) {\r\n                initOffcanvas($theTarget);\r\n\r\n                $toggles.each(function (index, elem) {\r\n                    initOffcanvasToggle($(elem));\r\n                });\r\n\r\n                truth &= true;\r\n                return;\r\n            }\r\n\r\n            truth &= false;\r\n        });\r\n\r\n        return truth;\r\n    }\r\n\r\n    function isChildOffcanvas($theTarget, $potentialParent) {\r\n        if (!isOffcanvas($theTarget) || !isOffcanvas($potentialParent)) {\r\n            return false;\r\n        }\r\n\r\n        if ($theTarget.data(\"offcanvas-state\").parents.indexOf($potentialParent[0]) === -1) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function isTopLevelOffcanvas($theTarget) {\r\n        return isOffcanvas($theTarget) && $theTarget.data(\"offcanvas-state\").parents.length === 0;\r\n    }\r\n\r\n    function updateBackdrop(newLevel, openTargetList) {\r\n        var $backdropDivs = $(\"[data-offcanvas-backdrop]\");\r\n\r\n        $backdropDivs.each(function (index, bdElem) {\r\n            var $bdElem = $(bdElem),\r\n                bdLevel = $bdElem.data(\"offcanvas-backdrop\"),\r\n                bdFor = $bdElem.data(\"offcanvas-backdrop-for\");\r\n\r\n            if (bdFor !== undefined && openTargetList.indexOf(bdFor) === -1) {\r\n                $bdElem.removeClass(\"is-Offcanvas--backdrop_active\");\r\n                $bdElem.addClass(\"is-Offcanvas--backdrop_inactive\");\r\n            } else if (newLevel >= bdLevel) {\r\n                $bdElem.addClass(\"is-Offcanvas--backdrop_active\");\r\n                $bdElem.removeClass(\"is-Offcanvas--backdrop_inactive\");\r\n            } else {\r\n                $bdElem.removeClass(\"is-Offcanvas--backdrop_active\");\r\n                $bdElem.addClass(\"is-Offcanvas--backdrop_inactive\");\r\n            }\r\n        });\r\n\r\n        currentLevel = newLevel;\r\n    }\r\n\r\n    function scanChildrenWithinLevel($theTarget, cbk) {\r\n        $theTarget.each(function (index, elem) {\r\n            var $elem = $(elem);\r\n\r\n            if (isOffcanvas($elem)) {\r\n                return;\r\n            }\r\n\r\n            cbk($elem);\r\n            scanChildrenWithinLevel($elem.children(), cbk);\r\n        });\r\n    }\r\n\r\n    function setFocusableWithinLevel($theTarget, isFocusable) {\r\n        if (isFocusable === undefined) {\r\n            isFocusable = true;\r\n        }\r\n\r\n        logger(\"changing focus state to \" + isFocusable);\r\n\r\n        scanChildrenWithinLevel($theTarget.children(), function ($elem) {\r\n            if ($elem.data(\"offcanvas-tabindex\") === undefined) {\r\n                //Determine if this element should be focusable or not...\r\n                if ($elem.attr(\"tabindex\") !== undefined) {\r\n                    $elem.data(\"offcanvas-tabindex\", $elem.attr(\"offcanvas-tabindex\"));\r\n                } else {\r\n                    $elem.data(\"offcanvas-tabindex\", null);\r\n                }\r\n            }\r\n\r\n            if (isFocusable) {\r\n                if ($elem.data(\"offcanvas-tabindex\") === null) {\r\n                    $elem.removeAttr(\"tabindex\");\r\n                } else {\r\n                    $elem.attr(\"tabindex\", $elem.data(\"offcanvas-tabindex\"));\r\n                }\r\n            } else {\r\n                $elem.attr(\"tabindex\", -1);\r\n            }\r\n        });\r\n    }\r\n\r\n    function openOffcanvas($theTarget, $theToggle, eventType, isRecursive, recursiveCount) {\r\n        var tgtState, $pelem, parState, newLevel = 1, i, targetIDs = [], $topElem, topState, newEvent;\r\n        if ($theTarget !== null && $theTarget !== undefined) {\r\n            logger(\"Open Offcanvas \" + $theTarget.attr(\"id\"));\r\n        } else {\r\n            logger(\"Open Offcanvas (no target)\");\r\n        }\r\n\r\n        if ($theTarget === null) {\r\n            return;\r\n        }\r\n        tgtState = $theTarget.data(\"offcanvas-state\");\r\n\r\n        if (recursiveCount === undefined) {\r\n            recursiveCount = 1;\r\n        }\r\n\r\n        $theTarget.addClass(\"is-Offcanvas--open\");\r\n        $theTarget.removeClass(\"is-Offcanvas--closed\");\r\n        tgtState.open = true;\r\n        tgtState.open_event = eventType;\r\n        $theTarget.data(\"offcanvas-state\", tgtState);\r\n\r\n        $(\"[data-toggle='offcanvas'][data-target='#\" + $theTarget.attr(\"id\") + \"']\").addClass(\"is-Offcanvas--target_open\");\r\n\r\n        setFocusableWithinLevel($theTarget, true);\r\n\r\n        if (tgtState.parents.length > 0) {\r\n            $pelem = $(tgtState.parents[0]);\r\n\r\n            parState = $pelem.data(\"offcanvas-state\");\r\n            parState.$openChild = $theTarget;\r\n            parState.openChildLvl = recursiveCount;\r\n            $pelem.data(\"offcanvas-state\", parState);\r\n\r\n            $pelem.addClass(\"is-Offcanvas--open_sublvl_\" + recursiveCount);\r\n\r\n            openOffcanvas($pelem, $theToggle, eventType, true, recursiveCount + 1);\r\n\r\n            newLevel = newLevel + tgtState.parents.length;\r\n\r\n            $topElem = $(tgtState.parents[tgtState.parents.length - 1]);\r\n            if ($topElem.length > 0) {\r\n                topState = $topElem.data(\"offcanvas-state\");\r\n\r\n                if (topState !== undefined) {\r\n                    if (topState.childDepthLvl !== undefined) {\r\n                        $topElem.removeClass(\"is-Offcanvas--depth_\" + topState.childDepthLvl);\r\n                    }\r\n\r\n                    topState.childDepthLvl = tgtState.parents.length;\r\n                    $topElem.addClass(\"is-Offcanvas--depth_\" + topState.childDepthLvl);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (isRecursive !== true) {\r\n            targetIDs.push($theTarget.attr(\"id\"));\r\n\r\n            for (i = 0; i < tgtState.parents.length; i += 1) {\r\n                targetIDs.push(tgtState.parents[i].getAttribute(\"id\"));\r\n            }\r\n\r\n            updateBackdrop(newLevel, targetIDs);\r\n        }\r\n\r\n        $openTarget = $theTarget;\r\n\r\n        newEvent = new $.Event({\r\n            \"type\": \"offcanvas-open\",\r\n            \"target\": $theTarget,\r\n            \"toggle\": $theToggle,\r\n            \"from_child\": isRecursive,\r\n            \"children_count\": recursiveCount\r\n        });\r\n        $theTarget.trigger(newEvent);\r\n    }\r\n    \r\n    /* Determine if a user-triggered event is allowed to dismiss an offcanvas\r\n     * or not.\r\n     * \r\n     * This function is consistenly called before dismissOffcanvas in order to\r\n     * gate event-driven dismissals consistently. Programmatic dismissals (e.g.\r\n     * by third-party code or for clearing the way for the next offcanvas) are\r\n     * NOT gated in the same way.\r\n     * \r\n     * To gate dismissals in the same fashion, call this function with the\r\n     * following four parameters:\r\n     * \r\n     *  - $_openTarget: The currently open offcanvas at the start of event\r\n     *                 processing. Specify false to automatically select the\r\n     *                 current open target. Specify undefined for no open\r\n     *                 target.\r\n     * \r\n     *  - $newTarget:  The new offcanvas that you plan to open at the end of\r\n     *                 event processing.\r\n     * \r\n     *  - evt:         The event that triggered your current event processing.\r\n     *                 Your code is expected to filter mobile emulation events\r\n     *                 such as emulated click-after-touchend through some means\r\n     *                 so that this function can differentiate between the two.\r\n     * \r\n     *  - $evtToggle:  The element which triggered the event. May be a\r\n     *                 data-toggle or data-dismiss element. This is not,\r\n     *                 strictly speaking, evt.target: client code is allowed and\r\n     *                 expected to traverse the parents of the target to find,\r\n     *                 say, the button containing the actual event target.\r\n     * \r\n     * In the event of recieving false from this function, event handlers should\r\n     * cease any event processing which would cause the open target to be\r\n     * dismissed, including opening other offcanvas hierarchies as that will\r\n     * implicitly dismiss the current one.\r\n     */\r\n    function eventCanDismissOffcanvas($_openTarget, $newTarget, evt, $evtToggle) {\r\n        var openTargetState = {\"toggleOptions\": []}, openTargetIsNoHover = false,\r\n            openTargetWasHovered = false,\r\n            targetsAreIdentical = false,\r\n            evtFromToggle = false, evtFromDismiss = false,\r\n            evtWithinOpenTarget = false,\r\n            evtToggleOptions, evtToggleIsNoHover = false,\r\n            evtToggleTargetsOpenTarget = false,\r\n            hasNewTarget,\r\n            hasOpenTarget,\r\n            hasEventToggle;\r\n        \r\n        if ($_openTarget === false) {\r\n            $_openTarget = $openTarget;\r\n        }\r\n        \r\n        hasNewTarget = $newTarget !== undefined && $newTarget !== null && $newTarget.length >= 1;\r\n        hasOpenTarget = $_openTarget !== undefined && $_openTarget !== null && $_openTarget.length >= 1;\r\n        hasEventToggle = $evtToggle !== undefined && $evtToggle !== null && $evtToggle.length >= 1;\r\n        \r\n        if (hasOpenTarget) {\r\n            openTargetState = $_openTarget.data(\"offcanvas-state\");\r\n            openTargetIsNoHover = openTargetState.toggleOptions.indexOf(\"nohover\") > -1;\r\n            openTargetWasHovered = openTargetState.open_event === \"mouseover\";\r\n            \r\n            if (evt.target) {\r\n                evtWithinOpenTarget = $_openTarget[0] === evt.target || $.contains($_openTarget[0], evt.target);\r\n            }\r\n        } else {\r\n            logger(\"Dismissals are always allowed if no offcanvas is open\");\r\n            return true;\r\n        }\r\n        \r\n        if (hasNewTarget) {\r\n            targetsAreIdentical = $_openTarget[0] === $newTarget[0];\r\n        }\r\n        \r\n        if (hasEventToggle) {\r\n            evtFromToggle = $evtToggle.filter(\"[data-toggle='offcanvas']\").length > 0 ||\r\n                            $evtToggle.parents().filter(\"[data-toggle='offcanvas']\").length > 0;\r\n            evtFromDismiss = $evtToggle.filter(\"[data-dismiss='offcanvas']\").length > 0 ||\r\n                             $evtToggle.parents().filter(\"[data-dismiss='offcanvas']\").length > 0;\r\n            \r\n            evtToggleOptions = $evtToggle.data(\"toggle-options\");\r\n            if (evtToggleOptions !== undefined) {\r\n                evtToggleOptions = evtToggleOptions.split(\" \");\r\n            } else {\r\n                evtToggleOptions = [];\r\n            }\r\n            \r\n            evtToggleIsNoHover = evtToggleOptions.indexOf(\"nohover\") > -1;\r\n            evtToggleTargetsOpenTarget = $evtToggle.data(\"target\") === \"#\" + $_openTarget.attr(\"id\");\r\n        }\r\n        \r\n        //Dismissals by toggling the same target\r\n        if (evt.type === \"click\" && openTargetWasHovered) {\r\n            if (targetsAreIdentical) {\r\n                logger(\"Not going to allow dismiss from click on already hovered nav.\");\r\n                return false;\r\n            }\r\n        }\r\n        \r\n        if (evt.type === \"focusin\") {\r\n            if (targetsAreIdentical) { //TODO: should this be evtWithinOpenTarget?\r\n                logger(\"Not going to allow dismiss from focusin within same target\");\r\n                return false;\r\n            }\r\n            \r\n            if (!hasNewTarget && (evtFromToggle || evtFromDismiss)) {\r\n                logger(\"Ignoring focus-dismiss due to the fact that event target is an offcanvas toggle.\");\r\n                logger(\"Currently focused off-canvas element: \" + $_openTarget.attr(\"id\"));\r\n                return false;\r\n            }\r\n        }\r\n        \r\n        if (evt.type === \"mouseover\" && !evtWithinOpenTarget) {\r\n            if (evtFromDismiss) {\r\n                logger(\"Not going to allow dismiss until user actually clicks hovered dismiss button.\");\r\n                return false;\r\n            } else if (evtToggleIsNoHover || openTargetIsNoHover) {\r\n                logger(\"Not going to allow dismiss as toggle is nohover.\");\r\n                return false;\r\n            } else if (evtFromToggle && targetsAreIdentical) {\r\n                logger(\"Not going to allow dismiss as toggle is for current offcanvas.\");\r\n                return false;\r\n            }\r\n        }\r\n        \r\n        return true;\r\n    }\r\n\r\n    function dismissOffcanvas($theTarget, numLvls) {\r\n        var tgtState = $theTarget.data(\"offcanvas-state\"), newLvl = -1, i, targetIDs = [], $topElem, topState, newEvent;\r\n\r\n        if ($theTarget !== null && $theTarget !== undefined) {\r\n            logger(\"Dismiss Offcanvas \" + $theTarget.attr(\"id\"));\r\n        } else {\r\n            logger(\"Dismiss Offcanvas (no target)\");\r\n        }\r\n\r\n        if (numLvls === undefined) {\r\n            /* NumLvls is the number of recursion levels (children being auto-dismissed) */\r\n            numLvls = 1;\r\n\r\n            $topElem = $(tgtState.parents[tgtState.parents.length - 1]);\r\n            if ($topElem.length > 0) {\r\n                topState = $topElem.data(\"offcanvas-state\");\r\n\r\n                if (topState !== undefined) {\r\n                    if (topState.childDepthLvl !== undefined) {\r\n                        $topElem.removeClass(\"is-Offcanvas--depth_\" + topState.childDepthLvl);\r\n                    }\r\n\r\n                    topState.childDepthLvl = tgtState.parents.length - 1;\r\n                    $topElem.addClass(\"is-Offcanvas--depth_\" + topState.childDepthLvl);\r\n                }\r\n            }\r\n        }\r\n\r\n        $theTarget.removeClass(\"is-Offcanvas--open\");\r\n        $theTarget.addClass(\"is-Offcanvas--closed\");\r\n        tgtState.open = false;\r\n        tgtState.open_event = undefined;\r\n        $theTarget.data(\"offcanvas-state\", tgtState);\r\n\r\n        $(\"[data-toggle='offcanvas'][data-target='#\" + $theTarget.attr(\"id\") + \"']\").removeClass(\"is-Offcanvas--target_open\");\r\n\r\n        newEvent = new $.Event({\r\n            \"type\": \"offcanvas-dismiss\",\r\n            \"target\": $theTarget\r\n        });\r\n        $theTarget.trigger(newEvent);\r\n\r\n        //TODO: How do we actually tell if the offcanvas is visible when closed?\r\n        //(e.g. desktop nav)\r\n        if (!isTopLevelOffcanvas($theTarget)) {\r\n            if ($theTarget !== null) {\r\n                logger(\"Marking non-top-level offcanvas nav \" + $theTarget.attr(\"id\") + \" as untabbable\");\r\n            }\r\n            setFocusableWithinLevel($theTarget, false);\r\n        }\r\n\r\n        if (tgtState.$openChild !== null) {\r\n            dismissOffcanvas(tgtState.$openChild, numLvls + 1);\r\n        } else {\r\n            if (tgtState.parents.length > 0) {\r\n                $openTarget = $(tgtState.parents[numLvls - 1]);\r\n                if ($openTarget.length === 0) {\r\n                    $openTarget = null;\r\n                }\r\n\r\n                $(tgtState.parents).each(function (index, pelem) {\r\n                    var $pelem = $(pelem), parState = $pelem.data(\"offcanvas-state\"), childlvl, newChildLvl = parState.openChildLvl - numLvls;\r\n\r\n                    $pelem.removeClass(\"is-Offcanvas--open_sublvl_\" + parState.openChildLvl);\r\n                    if (newChildLvl > 0) {\r\n                        $pelem.addClass(\"is-Offcanvas--open_sublvl_\" + newChildLvl);\r\n                    } else {\r\n                        parState.$openChild = null;\r\n                    }\r\n\r\n                    parState.openChildLvl = newChildLvl;\r\n                    $pelem.data(\"offcanvas-state\", parState);\r\n\r\n                    if (newChildLvl > newLvl) {\r\n                        newLvl = newChildLvl;\r\n                    }\r\n                });\r\n            } else {\r\n                $openTarget = null;\r\n                newLvl = -1;\r\n            }\r\n\r\n            for (i = 0; i < tgtState.parents.length; i += 1) {\r\n                targetIDs.push(tgtState.parents[i].getAttribute(\"id\"));\r\n            }\r\n\r\n            updateBackdrop(newLvl + 1, targetIDs);\r\n        }\r\n    }\r\n\r\n    function dismissOpenOffcanvas() {\r\n        if ($openTarget !== null) {\r\n            dismissOffcanvas($openTarget);\r\n        }\r\n    }\r\n\r\n    function enableDebounce() {\r\n        if (!isInDebounce) {\r\n            logger(\"Debounce timeout enabled\");\r\n            isInDebounce = true;\r\n            window.setTimeout(function () {\r\n                logger(\"Debounce timeout expired - event processing will resume\");\r\n                isInDebounce = false;\r\n            }, 100);\r\n        }\r\n    }\r\n\r\n    $(document).on(\"keydown\", function (evt) {\r\n        if (evt.keyCode === 27) {\r\n            dismissOpenOffcanvas();\r\n        } else if (evt.keyCode === 13) {\r\n            logger(\"Keydown event - ENTER. Disabling link clickthrough for the next click event.\");\r\n            click_keydown_inquiry = true; //mark that the following click event is\r\n                                        //from a keyboard\r\n        }\r\n    });\r\n\r\n    $(document).on(\"ready\", function (evt) {\r\n        var openIDs = [], openState, i;\r\n\r\n        if ($openTarget !== null) {\r\n            openState = $openTarget.data(\"offcanvas-state\");\r\n\r\n            for (i = 0; i < openState.parents.length; i += 1) {\r\n                openIDs.push(openState.parents[i].getAttribute(\"id\"));\r\n            }\r\n\r\n            updateBackdrop(currentLevel, openIDs);\r\n        }\r\n    });\r\n\r\n    function on_focusin(evt) {\r\n        var $tgt = $(evt.target), $tgtOffcanvas = null,\r\n            $tgtParents = $tgt.parents(), $toggleTarget,\r\n            dismissAllowed;\r\n\r\n        $tgtParents.each(function (index, elem) {\r\n            if ($tgtOffcanvas === null) {\r\n                if (isOffcanvas($(elem))) {\r\n                    $tgtOffcanvas = $(elem);\r\n                }\r\n            }\r\n        });\r\n\r\n        if (isInDebounce) {\r\n            logger(\"Processed event (debounced, type: focusin)\");\r\n            return;\r\n        }\r\n        \r\n        if ($tgt.data(\"toggle\") === \"offcanvas\") {\r\n            $toggleTarget = $($tgt.data(\"target\"));\r\n            if (!isTopLevelOffcanvas($toggleTarget)) {\r\n                if ($toggleTarget !== null) {\r\n                    logger(\"Marking non-top-level offcanvas nav \" + $toggleTarget.attr(\"id\") + \" as untabbable\");\r\n                }\r\n                setFocusableWithinLevel($toggleTarget, false);\r\n            }\r\n        }\r\n        \r\n        if (!eventCanDismissOffcanvas($openTarget, $tgtOffcanvas, evt, $tgt)) {\r\n            return;\r\n        }\r\n\r\n        if ($tgtOffcanvas === null && $openTarget !== null) {\r\n            logger(\"Focused on something outside of off-canvas nav \" + $openTarget.attr(\"id\"));\r\n            logger($tgt);\r\n\r\n            enableDebounce(); //prevent subsequent click event handlers from tripping\r\n\r\n            while ($openTarget !== null) {\r\n                dismissOpenOffcanvas();\r\n            }\r\n        } else {\r\n            if ($tgtOffcanvas !== null) {\r\n                logger(\"Focused inside off-canvas nav \" + $tgtOffcanvas.attr(\"id\"));\r\n            }\r\n\r\n            if ($openTarget !== null) {\r\n                enableDebounce(); //prevent subsequent click event handlers from tripping\r\n\r\n                while ($openTarget !== null && !isChildOffcanvas($tgtOffcanvas, $openTarget)) {\r\n                    logger(\"Dismissing off-canvas menu \" + $openTarget.attr(\"id\"));\r\n                    dismissOffcanvas($openTarget);\r\n                }\r\n            }\r\n            openOffcanvas($tgtOffcanvas, $tgt, evt.type);\r\n        }\r\n    }\r\n    \r\n    //Track a specific set of focus events to ensure they don't result in a\r\n    //click.\r\n    $(document).on(\"focusin\", function (evt) {\r\n        logger(evt.type);\r\n\r\n        focus_click_inquiry = true;\r\n\r\n        window.setTimeout(function () {\r\n            if (focus_click_inquiry) { //e.g. if a click event hasn't happened\r\n                on_focusin(evt);\r\n            }\r\n        }, 300);\r\n    });\r\n    \r\n    //Activate touch-specific behaviors if we have ever recieved a touch event.\r\n    $(document).on(\"touchstart touchend touchmove touchcancel\", function (evt) {\r\n        target_has_touch = true;\r\n    });\r\n    \r\n    /* Track the starting position of every touch we get. */\r\n    $(document).on(\"touchstart\", function (evt) {\r\n        var i, touch;\r\n        \r\n        for (i = 0; i < evt.originalEvent.changedTouches.length; i += 1) {\r\n            touch = evt.originalEvent.changedTouches.item(i);\r\n            eligibleTouches[touch.identifier] = {\r\n                \"x\": touch.screenX,\r\n                \"y\": touch.screenY\r\n            };\r\n        }\r\n    });\r\n    \r\n    /* Track and remove touches which have become drags.\r\n     * Assumes a minimum drag distance of 15px.\r\n     * Returns true if any of the given touches are still eligible.\r\n     */\r\n    function testAndPruneTouchList(changedTouches) {\r\n        var i, touch, stTouch, dist, MAX_DIST = 15, num_valid_touches = 0;\r\n        \r\n        for (i = 0; i < changedTouches.length; i += 1) {\r\n            touch = changedTouches.item(i);\r\n            \r\n            if (eligibleTouches.hasOwnProperty(touch.identifier)) {\r\n                stTouch = eligibleTouches[touch.identifier];\r\n                dist = Math.sqrt(Math.pow((touch.screenX - stTouch.x), 2.0)\r\n                               + Math.pow((touch.screenY - stTouch.y), 2.0));\r\n                \r\n                if (dist > MAX_DIST) {\r\n                    delete eligibleTouches[touch.identifier];\r\n                } else {\r\n                    num_valid_touches += 1;\r\n                }\r\n            }\r\n        }\r\n        \r\n        return num_valid_touches > 0;\r\n    }\r\n    \r\n    /* Remove touches that have become drags.\r\n     * This function assumes a minimum drag distance of 15px.\r\n     */\r\n    $(document).on(\"touchmove\", function (evt) {\r\n        testAndPruneTouchList(evt.originalEvent.changedTouches);\r\n    });\r\n    \r\n    /* Remove touches that have cancelled for hardware or OS specific reasons.\r\n     */\r\n    $(document).on(\"touchcancel\", function (evt) {\r\n        var i, touch;\r\n        \r\n        for (i = 0; i < evt.originalEvent.changedTouches.length; i += 1) {\r\n            touch = evt.originalEvent.changedTouches.item(i);\r\n            delete eligibleTouches[touch.identifier];\r\n        }\r\n    });\r\n    \r\n    /* Our main, extremely complicated event handler.\r\n     * We have to track a whole bunch of corner cases, since users expect the\r\n     * following out of their navigation structures:\r\n     * \r\n     *  1. Hovering over a toggle should open it\r\n     *  2. Touching a toggle with a finger should open it\r\n     *  3. Clicking on a toggle should navigate to it's link target, as it has\r\n     *     already opened from a hover\r\n     *  4. Tab-focusing content should cause offcanvas's open/close state to\r\n     *     follow through it\r\n     *  5. Touches should only be honored if they were not the end of a drag\r\n     */\r\n    $(document).on(\"click touchend mouseover\", function (evt) {\r\n        var i, sentinel = false,\r\n            $theToggle = $(evt.target),\r\n            $theTarget,\r\n            tgtStatus,\r\n            tgtState,\r\n            $btnParent = $theToggle.parents().filter(\"[data-toggle='offcanvas']\"),\r\n            skipToggle = false,\r\n            hoverMin = $(\"body\").data(\"offcanvas-hover-min\"),\r\n            toggleOptions,\r\n            hasEligibleTouches;\r\n\r\n        logger(evt.type);\r\n\r\n        focus_click_inquiry = false;\r\n\r\n        if (hoverMin === undefined) {\r\n            hoverMin = 0;\r\n        }\r\n\r\n        if (evt.type === \"mouseover\") {\r\n            if ($(window).width() < hoverMin) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        if ($theToggle.data(\"toggle\") !== \"offcanvas\" && $btnParent.length > 0) { //Fixup hits on child text, graphical bits, etc\r\n            $theToggle = $btnParent;\r\n        }\r\n\r\n        if (($openTarget === null || $openTarget === undefined || $openTarget.length === 0) && $theToggle.data(\"toggle\") !== \"offcanvas\") {\r\n            return;\r\n        }\r\n\r\n        if (evt.type !== \"mouseover\" && isInDebounce) {\r\n            logger(\"Processed event (debounced)\");\r\n            evt.preventDefault();\r\n            return;\r\n        }\r\n        \r\n        //Check if any of our touches were actually drags so we can ignore em\r\n        if (evt.type === \"touchend\") {\r\n            hasEligibleTouches = testAndPruneTouchList(evt.originalEvent.changedTouches);\r\n            \r\n            if (!hasEligibleTouches) {\r\n                logger(\"Ignoring touch event as it is the result of a drag\");\r\n                return;\r\n            }\r\n        }\r\n\r\n        toggleOptions = $theToggle.data(\"toggle-options\");\r\n        if (toggleOptions !== undefined) {\r\n            toggleOptions = toggleOptions.split(\" \");\r\n        } else {\r\n            toggleOptions = [];\r\n        }\r\n\r\n        if (evt.type === \"mouseover\" && toggleOptions.indexOf(\"nohover\") > -1) {\r\n            logger(\"Not opening a no-hover toggle\");\r\n            return;\r\n        }\r\n        \r\n        //Used to allow using the <a>nchor portion of a dropdown toggle\r\n        //but only after it was opened using a mouse\r\n        if ($(window).width() >= hoverMin &&\r\n                $theToggle[0].tagName === \"A\" &&\r\n                evt.type === \"click\" &&\r\n                !target_has_touch &&\r\n                !click_keydown_inquiry && //and event is not generated by a keyboard\r\n                toggleOptions.indexOf(\"nohover\") === -1 &&\r\n                toggleOptions.indexOf(\"nohref\") === -1) {\r\n\r\n            logger(\"Allowing link to resolve instead of opening toggle\");\r\n            return;\r\n        }\r\n\r\n        click_keydown_inquiry = false; //clear the \"click event was generated by\r\n                                     //a keyboard event\" flag so the user can\r\n                                     //switch back to mouse input\r\n        \r\n        if ($openTarget !== null && $openTarget !== undefined && $openTarget.length > 0) {\r\n            //Determine if it's okay to do anything that might dismiss an offcanvas\r\n            //based on this event\r\n            tgtState = $openTarget.data(\"offcanvas-state\");\r\n            if (tgtState === undefined) {\r\n                //This step is needed if the offcanvas elements were deleted and\r\n                //recreated behind our back (e.g. because PageTransitions). In that\r\n                //case all we can do is drop the current $openTarget entirely.\r\n                $openTarget = undefined;\r\n            }\r\n        }\r\n        \r\n        if ($theToggle.data(\"toggle\") === \"offcanvas\") {\r\n            $theTarget = initOffcanvasToggle($theToggle);\r\n            findParentLevels($theTarget);\r\n        }\r\n\r\n        if (!eventCanDismissOffcanvas($openTarget, $theTarget, evt, $theToggle)) {\r\n            return;\r\n        }\r\n        \r\n        logger(\"Processed event\");\r\n        \r\n        if ($openTarget !== null &&\r\n                $openTarget !== undefined &&\r\n                $openTarget.length > 0 &&\r\n                !$.contains($openTarget[0], evt.target) &&\r\n                $openTarget[0] !== evt.target) {\r\n            \r\n            //Dismiss offcanvas by clicking outside it's area\r\n            if (\"#\" + $openTarget.attr(\"id\") === $theToggle.data(\"target\")) {\r\n                skipToggle = true;\r\n            }\r\n            \r\n            if ($theToggle.filter(\"[data-dismiss='offcanvas']\").length > 0) {\r\n                logger(\"Not overridding a click on an existing dismiss button just because the click handler happened to win a race condition\");\r\n            } else {\r\n                logger(tgtState.toggleOptions);\r\n                logger(toggleOptions);\r\n\r\n                enableDebounce();\r\n\r\n                if ($($theToggle.data(\"target\"))[0] === $openTarget[0]) {\r\n                    //If we have clicked on a toggle for the currently open offcanvas, eat the event\r\n                    evt.preventDefault();\r\n                    evt.stopPropagation();\r\n                    evt.stopImmediatePropagation();\r\n                }\r\n\r\n                dismissOffcanvas($openTarget);\r\n            }\r\n        }\r\n\r\n        if ($theTarget !== undefined && !skipToggle) { //Open offcanvas via a toggle link\r\n            enableDebounce();\r\n\r\n            tgtState = $theTarget.data(\"offcanvas-state\");\r\n\r\n            //Determine if a different offcanvas tree is active, and, if so, dismiss it first.\r\n            while ($openTarget !== null && $openTarget !== undefined) {\r\n                sentinel = $openTarget[0] === $theTarget[0];\r\n\r\n                for (i = 0; i < tgtState.parents.length; i += 1) {\r\n                    if ($openTarget[0] === tgtState.parents[i]) {\r\n                        sentinel = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (sentinel) {\r\n                    break;\r\n                }\r\n\r\n                dismissOffcanvas($openTarget);\r\n            }\r\n\r\n            if (tgtState.open) {\r\n                dismissOffcanvas($theTarget);\r\n            } else {\r\n                openOffcanvas($theTarget, $theToggle, evt.type);\r\n            }\r\n\r\n            if ($theToggle[0].tagName.toLowerCase() === \"a\" || $theToggle[0].tagName.toLowerCase() === \"button\") {\r\n                evt.preventDefault();\r\n            }\r\n        }\r\n    });\r\n    \r\n    /* Another, slightly less complex event handler for dismissing open content\r\n     */\r\n    $(document).on(\"click touchend\", function (evt) {\r\n        var $theToggle = $(evt.target), $theTarget, tgtStatus, tgtState, $btnParent = $theToggle.parents().filter(\"[data-dismiss='offcanvas']\"), skipToggle = false, i, sentinel = false, $toDismiss = $openTarget;\r\n\r\n        if ($theToggle.data(\"dismiss\") !== \"offcanvas\" && $btnParent.length > 0) { //Fixup hits on child text, graphical bits, etc\r\n            $theToggle = $btnParent;\r\n        }\r\n\r\n        if ($theToggle.data(\"dismiss\") !== \"offcanvas\") {\r\n            return;\r\n        }\r\n\r\n        if (isInDebounce) {\r\n            logger(\"Processed event (debounced)\");\r\n            evt.preventDefault();\r\n            return;\r\n        }\r\n\r\n        enableDebounce();\r\n\r\n        if ($theToggle.data(\"target\") !== undefined) {\r\n            $toDismiss = $($theToggle.data(\"target\"));\r\n        }\r\n\r\n        if ($toDismiss.length > 0) {\r\n            dismissOffcanvas($toDismiss);\r\n        }\r\n        \r\n        evt.preventDefault();\r\n    });\r\n\r\n    module.isOffcanvas = isOffcanvas;\r\n    module.isChildOffcanvas = isChildOffcanvas;\r\n    module.isTopLevelOffcanvas = isTopLevelOffcanvas;\r\n    module.initOffcanvas = initOffcanvas;\r\n    module.initOffcanvasToggle = initOffcanvasToggle;\r\n    module.dismissOpenOffcanvas = dismissOpenOffcanvas;\r\n    module.openOffcanvas = openOffcanvas;\r\n    module.dismissOffcanvas = dismissOffcanvas;\r\n    module.enableDebounce = enableDebounce;\r\n    module.switchLoggingMode = switchLoggingMode;\r\n\r\n    return module;\r\n}));\r\n","/*global define, console, document, window, Promise*/\r\n(function (root, factory) {\r\n    \"use strict\";\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(\"PageTransition\", [\"jquery\", \"Behaviors\", \"Animations\"], factory);\r\n    } else {\r\n        root.PageTransition = factory(root.jQuery, root.Behaviors, root.Animations);\r\n    }\r\n}(this, function ($, Behaviors, Animations) {\r\n    \"use strict\";\r\n\r\n    var module = {};\r\n\r\n    function $do(that, target) {\r\n        return function () {\r\n            target.apply(that, arguments);\r\n        };\r\n    }\r\n\r\n    /* A page transition region is an element on the page with a unique ID that\r\n     * is the same from page load to page load. It is a good idea for there to\r\n     * be only one page transition region covering as much is it can on the\r\n     * page.\r\n     *\r\n     * An ID is mandatory for page transition regions.\r\n     */\r\n    function PageTransitionRegion(elem) {\r\n        Behaviors.init(PageTransitionRegion, this, arguments);\r\n\r\n        this.id = this.$elem.attr(\"id\");\r\n\r\n        this.$elem.on(\"click\", this.navigation_intent.bind(this));\r\n\r\n        this.claim_current_state();\r\n        $(window).on(\"popstate\", this.pop_state_intent.bind(this));\r\n    }\r\n\r\n    Behaviors.inherit(PageTransitionRegion, Behaviors.Behavior);\r\n\r\n    PageTransitionRegion.QUERY = \"[data-pagetransition-region]\";\r\n    \r\n    /* Determine if we can transition to a new page or not.\r\n     * \r\n     * This does not actually replace the content. Thus, you can make the check\r\n     * without committing to the new page.\r\n     */\r\n    PageTransitionRegion.prototype.can_replace = function ($new_document) {\r\n        var $other_region = $new_document.find(\"#\" + this.id);\r\n        if ($other_region.length === 0) {\r\n            $other_region = $new_document.filter(\"#\" + this.id);\r\n        }\r\n        \r\n        if ($other_region.length === 0) {\r\n            return false;\r\n        }\r\n        \r\n        return true;\r\n    };\r\n    \r\n    /* Prepare to replace the old content with the new one.\r\n     */\r\n    PageTransitionRegion.prototype.prepare_to_replace = function ($old_document) {\r\n        Behaviors.content_removal($old_document.children().filter(\":not([data-pagetransition-backdrop])\"));\r\n    };\r\n\r\n    /* Replace current content with content pulled from a new page we're trying\r\n     * to transition into.\r\n     *\r\n     * Returns false if we could not extract content from the new document.\r\n     * In this case, calling method should perform a traditional navigation to\r\n     * the new document.\r\n     */\r\n    PageTransitionRegion.prototype.replace = function ($new_document) {\r\n        var $other_region = $new_document.find(\"#\" + this.id), $children;\r\n        if ($other_region.length === 0) {\r\n            $other_region = $new_document.filter(\"#\" + this.id);\r\n        }\r\n\r\n        if ($other_region.length === 0) {\r\n            return false;\r\n        }\r\n        \r\n        $children = $other_region.children().filter(\":not([data-pagetransition-backdrop])\");\r\n\r\n        this.$elem.children().filter(\":not([data-pagetransition-backdrop])\").remove();\r\n        this.$elem.append($children);\r\n        $(window).scrollTop(0);\r\n        \r\n        Behaviors.content_ready($children.parent());\r\n\r\n        return true;\r\n    };\r\n\r\n    /* Replace the backdrop element.\r\n     *\r\n     * This is replaced separately so that each page can specify it's own outro\r\n     * backdrop without interrupting the incoming animation.\r\n     *\r\n     * This should only be called after the promise returned by transition_in\r\n     * resolves.\r\n     *\r\n     * Returns false if we could not extract content from the new document.\r\n     * In this case, calling method should perform a traditional navigation to\r\n     * the new document.\r\n     */\r\n    PageTransitionRegion.prototype.replace_backdrop = function ($new_document) {\r\n        var $other_region = $new_document.find(\"#\" + this.id);\r\n        if ($other_region.length === 0) {\r\n            $other_region = $new_document.filter(\"#\" + this.id);\r\n        }\r\n\r\n        if ($other_region.length === 0) {\r\n            return false;\r\n        }\r\n\r\n        this.$elem.attr(\"class\", $other_region.attr(\"class\"));\r\n        this.$elem.children().filter(\"[data-pagetransition-backdrop]\").remove();\r\n        this.$elem.append($other_region.children().filter(\"[data-pagetransition-backdrop]\"));\r\n\r\n        return true;\r\n    };\r\n\r\n    /* Change the browser URL to point to the new URL, and also fix relative\r\n     * links such that they resolve correctly.\r\n     *\r\n     * The transition property in the pushState data indicates that this entry\r\n     * was placed here by the PageTransitionRegion class. This lets us avoid\r\n     * applying transitions to things that shouldn't get them.\r\n     */\r\n    PageTransitionRegion.prototype.replace_state = function (url) {\r\n        window.history.pushState({transition: true, url: url}, \"\", url);\r\n        this.claim_current_state();\r\n    };\r\n    \r\n    /* Changes the document head to match what is present in the new document.\r\n     * \r\n     * Currently, only title replacement is supported, but this function may\r\n     * also be extended to \r\n     */\r\n    PageTransitionRegion.prototype.replace_head = function ($new_document) {\r\n        var $new_title = $new_document.filter(\"title\"),\r\n            $title = $(\"title\");\r\n        \r\n        if ($new_title.length === 0) {\r\n            $new_title = $new_document.find(\"title\");\r\n        }\r\n        \r\n        $title.text($new_title.text());\r\n    };\r\n    \r\n    /* Retrigger analytics scripts if so marked.\r\n     */\r\n    PageTransitionRegion.prototype.replace_analytics = function () {\r\n        var $reloadable_tags;\r\n        \r\n        //Step 1: Find tags marked for reloading.\r\n        $reloadable_tags = $(this.constructor.RELOADABLE_SCRIPT_QUERY);\r\n        \r\n        //Step 2: Reinsert them, hopefully causing them to be included again.\r\n        //We need to try this two separate ways based on if it's an inline\r\n        //script or external.\r\n        $reloadable_tags.detach();\r\n        \r\n        $reloadable_tags.each(function (index, elem) {\r\n            var $elem = $(elem), src = $elem.attr(\"src\");\r\n            \r\n            if (src !== undefined) {\r\n                //External script, recreate the tag\r\n                $elem.remove();\r\n                $elem = $(\"<script></script>\");\r\n                $elem.attr(\"src\", src);\r\n            }\r\n            \r\n            $(\"body\").append($elem);\r\n        });\r\n    };\r\n    \r\n    /* Indicates an analytics tag that can be retriggered for the new page load\r\n     * by just reloading it's tag.\r\n     */\r\n    PageTransitionRegion.RELOADABLE_SCRIPT_QUERY = \"[data-pagetransition-analytics='reloadable']\";\r\n\r\n    /* Claim the current history state for ourselves.\r\n     *\r\n     * By default, this is only called at the start of the page load.\r\n     */\r\n    PageTransitionRegion.prototype.claim_current_state = function () {\r\n        var url = window.location.href;\r\n        window.history.replaceState({transition: true, url: url}, \"\", url);\r\n    };\r\n\r\n    /* Determine if link is internal or external.\r\n     *\r\n     * The purpose of distinguishing between internal and external links is to\r\n     * check if we can transition to them properly or not. We can only\r\n     * transition into pages with compatible regions; so we assume that all\r\n     * internal links will use the same compatible theming.\r\n     *\r\n     * Also, transitioning to an external page requires specially configured\r\n     * web servers that allow CORS, which is a pain.\r\n     *\r\n     * Returns LINK_INTERNAL, LINK_EXTERNAL, LINK_POPUP, or LINK_HASH.\r\n     */\r\n    PageTransitionRegion.prototype.is_internal_link = function (url, $a) {\r\n        var extRegex = new RegExp(\"(\\/\\/|:)\"),\r\n            hashRegex = new RegExp(\"^#\"),\r\n            domainRelativeHashRegex = new RegExp(\"^\" + window.location.pathname + \"/#\"),\r\n            protRelativeRegex = new RegExp(\"^//\" + window.location.host),\r\n            protAbsoluteRegex = new RegExp('^' + window.location.protocol + \"//\" + window.location.host),\r\n            protRelativeHashRegex = new RegExp('^//' + window.location.host + window.location.pathname + \"#\"),\r\n            absoluteHashRegex = new RegExp('^' + window.location.protocol + \"//\" + window.location.host + window.location.pathname + \"#\");\r\n\r\n        if ($a.attr(\"target\") !== undefined && $a.attr(\"target\") !== \"\") {\r\n            return PageTransitionRegion.LINK_POPUP;\r\n        }\r\n        \r\n        if (hashRegex.test(url) || absoluteHashRegex.test(url) || protRelativeHashRegex.test(url) || domainRelativeHashRegex.test(url)) {\r\n            return PageTransitionRegion.LINK_HASH;\r\n        } else if (!extRegex.test(url) || protRelativeRegex.test(url) || protAbsoluteRegex.test(url)) {\r\n            return PageTransitionRegion.LINK_INTERNAL;\r\n        } else {\r\n            return PageTransitionRegion.LINK_EXTERNAL;\r\n        }\r\n    };\r\n\r\n    /* Transition out the current page.\r\n     *\r\n     * Returns a promise which resolves when the transition has completed.\r\n     *\r\n     * This default implementation uses a CSS class and waits for transitionEnd\r\n     * events.\r\n     */\r\n    PageTransitionRegion.prototype.transition_out = function () {\r\n        var aw;\r\n\r\n        this.$elem.removeClass(\"is-PageTransition--transition_loading\");\r\n        this.$elem.addClass(\"is-PageTransition--transition_out\");\r\n        this.$elem.removeClass(\"is-PageTransition--transition_in\");\r\n        aw = new Animations.AnimationWatcher(this.$elem.find(\"[data-pagetransition-backdrop]\"));\r\n\r\n        return aw.promise;\r\n    };\r\n\r\n    /* Transition to a loading animation.\r\n     *\r\n     * Returns a promise which resolves when the transition has completed.\r\n     *\r\n     * This default implementation uses a CSS class and waits for transitionEnd\r\n     * events.\r\n     */\r\n    PageTransitionRegion.prototype.transition_loading = function () {\r\n        var aw;\r\n\r\n        this.$elem.addClass(\"is-PageTransition--transition_loading\");\r\n        this.$elem.removeClass(\"is-PageTransition--transition_out\");\r\n        this.$elem.removeClass(\"is-PageTransition--transition_in\");\r\n        aw = new Animations.AnimationWatcher(this.$elem.find(\"[data-pagetransition-backdrop]\"));\r\n\r\n        return aw.promise;\r\n    };\r\n\r\n    /* Transition in the current page.\r\n     *\r\n     * Returns a promise which resolves when the transition has completed.\r\n     *\r\n     * This default implementation uses a CSS class and waits for transitionEnd\r\n     * events.\r\n     */\r\n    PageTransitionRegion.prototype.transition_in = function () {\r\n        var aw;\r\n\r\n        this.$elem.removeClass(\"is-PageTransition--transition_loading\");\r\n        this.$elem.removeClass(\"is-PageTransition--transition_out\");\r\n        this.$elem.addClass(\"is-PageTransition--transition_in\");\r\n        aw = new Animations.AnimationWatcher(this.$elem.find(\"[data-pagetransition-backdrop]\"));\r\n\r\n        return aw.promise;\r\n    };\r\n\r\n    /* Transition to the \"done\" state, which should just have the site be\r\n     * plainly visible.\r\n     *\r\n     * Returns a promise which resolves any final transitions have completed.\r\n     * However, most transition effects should not be starting animations here,\r\n     * so it may never resolve.\r\n     *\r\n     * This default implementation removes all CSS classes and waits for\r\n     * transitionEnd events.\r\n     */\r\n    PageTransitionRegion.prototype.transition_done = function () {\r\n        var aw;\r\n\r\n        this.$elem.removeClass(\"is-PageTransition--transition_loading\");\r\n        this.$elem.removeClass(\"is-PageTransition--transition_out\");\r\n        this.$elem.removeClass(\"is-PageTransition--transition_in\");\r\n        aw = new Animations.AnimationWatcher(this.$elem.find(\"[data-pagetransition-backdrop]\"));\r\n\r\n        return aw.promise;\r\n    };\r\n\r\n    /* Given a URL, actually transition the page to a new page.\r\n     *\r\n     * The default method of transitioning the page is to:\r\n     *\r\n     *   1. AJAX the new page in\r\n     *   2. Transition out the current page\r\n     *   3. Call .replace() to get the new page's content in here.\r\n     *   4. Transition in the new page\r\n     *\r\n     * Subclasses of PageTransitionRegion may implement more complicated\r\n     * behavior based on their own individual requirements. Generally, however,\r\n     * you will want to call .replace() to get the content in.\r\n     *\r\n     * If the replacement fails, we will attempt traditional navigation instead\r\n     * of silently or catastrophically failing.\r\n     */\r\n    PageTransitionRegion.prototype.retrieve_document_by_url = function (url, isPopState) {\r\n        var ajaxPromise = new Promise(function (resolve, reject) {\r\n            $.get(url, undefined, resolve, \"html\");\r\n        }),\r\n            theData;\r\n\r\n        return this.transition_out().then(function () {\r\n            console.log(\"Out transition finished\");\r\n            this.transition_loading();\r\n            return ajaxPromise;\r\n        }.bind(this)).then(function (data) {\r\n            this.prepare_to_replace(this.$elem);\r\n            return new Promise(function (resolve, reject) {\r\n                window.setTimeout(resolve.bind(this, data), 1);\r\n            });\r\n        }.bind(this)).then(function (data) {\r\n            var couldReplace;\r\n\r\n            console.log(\"Load finished\");\r\n            theData = data;\r\n\r\n            couldReplace = this.can_replace($(theData));\r\n            if (!couldReplace) {\r\n                window.location.href = url;\r\n                throw new Error(\"Location \" + url + \" does not have transitionable links!\");\r\n            } else if (isPopState !== true) {\r\n                this.replace_state(url);\r\n            }\r\n            \r\n            this.replace($(theData));\r\n            this.replace_head($(theData));\r\n            this.replace_analytics($(theData));\r\n            \r\n            return this.transition_in();\r\n        }.bind(this)).then(function () {\r\n            console.log(\"In transition finished\");\r\n            this.replace_backdrop($(theData));\r\n            this.transition_done();\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Link which resolves to the same origin server. */\r\n    PageTransitionRegion.LINK_INTERNAL = 0;\r\n\r\n    /* Link which resolves to a different origin server. */\r\n    PageTransitionRegion.LINK_EXTERNAL = 1;\r\n\r\n    /* Link which resolves in another window */\r\n    PageTransitionRegion.LINK_POPUP = 2;\r\n\r\n    /* Link which resolves to the same page.\r\n     * Also covers links which do JavaScripty things and should be buttons, but\r\n     * aren't because some developers think their pages will always load with\r\n     * the correct JS and don't consider fallback cases\r\n     */\r\n    PageTransitionRegion.LINK_HASH = 3;\r\n\r\n    /* Event handler for when a link within the region is clicked.\r\n     */\r\n    PageTransitionRegion.prototype.navigation_intent = function (evt) {\r\n        var $target = $(evt.target), $parent_tgt = $target.parents().filter(\"a\"),\r\n            href;\r\n\r\n        if ($target.filter(\"a\").length === 0) {\r\n            $target = $parent_tgt;\r\n        }\r\n\r\n        if ($target.filter(\"a\").length === 0) {\r\n            //Not a link.\r\n            return;\r\n        }\r\n\r\n        href = $target.attr(\"href\");\r\n\r\n        if (this.is_internal_link(href, $target) === PageTransitionRegion.LINK_INTERNAL) {\r\n            //It's AJAX time!\r\n            evt.preventDefault();\r\n            this.retrieve_document_by_url(href);\r\n        }\r\n    };\r\n\r\n    /* Event handler for when the user presses the back button. */\r\n    PageTransitionRegion.prototype.pop_state_intent = function (evt) {\r\n        if (evt.originalEvent.state !== undefined &&\r\n                evt.originalEvent.state !== null &&\r\n                evt.originalEvent.state.transition === true) {\r\n            evt.preventDefault();\r\n            this.retrieve_document_by_url(evt.originalEvent.state.url, true);\r\n        }\r\n    };\r\n\r\n    Behaviors.register_behavior(PageTransitionRegion);\r\n\r\n    module.PageTransitionRegion = PageTransitionRegion;\r\n\r\n    return module;\r\n}));\r\n","/*global window, define, Promise*/\r\n\r\n(function (root, factory) {\r\n    \"use strict\";\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(\"ScrollEffects\", [\"jquery\", \"Behaviors\", \"AtlasPlayer\", \"Animations\"], factory);\r\n    } else {\r\n        root.ScrollEffects = factory(root.jQuery, root.Behaviors, root.AtlasPlayer, root.Animations);\r\n    }\r\n}(this, function ($, Behaviors, AtlasPlayer, Animations) {\r\n    \"use strict\";\r\n\r\n    var module = {};\r\n\r\n    function ScrollEffects(elem) {\r\n        Behaviors.init(ScrollEffects, this, arguments);\r\n\r\n        this.$elem = $(elem);\r\n        this.$scrollCtxt = $(window); //TODO: Allow CSS overflow scrolling\r\n        \r\n        this.scrollHandler = this.on_scroll_intent.bind(this);\r\n\r\n        this.$scrollCtxt.on(\"scroll\", this.scrollHandler);\r\n        \r\n        this.has_load_animation = $(elem).data(\"scrolleffects-loadanimation\") !== undefined;\r\n    }\r\n\r\n    Behaviors.inherit(ScrollEffects, Behaviors.Behavior);\r\n\r\n    ScrollEffects.QUERY = \"[data-scrolleffects]\";\r\n    ScrollEffects.THROTTLE_TIMEOUT = 200;\r\n    \r\n    /* Deinitialize our scroll handler if needed.\r\n     */\r\n    ScrollEffects.prototype.deinitialize = function () {\r\n        this.$scrollCtxt.off(\"scroll\", this.scrollHandler);\r\n    };\r\n    \r\n    /* Return a list of all available scroll effect modes on this bit.\r\n     */\r\n    ScrollEffects.prototype.activation_modes = function () {\r\n        return this.$elem.data(\"scrolleffects\").split(\" \");\r\n    };\r\n\r\n    ScrollEffects.prototype.update_css_classes = function () {\r\n        var activation_modes = this.activation_modes(),\r\n            active = false;\r\n\r\n        if (this.isTopVisible && activation_modes.indexOf(\"top_visible\") !== -1) {\r\n            active = true;\r\n        }\r\n\r\n        if (this.isBottomVisible && activation_modes.indexOf(\"bottom_visible\") !== -1) {\r\n            active = true;\r\n        }\r\n\r\n        if (this.isVisible && activation_modes.indexOf(\"visible\") !== -1) {\r\n            active = true;\r\n        }\r\n\r\n        if (this.onceTopVisible && activation_modes.indexOf(\"top_visible_once\") !== -1) {\r\n            active = true;\r\n        }\r\n\r\n        if (this.onceBottomVisible && activation_modes.indexOf(\"bottom_visible_once\") !== -1) {\r\n            active = true;\r\n        }\r\n\r\n        if (this.onceVisible && activation_modes.indexOf(\"visible_once\") !== -1) {\r\n            active = true;\r\n        }\r\n\r\n        if (active) {\r\n            this.$elem.addClass(\"is-ScrollEffects--active\");\r\n            this.$elem.removeClass(\"is-ScrollEffects--inactive\");\r\n        } else {\r\n            this.$elem.removeClass(\"is-ScrollEffects--active\");\r\n            this.$elem.addClass(\"is-ScrollEffects--inactive\");\r\n        }\r\n        \r\n        if (this.loaded) {\r\n            this.$elem.removeClass(\"is-ScrollEffects--unloaded\");\r\n            this.$elem.addClass(\"is-ScrollEffects--loaded\");\r\n        } else {\r\n            this.$elem.addClass(\"is-ScrollEffects--unloaded\");\r\n            this.$elem.removeClass(\"is-ScrollEffects--loaded\");\r\n        }\r\n    };\r\n\r\n    ScrollEffects.prototype.on_scroll_intent = function () {\r\n        var top = this.$elem.offset().top,\r\n            height = this.$elem.height(),\r\n            bottom = top + height,\r\n            contextOffset = this.$scrollCtxt.offset(),\r\n            contextScrollTop = contextOffset !== undefined\r\n                                ? contextOffset.top + this.$scrollCtxt.scrollTop()\r\n                                : this.$scrollCtxt.scrollTop(),\r\n            contextHeight = this.$scrollCtxt.height(),\r\n            contextScrollBottom = contextScrollTop + contextHeight;\r\n\r\n        this.isTopVisible = contextScrollTop <= top && top <= contextScrollBottom;\r\n        this.isBottomVisible = contextScrollTop <= bottom && bottom <= contextScrollBottom;\r\n        this.isVisible = this.isTopVisible || this.isBottomVisible\r\n            || (top <= contextScrollTop && contextScrollTop <= bottom)\r\n            || (top <= contextScrollBottom && contextScrollBottom <= bottom);\r\n\r\n        this.onceTopVisible = this.onceTopVisible || this.isTopVisible;\r\n        this.onceBottomVisible = this.onceBottomVisible || this.isBottomVisible;\r\n        this.onceVisible = this.onceVisible || this.isVisible;\r\n\r\n        this.top = top;\r\n        this.bottom = bottom;\r\n        this.contextScrollTop = contextScrollTop;\r\n        this.contextScrollBottom = contextScrollBottom;\r\n\r\n        this.update_css_classes();\r\n    };\r\n\r\n    Behaviors.register_behavior(ScrollEffects);\r\n\r\n    function ScrollAlax() {\r\n        Behaviors.init(ScrollAlax, this, arguments);\r\n\r\n        this.$layers = this.$elem.find(\"li\");\r\n        this.$atlasplayers = this.$elem.find(AtlasPlayer.AtlasPlayer.QUERY);\r\n        this.atlasplayers = AtlasPlayer.AtlasPlayer.find_markup(this.$atlasplayers);\r\n        \r\n        this.depth = this.$elem.height() * -0.5;\r\n\r\n        if (this.$elem.data('scrollalax-depthrange') === 'outside') {\r\n            this.anim_scale = 1;\r\n        } else {\r\n            this.anim_scale = -1;\r\n        }\r\n\r\n        this.weights = this.weight_layers(this.$layers);\r\n\r\n        this.on_scroll_intent();\r\n        \r\n        this.loaded = false;\r\n        this.minimum_load_time = this.$elem.data(\"scrollalax-loadmin\");\r\n        this.load().then(this.on_loaded.bind(this));\r\n        \r\n        this.load_animation_playing = this.has_load_animation;\r\n        \r\n        if (this.has_load_animation) {\r\n            this.load_animation_watcher = new Animations.AnimationWatcher(this.$elem);\r\n            this.load_animation_watcher.promise.then(this.on_load_animation_complete.bind(this));\r\n        } else {\r\n            this.on_load_animation_complete();\r\n        }\r\n    }\r\n\r\n    Behaviors.inherit(ScrollAlax, ScrollEffects);\r\n\r\n    ScrollAlax.QUERY = \"[data-scrollalax]\";\r\n\r\n    /* Determine the weights of each layer on the parallax group. */\r\n    ScrollAlax.prototype.weight_layers = function ($layers) {\r\n        var min = Infinity, max = -Infinity, w = [];\r\n\r\n        $layers.each(function (index, elem) {\r\n            var depth = $(elem).data(\"scrollalax-depth\");\r\n\r\n            if (min > depth) {\r\n                min = depth;\r\n            }\r\n\r\n            if (max < depth) {\r\n                max = depth;\r\n            }\r\n        }.bind(this));\r\n\r\n        $layers.each(function (index, elem) {\r\n            var depth = $(elem).data(\"scrollalax-depth\");\r\n\r\n            if (this.anim_scale === -1) {\r\n                w.push(-1 + (depth - min) / (max - min));\r\n            } else {\r\n                w.push((depth - min) / (max - min));\r\n            }\r\n        }.bind(this));\r\n\r\n        return w;\r\n    };\r\n\r\n    /* Calculate X or Y positions of a layer. */\r\n    ScrollAlax.prototype.apply_transform_css = function (style, index, xPct, yPct) {\r\n        var pct_Xdrag = this.weights[index] * xPct * this.anim_scale,\r\n            pct_Ydrag = this.weights[index] * yPct * this.anim_scale,\r\n            xDisp = this.depth * pct_Xdrag * this.anim_scale,\r\n            yDisp = this.depth * pct_Ydrag * this.anim_scale;\r\n\r\n        //style.left = xDisp + \"px\";\r\n        //style.top = yDisp + \"px\";\r\n\r\n        style.transform = \"translate3D(\" + xDisp + \"px, \" + yDisp + \"px, 0px)\";\r\n    };\r\n\r\n    /* Update the scroll animation. */\r\n    ScrollAlax.prototype.update_css_classes = function (evt) {\r\n        var pct_down = Math.max(Math.min((this.contextScrollTop - this.top) / this.$elem.height(), 1.0), 0.0);\r\n        \r\n        this.$layers.each(function (index, layer_elem) {\r\n            var $layer_elem = $(layer_elem);\r\n\r\n            this.apply_transform_css(layer_elem.style, index, 0, pct_down);\r\n        }.bind(this));\r\n        \r\n        if (this.loaded && !this.load_animation_playing) {\r\n            this.$elem.removeClass(\"is-ScrollEffects--unloaded\");\r\n            this.$elem.addClass(\"is-ScrollEffects--loaded\");\r\n        } else {\r\n            this.$elem.addClass(\"is-ScrollEffects--unloaded\");\r\n            this.$elem.removeClass(\"is-ScrollEffects--loaded\");\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Ensure all layers have their images loaded.\r\n     * \r\n     * Returns a promise that resolves when all images in all layers have\r\n     * loaded.\r\n     */\r\n    ScrollAlax.prototype.load = function () {\r\n        var promises = [];\r\n        \r\n        if (this.minimum_load_time > 0) {\r\n            promises.push(new Promise (function (resolve) {\r\n                window.setTimeout(resolve, this.minimum_load_time * 1000);\r\n            }.bind(this)));\r\n        }\r\n        \r\n        this.$layers.each(function (index, layer_elem) {\r\n            var $backgrounds = $(layer_elem).find(\"[style*='background-image']\"),\r\n                $images = $(layer_elem).find(\"img[src]\");\r\n            \r\n            $backgrounds.each(function (index, bgelem) {\r\n                var src = $(bgelem).css(\"background-image\").slice(5, -2);\r\n                \r\n                promises.push(new Promise(function (resolve) {\r\n                    $(\"<img/>\").attr(\"src\", src).on('load', function () {\r\n                        $(this).remove();\r\n                        resolve();\r\n                    }).on('error', function () {\r\n                        //This should be reject, but some browsers will\r\n                        //spuriously fire error if the image was cached instead\r\n                        //of firing load. This is a workaround.\r\n                        $(this).remove();\r\n                        resolve();\r\n                    });\r\n                }.bind(this)));\r\n            }.bind(this));\r\n            \r\n            $images.each(function (index, imgelem) {\r\n                var src = $(imgelem).attr(\"src\");\r\n                \r\n                promises.push(new Promise(function (resolve) {\r\n                    $(\"<img/>\").attr(\"src\", src).on('load', function () {\r\n                        $(this).remove();\r\n                        resolve();\r\n                    }).on('error', function () {\r\n                        //This should be reject, but some browsers will\r\n                        //spuriously fire error if the image was cached instead\r\n                        //of firing load. This is a workaround.\r\n                        $(this).remove();\r\n                        resolve();\r\n                    });\r\n                }.bind(this)));\r\n            }.bind(this));\r\n        });\r\n        \r\n        return Promise.all(promises);\r\n    };\r\n    \r\n    ScrollAlax.prototype.on_loaded = function () {\r\n        var i = 0;\r\n\r\n        for (i = 0; i < this.atlasplayers.length; i += 1) {\r\n            this.atlasplayers[i].seek(0);\r\n            this.atlasplayers[i].stop();\r\n        }\r\n        \r\n        this.loaded = true;\r\n        this.update_css_classes();\r\n        \r\n        if (!this.load_animation_playing) {\r\n            if (this.has_load_animation) {\r\n                this.unload_animation_watcher = new Animations.AnimationWatcher(this.$elem);\r\n                this.unload_animation_watcher.promise.then(this.on_unload_animation_complete.bind(this));\r\n            } else {\r\n                this.on_unload_animation_complete();\r\n            }\r\n        }\r\n    };\r\n    \r\n    ScrollAlax.prototype.on_load_animation_complete = function () {\r\n        this.load_animation_playing = false;\r\n        this.update_css_classes();\r\n        \r\n        if (this.loaded) {\r\n            if (this.has_load_animation) {\r\n                this.unload_animation_watcher = new Animations.AnimationWatcher(this.$elem);\r\n                this.unload_animation_watcher.promise.then(this.on_unload_animation_complete.bind(this));\r\n            } else {\r\n                this.on_unload_animation_complete();\r\n            }\r\n        }\r\n    };\r\n    \r\n    ScrollAlax.prototype.on_unload_animation_complete = function () {\r\n        var i = 0;\r\n\r\n        for (i = 0; i < this.atlasplayers.length; i += 1) {\r\n            this.atlasplayers[i].seek(0);\r\n            this.atlasplayers[i].play();\r\n        }\r\n    };\r\n\r\n    Behaviors.register_behavior(ScrollAlax);\r\n\r\n    module.ScrollEffects = ScrollEffects;\r\n    module.ScrollAlax = ScrollAlax;\r\n\r\n    return module;\r\n}));\r\n","(function (root, factory) {\r\n    \"use strict\";\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(\"accountslidein\", [\"jquery\", \"betteroffcanvas\"], factory);\r\n    } else {\r\n        // Browser globals\r\n        root.accountslidein = factory(root.jQuery, root.betteroffcanvas);\r\n    }\r\n}(this, function ($, betteroffcanvas) {\r\n    \"use strict\";\r\n    \"feel good\";\r\n\r\n    $('.Account_slide-login--button').click(function(){\r\n        $(this).hide();\r\n        $('.Account_slide-form--password').removeClass('Account_slide-form--visible')\r\n        $('.Account_slide-form--login').addClass('Account_slide-form--visible');\r\n        return false;\r\n    });\r\n\r\n    $('.Account_slide-password_recovery').click(function(){\r\n        $('.Account_slide-login--button').show();\r\n        $('.Account_slide-form--login').removeClass('Account_slide-form--visible');\r\n        $('.Account_slide-form--password').addClass('Account_slide-form--visible');\r\n        return false;\r\n    });\r\n\r\n\r\n    $('.Account_slide-close').click(function(){\r\n        betteroffcanvas.dismissOffcanvas($('#SiteHeader-accounts'));\r\n    });\r\n}));\r\n","(function (root, factory) {\r\n    \"use strict\";\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(\"siteheader\", [\"jquery\", \"betteroffcanvas\"], factory);\r\n    } else {\r\n        // Browser globals\r\n        root.siteheader = factory(root.jQuery, root.betteroffcanvas);\r\n    }\r\n}(this, function ($, betteroffcanvas, ajaxCart, Handlebars) {\r\n    \"use strict\";\r\n    \"feel good\";\r\n\r\n    function update_scroll() {\r\n        var scrollTop = $(window).scrollTop(),\r\n            $SiteHeader = $(\"[data-siteheader='siteheader']\");\r\n\r\n        if (scrollTop === 0) {\r\n            $SiteHeader.addClass(\"is-SiteHeader--at_top\");\r\n            $SiteHeader.removeClass(\"is-SiteHeader--scrolled\");\r\n        } else {\r\n            $SiteHeader.removeClass(\"is-SiteHeader--at_top\");\r\n            $SiteHeader.addClass(\"is-SiteHeader--scrolled\");\r\n        }\r\n    };\r\n\r\n    $(window).on(\"scroll\", update_scroll);\r\n\r\n    update_scroll();\r\n}));\r\n","(function (root, factory) {\r\n    \"use strict\";\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(\"StaffGrid\", [\"jquery\", \"Behaviors\"], factory);\r\n    } else {\r\n        root.StaffGrid = factory(root.jQuery, root.Behaviors);\r\n    }\r\n}(this, function ($, Behaviors) {\r\n    \"use strict\";\r\n\r\n    var module = {};\r\n    \r\n    function StaffGridSlider() {\r\n        Behaviors.init(StaffGridSlider, this, arguments);\r\n        \r\n        this.$elem.slick({\r\n            prevArrow: this.$elem.find('[data-staffgrid-prev]'),\r\n            nextArrow: this.$elem.find('[data-staffgrid-next]')\r\n        });\r\n    }\r\n    \r\n    Behaviors.inherit(StaffGridSlider, Behaviors.Behavior);\r\n    \r\n    StaffGridSlider.QUERY = \"[data-staffgrid-slider]\";\r\n    \r\n    StaffGridSlider.prototype.goto = function (id, animate) {\r\n        this.$elem.slick('slickGoTo', id, animate);\r\n    }\r\n    \r\n    function StaffGridModal() {\r\n        Behaviors.init(StaffGridModal, this, arguments);\r\n        \r\n        this.slider = StaffGridSlider.locate(this.$elem.find('[data-staffgrid-slider]'));\r\n        this.$elem.on(\"offcanvas-open\", this.modal_reveal_intent.bind(this));\r\n    }\r\n    \r\n    Behaviors.inherit(StaffGridModal, Behaviors.Behavior);\r\n    \r\n    StaffGridModal.QUERY = \"[data-staffgrid-modal]\";\r\n    \r\n    StaffGridModal.prototype.modal_reveal_intent = function (evt) {\r\n        var slideIndex = $(evt.originalEvent.toggle).data('staffgrid-slider-index');\r\n        \r\n        this.slider.goto(slideIndex, true);\r\n    };\r\n    \r\n    Behaviors.register_behavior(StaffGridModal);\r\n    Behaviors.register_behavior(StaffGridSlider);\r\n    \r\n    module.StaffGridModal = StaffGridModal;\r\n    module.StaffGridSlider = StaffGridSlider;\r\n    \r\n    return module;\r\n}));\r\n","/*global define, console, document, window*/\r\n(function (root, factory) {\r\n    \"use strict\";\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(\"TabbedContent\", [\"jquery\", \"Behaviors\"], factory);\r\n    } else {\r\n        root.TabbedContent = factory(root.jQuery, root.Behaviors);\r\n    }\r\n}(this, function ($, Behaviors) {\r\n    \"use strict\";\r\n\r\n    var module = {};\r\n\r\n    function $do(that, target) {\r\n        return function () {\r\n            target.apply(that, arguments);\r\n        };\r\n    }\r\n\r\n    function TabbedContentRegion(elem) {\r\n        Behaviors.init(TabbedContentRegion, this, arguments);\r\n\r\n        this.$elem = $(elem);\r\n        this.id = this.$elem.attr(\"id\");\r\n        this.active = this.$elem.data(\"tabbedcontent-region-active\") !== undefined;\r\n\r\n        this.links = [];\r\n\r\n        this.reflect_status();\r\n    }\r\n\r\n    Behaviors.inherit(TabbedContentRegion, Behaviors.Behavior);\r\n\r\n    TabbedContentRegion.QUERY = \"[data-tabbedcontent-region]\";\r\n\r\n    TabbedContentRegion.prototype.reflect_status = function (status) {\r\n        var i;\r\n\r\n        if (status === undefined) {\r\n            status = this.active;\r\n        }\r\n\r\n        if (status) {\r\n            this.$elem.addClass(\"is-TabbedContent--active\");\r\n            this.$elem.removeClass(\"is-TabbedContent--inactive\");\r\n        } else {\r\n            this.$elem.removeClass(\"is-TabbedContent--active\");\r\n            this.$elem.addClass(\"is-TabbedContent--inactive\");\r\n        }\r\n\r\n        for (i = 0; i < this.links.length; i += 1) {\r\n            if (status) {\r\n                this.links[i].addClass(\"is-TabbedContent--target_active\");\r\n                this.links[i].removeClass(\"is-TabbedContent--target_inactive\");\r\n            } else {\r\n                this.links[i].removeClass(\"is-TabbedContent--target_active\");\r\n                this.links[i].addClass(\"is-TabbedContent--target_inactive\");\r\n            }\r\n        }\r\n    };\r\n\r\n    TabbedContentRegion.prototype.add_incoming_link = function ($li) {\r\n        this.links.push($li);\r\n    };\r\n\r\n    function TabbedContentSet(elem) {\r\n        Behaviors.init(TabbedContentSet, this, arguments);\r\n\r\n        this.$elem = $(elem);\r\n\r\n        this.tabset_name = this.$elem.attr(\"data-tabbedcontent-set\");\r\n        if (this.tabset_name === undefined) {\r\n            this.tabset_name = this.$elem.attr(\"id\");\r\n        }\r\n\r\n        this.tab_members = {};\r\n        this.list = [];\r\n\r\n        this.find_links();\r\n    }\r\n\r\n    Behaviors.inherit(TabbedContentSet, Behaviors.Behavior);\r\n\r\n    TabbedContentSet.QUERY = \"[data-tabbedcontent-set]\";\r\n\r\n    TabbedContentSet.prototype.new_tab = function (id) {\r\n        var $elem = $(\"#\" + id);\r\n\r\n        if ($elem.length === 0) {\r\n            return false;\r\n        }\r\n\r\n        if (this.tab_members[id] === undefined) {\r\n            this.tab_members[id] = {\r\n                \"toggles\": [],\r\n                \"content\": TabbedContentRegion.locate($elem)\r\n            };\r\n        }\r\n\r\n        return true;\r\n    };\r\n\r\n    TabbedContentSet.prototype.set_active_tab = function (id) {\r\n        var k;\r\n\r\n        for (k in this.tab_members) {\r\n            if (this.tab_members.hasOwnProperty(k)) {\r\n                this.tab_members[k].content.active = k === id;\r\n                this.tab_members[k].content.reflect_status();\r\n            }\r\n        }\r\n    };\r\n\r\n    TabbedContentSet.prototype.navigate_tab_intent = function (id, evt) {\r\n        this.set_active_tab(id);\r\n\r\n        if (evt) {\r\n            evt.preventDefault();\r\n        }\r\n    };\r\n\r\n    TabbedContentSet.prototype.import_list_item = function (li) {\r\n        var $li = $(li),\r\n            $link = $li.find(\"a\"),\r\n            href = $link.attr(\"href\"),\r\n            id;\r\n\r\n        if ($link.length === 0) {\r\n            return;\r\n        }\r\n\r\n        if (href.indexOf(\"#\") !== -1) {\r\n            id = href.slice(1);\r\n        }\r\n\r\n        if (id === undefined) {\r\n            return;\r\n        }\r\n\r\n        if (this.tab_members[id] === undefined && !this.new_tab(id)) {\r\n            return;\r\n        }\r\n\r\n        this.list.push({\r\n            \"li\": $li,\r\n            \"id\": id\r\n        });\r\n        this.tab_members[id].content.add_incoming_link($li);\r\n        this.tab_members[id].content.reflect_status();\r\n        $link.on(\"touchend click\", this.navigate_tab_intent.bind(this, id));\r\n    };\r\n\r\n    TabbedContentSet.prototype.find_links = function () {\r\n        var that = this;\r\n\r\n        this.$elem.find(\"li\").each(function (index, elem) {\r\n            return that.import_list_item(elem);\r\n        });\r\n    };\r\n\r\n    Behaviors.register_behavior(TabbedContentSet);\r\n\r\n    module.TabbedContentSet = TabbedContentSet;\r\n\r\n    return module;\r\n}));\r\n","/*jslint continue: true, es5: true*/\r\n/*global detectZoom, console, jQuery, define, Float32Array, Uint16Array*/\r\n(function (root, factory) {\r\n    \"use strict\";\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(\"UTM\", [\"jquery\", \"Behaviors\"], factory);\r\n    } else {\r\n        root.UTM = factory(root.jQuery, root.Behaviors);\r\n    }\r\n}(this, function ($, Behaviors) {\r\n    \"use strict\";\r\n    var module = {},\r\n        utm_variables = {},\r\n        wanted_vars = [\"utm_source\", \"utm_medium\", \"utm_campaign\", \"utm_term\", \"utm_content\"];\r\n    \r\n    function utm_preserve_enabled() {\r\n        return $(\"body\").data(\"utmpreserve-preserve\") !== false;\r\n    }\r\n    \r\n    function utm_forminject_enabled() {\r\n        return $(\"body\").data(\"utmpreserve-forminject\") !== false;\r\n    }\r\n\r\n    function getQueryVariable(variable) {\r\n        var query = window.location.search.substring(1);\r\n        var vars = query.split('&');\r\n        for (var i = 0; i < vars.length; i++) {\r\n            var pair = vars[i].split('=');\r\n            if (decodeURIComponent(pair[0]) == variable) {\r\n                return decodeURIComponent(pair[1]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /* Given a query string, return an object whose keys are matched UTM vars.\r\n     */\r\n    function look_for_utm_variables() {\r\n        var new_utm_variables = {}, i;\r\n\r\n        for (i = 0; i < wanted_vars.length; i += 1) {\r\n            new_utm_variables[wanted_vars[i]] = getQueryVariable(wanted_vars[i]);\r\n        }\r\n\r\n        return new_utm_variables;\r\n    }\r\n\r\n    function do_utm_replace($context) {\r\n        if (!utm_preserve_enabled()) {\r\n            console.log(\"UTM preserve is disabled.\");\r\n            return;\r\n        }\r\n        \r\n        utm_variables = look_for_utm_variables();\r\n\r\n        $context.find(\"a[href]\").each(function (index, elem) {\r\n            var k, $elem = $(elem),\r\n                old_href = $elem.attr(\"href\");\r\n\r\n            for (k in utm_variables) {\r\n                if (utm_variables.hasOwnProperty(k) && utm_variables[k] !== undefined) {\r\n                    if (old_href.indexOf(\"?\") !== -1) {\r\n                        old_href = old_href + \"&\" + k + \"=\" + utm_variables[k];\r\n                    } else {\r\n                        old_href = old_href + \"?\" + k + \"=\" + utm_variables[k];\r\n                    }\r\n                }\r\n            }\r\n\r\n            $elem.attr(\"href\", old_href);\r\n        })\r\n    }\r\n    \r\n    function do_gform_insertion(evt, form_id, current_page) {\r\n        var $form = $(\"#gform_\" + form_id), i, k,\r\n            old_action = $form.attr(\"action\");\r\n        \r\n        if (!utm_forminject_enabled()) {\r\n            console.log(\"UTM form injection is disabled.\");\r\n            return;\r\n        }\r\n        \r\n        utm_variables = look_for_utm_variables();\r\n        \r\n        //Remove any existing query vars.\r\n        //TODO: should we bother preserving old vars that aren't UTMs?\r\n        old_action = old_action.split(\"?\")[0];\r\n        \r\n        //Add UTM variables as seen by the client.\r\n        for (k in utm_variables) {\r\n            if (utm_variables.hasOwnProperty(k) && utm_variables[k] !== undefined) {\r\n                if (old_action.indexOf(\"?\") !== -1) {\r\n                    old_action = old_action + \"&\" + k + \"=\" + utm_variables[k];\r\n                } else {\r\n                    old_action = old_action + \"?\" + k + \"=\" + utm_variables[k];\r\n                }\r\n            }\r\n        }\r\n        \r\n        $form.attr(\"action\", old_action);\r\n        \r\n        //We can't auto-insert UTM variables into hidden fields, so instead we\r\n        //replace by hidden values.\r\n        $form.find(\"input[type='hidden']\").each(function (index, ielem) {\r\n            var $ielem = $(ielem), old_value = $ielem.attr(\"value\"), new_key;\r\n\r\n            if (old_value.startsWith(\"replace_param[\") && old_value.endsWith(\"]\")) {\r\n                new_key = old_value.split(\"[\")[1].split(\"]\")[0];\r\n                $ielem.val(utm_variables[new_key]);\r\n            }\r\n        })\r\n    }\r\n    \r\n    $(document).bind(\"gform_post_render\", do_gform_insertion);\r\n    \r\n    Behaviors.register_content_listener(do_utm_replace);\r\n    \r\n    module.do_utm_replace = do_utm_replace;\r\n    module.look_for_utm_variables = look_for_utm_variables;\r\n    module.getQueryVariable = getQueryVariable;\r\n    \r\n    return module;\r\n}));\r\n","/*global define, window, document, Promise*/\r\n(function (root, factory) {\r\n    \"use strict\";\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(\"VideoPlayer\", [\"jquery\", \"Behaviors\"], factory);\r\n    } else {\r\n        root.VideoPlayer = factory(root.jQuery, root.Behaviors);\r\n    }\r\n}(this, function ($, Behaviors) {\r\n    \"use strict\";\r\n\r\n    var module = {};\r\n\r\n    function VideoPlayer(elem) {\r\n        Behaviors.init(VideoPlayer, this, arguments);\r\n\r\n        this.$elem = $(elem);\r\n        \r\n        if (this.ready) {\r\n            this.ready().then(this.locate_children.bind(this));\r\n        } else {\r\n            this.locate_children();\r\n        }\r\n    }\r\n\r\n    Behaviors.inherit(VideoPlayer, Behaviors.Behavior);\r\n\r\n    /* Returns a promise which resolves when the player is ready to accept\r\n     * other API calls.\r\n     *\r\n     * Calling those other API calls outside of a then() block from the promise\r\n     * returned by this function is a good way to have a bad time.\r\n     *\r\n     * By default, the video player is always ready.\r\n     */\r\n    VideoPlayer.prototype.ready = function () {\r\n        return new Promise(function (resolve, reject) {\r\n            resolve();\r\n        });\r\n    };\r\n\r\n    //No QUERY is defined for the base VideoPlayer class as it is not intended\r\n    //to be locatable. Derived classes should locate their VideoPlayer subclass\r\n    //once it's attendant APIs have been loaded.\r\n    //VideoPlayer.QUERY = \"\";\r\n\r\n    VideoPlayer.prototype.locate_children = function () {\r\n        var $parent_modal, $parent_hover;\r\n        \r\n        this.playpause = VideoPlayer_playpause.find_markup(this.$elem, this);\r\n        this.scrubbers = VideoPlayer_scrubber.find_markup(this.$elem, this);\r\n        this.mute_btns = VideoPlayer_mute.find_markup(this.$elem, this);\r\n        \r\n        //This is an example of how to locate upwards\r\n        $parent_modal = this.$elem.parents().filter(VideoPlayer_offcanvas.QUERY);\r\n        \r\n        if ($parent_modal.length > 0) {\r\n            this.modal = VideoPlayer_offcanvas.locate($parent_modal[0], this);\r\n        }\r\n        \r\n        $parent_hover = this.$elem.parents().filter(VideoPlayer_hover.QUERY);\r\n        \r\n        if ($parent_hover.length > 0) {\r\n            this.hover = VideoPlayer_hover.locate($parent_hover[0], this);\r\n        }\r\n        \r\n        //Now see if we're supposed to autoplay...\r\n        if (this.$elem.data(\"videoplayer-autoplay\") !== undefined) {\r\n            this.play();\r\n        }\r\n        \r\n        if (this.$elem.data(\"videoplayer-loop\") !== undefined) {\r\n            this.add_statechange_listener(this.loopcheck.bind(this));\r\n        }\r\n    };\r\n    \r\n    VideoPlayer.prototype.loopcheck = function () {\r\n        Promise.all([this.is_paused(), this.get_current_time(), this.get_duration()]).then(function (values) {\r\n            var is_paused = values[0];\r\n            var current_time = values[1];\r\n            var duration = values[2];\r\n            \r\n            if (current_time === duration) {\r\n                this.seek(0);\r\n                this.play();\r\n            }\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Determine if the video player is active.\r\n     *\r\n     * Most keyboard events only process on the active video's controls, not\r\n     * other videos. This ensures that you can have multiple VideoPlayers\r\n     * running without them all being controlled by the same limited set of\r\n     * keyboard shortcuts.\r\n     *\r\n     * A video player is active if any of the following apply:\r\n     *\r\n     *  - The video is marked primary with [data-videoplayer-primary].\r\n     *  - The video is currently playing.\r\n     *  - The VideoPlayer element or one of it's children has keyboard focus.\r\n     * \r\n     * This function returns a promise which resolves to the return value.\r\n     */\r\n    VideoPlayer.prototype.is_active = function () {\r\n        return this.is_paused(function (is_paused) {\r\n            if (this.$elem.data(\"videoplayer-primary\") !== undefined) {\r\n                return true;\r\n            }\r\n\r\n            if (!is_paused) {\r\n                return true;\r\n            }\r\n\r\n            if (this.$elem.find(\":focus\").length > 0) {\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Serves as a play/pause button for a connected VideoPlayer.\r\n     */\r\n    function VideoPlayer_playpause(elem, parent) {\r\n        var that = this;\r\n\r\n        Behaviors.init(VideoPlayer_playpause, that, arguments);\r\n\r\n        that.parent = parent;\r\n\r\n        that.parent.ready().then(function () {\r\n            that.parent.add_statechange_listener(that.on_statechange.bind(that));\r\n            that.$elem.on(\"click touchend\", that.on_play_intent.bind(that));\r\n\r\n            that.update_css_classes();\r\n        });\r\n    }\r\n\r\n    Behaviors.inherit(VideoPlayer_playpause, Behaviors.Behavior);\r\n\r\n    VideoPlayer_playpause.QUERY = \"[data-videoplayer-playpause]\";\r\n\r\n    VideoPlayer_playpause.prototype.update_css_classes = function () {\r\n        this.parent.is_paused().then(function (is_paused) {\r\n            if (is_paused) {\r\n                this.$elem.addClass(\"is-VideoPlayer--paused\");\r\n                this.$elem.removeClass(\"is-VideoPlayer--playing\");\r\n            } else {\r\n                this.$elem.removeClass(\"is-VideoPlayer--paused\");\r\n                this.$elem.addClass(\"is-VideoPlayer--playing\");\r\n            }\r\n        }.bind(this));\r\n    };\r\n\r\n    VideoPlayer_playpause.prototype.toggle_playback = function () {\r\n        this.parent.is_paused().then(function (is_paused) {\r\n            if (is_paused) {\r\n                this.parent.play();\r\n            } else {\r\n                this.parent.pause();\r\n            }\r\n        }.bind(this));\r\n    };\r\n\r\n    VideoPlayer_playpause.prototype.on_statechange = function () {\r\n        this.update_css_classes();\r\n    };\r\n\r\n    VideoPlayer_playpause.prototype.on_play_intent = function () {\r\n        this.toggle_playback();\r\n    };\r\n\r\n    /* Allows a video modal to be started and stopped as the modal is opened\r\n     * and closed.\r\n     * \r\n     * Place this on the Offcanvas element that gets dismissed and/or opened.\r\n     */\r\n    function VideoPlayer_offcanvas(elem, parent) {\r\n        var that = this;\r\n\r\n        Behaviors.init(VideoPlayer_offcanvas, that, arguments);\r\n\r\n        that.parent = parent;\r\n\r\n        that.$elem.on(\"offcanvas-open\", that.on_open_intent.bind(that));\r\n        that.$elem.on(\"offcanvas-dismiss\", that.on_dismiss_intent.bind(that));\r\n    }\r\n\r\n    Behaviors.inherit(VideoPlayer_offcanvas, Behaviors.Behavior);\r\n\r\n    VideoPlayer_offcanvas.QUERY = \"[data-videoplayer-offcanvas]\";\r\n\r\n    VideoPlayer_offcanvas.prototype.on_open_intent = function () {\r\n        var that = this;\r\n\r\n        that.parent.is_paused().then(function (is_paused) {\r\n            if (is_paused) {\r\n                that.parent.play();\r\n            }\r\n        });\r\n    };\r\n\r\n    VideoPlayer_offcanvas.prototype.on_dismiss_intent = function () {\r\n        var that = this;\r\n\r\n        that.parent.is_paused().then(function (is_paused) {\r\n            if (!is_paused) {\r\n                that.parent.pause();\r\n            }\r\n        });\r\n    };\r\n\r\n    /* Allows a video modal to be started and stopped based on the hover state\r\n     * of an element. Won't work on mobile.\r\n     * \r\n     * Place this on the element that gets hovered.\r\n     */\r\n    function VideoPlayer_hover(elem, parent) {\r\n        var that = this;\r\n\r\n        Behaviors.init(VideoPlayer_hover, that, arguments);\r\n\r\n        that.parent = parent;\r\n\r\n        that.$elem.on(\"mouseenter\", that.on_hover_intent.bind(that));\r\n        that.$elem.on(\"mouseleave\", that.on_leave_intent.bind(that));\r\n    }\r\n\r\n    Behaviors.inherit(VideoPlayer_hover, Behaviors.Behavior);\r\n\r\n    VideoPlayer_hover.QUERY = \"[data-videoplayer-hover]\";\r\n\r\n    VideoPlayer_hover.prototype.on_hover_intent = function () {\r\n        var that = this;\r\n\r\n        that.parent.is_paused().then(function (is_paused) {\r\n            if (is_paused) {\r\n                that.parent.play();\r\n            }\r\n        });\r\n    };\r\n\r\n    VideoPlayer_hover.prototype.on_leave_intent = function () {\r\n        var that = this;\r\n\r\n        that.parent.is_paused().then(function (is_paused) {\r\n            if (!is_paused) {\r\n                that.parent.pause();\r\n            }\r\n        });\r\n    };\r\n\r\n    /* Serves as a scrub bar for a connected VideoPlayer.\r\n     *\r\n     * A Scrubber contains additional elements inside of it that do not have an\r\n     * associated behavior:\r\n     *\r\n     *  - [data-videoplayer-scrubberfill]: The filled range of the scrubber.\r\n     *  - [data-videoplayer-scrubberknob]: A knob which indicates the current\r\n     *     scrubber point.\r\n     */\r\n    function VideoPlayer_scrubber(elem, parent) {\r\n        var err, that = this;\r\n\r\n        Behaviors.init(VideoPlayer_scrubber, that, arguments);\r\n\r\n        that.parent = parent;\r\n\r\n        //EVENT STATE VARIABLES\r\n        that.is_dragging = false;\r\n        that.in_debounce = false;\r\n\r\n        //OPTIONAL COMPONENTS\r\n        that.$scrubfill = that.$elem.find(\"[data-videoplayer-scrubberfill]\");\r\n        that.$scrubknob = that.$elem.find(\"[data-videoplayer-scrubberknob]\");\r\n\r\n        that.parent.ready().then(function () {\r\n            //EVENT HANDLERS\r\n            that.$elem.on(\"mousedown touchstart\", that.on_dragstart_intent.bind(that));\r\n            that.$elem.on(\"mousemove touchmove\", that.on_drag_intent.bind(that));\r\n            $(document).on(\"mouseup touchend touchcancel\", that.on_dragend_intent.bind(that));\r\n            $(document).on(\"keydown\", that.on_keyboard_nav.bind(that));\r\n\r\n            err = that.parent.add_timeupdate_listener(that.on_timeupdate.bind(that));\r\n            if (err === false) {\r\n                window.setInterval(that.on_timeupdate.bind(that), 1000);\r\n            }\r\n        });\r\n\r\n        that.update_scrubber();\r\n    }\r\n\r\n    Behaviors.inherit(VideoPlayer_scrubber, Behaviors.Behavior);\r\n\r\n    VideoPlayer_scrubber.QUERY = \"[data-videoplayer-scrubber]\";\r\n\r\n    VideoPlayer_scrubber.prototype.css_percent = function (value) {\r\n        return (value * 100) + \"%\";\r\n    };\r\n\r\n    /* This defines the dynamic CSS properties that are applied to scrubber\r\n     * elements.\r\n     *\r\n     * Specifically, fills get a width equal to the current play percentage;\r\n     * knobs get a left position equal to the current play percentage.\r\n     *\r\n     * This assumes knobs and fills get positioned relative to the scrubber.\r\n     */\r\n    VideoPlayer_scrubber.prototype.update_scrubber = function () {\r\n        var that = this, currentTime, ratio;\r\n        \r\n        that.parent.ready().then(function () {\r\n            return that.parent.get_current_time();\r\n        }.bind(this)).then(function (newCurrentTime) {\r\n            currentTime = newCurrentTime;\r\n            return that.parent.get_duration();\r\n        }.bind(this)).then(function (duration) {\r\n            ratio = 0;\r\n\r\n            if (!isFinite(duration)) {\r\n                //Livestreams always show as complete.\r\n                ratio = 1;\r\n            } else if (!isNaN(duration)) {\r\n                ratio = currentTime / duration;\r\n            }\r\n\r\n            that.$scrubfill.css(\"width\", that.css_percent(ratio));\r\n            that.$scrubknob.css(\"left\", that.css_percent(ratio));\r\n        });\r\n    };\r\n\r\n    /* Given an X coordinate, calculate the corresponding video seek time and\r\n     * return it.\r\n     *\r\n     * Input is in page co-ordinates. Input is scaled to output based on the\r\n     * CSS width and position of the scrubber. Output is bounded within the\r\n     * closed range [0, 1].\r\n     * \r\n     * Returns a promise with the correct seek time.\r\n     */\r\n    VideoPlayer_scrubber.prototype.mouse_to_ctime = function (page_x) {\r\n        return this.parent.get_duration().then(function (duration) {\r\n            return (page_x - this.$elem.offset().left) / this.$elem.width() * duration;\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Seek the parent player, but only if the proposed new time is valid.\r\n     */\r\n    VideoPlayer_scrubber.prototype.seek_if_valid = function (newTime, isFinal) {\r\n        if (isNaN(newTime) || !isFinite(newTime)) {\r\n            return;\r\n        }\r\n\r\n        this.parent.seek(newTime, isFinal);\r\n    };\r\n\r\n    // Drag event filtering\r\n\r\n    /* Start a drag operation; configuring the event filtering machinery to\r\n     * only recognize the click or touch that started the event chain.\r\n     */\r\n    VideoPlayer_scrubber.prototype.start_drag = function (evt) {\r\n        this.is_dragging = true;\r\n\r\n        if (evt.changedTouches !== undefined && evt.changedTouches.length > 0) {\r\n            this.drag_touch_id = evt.changedTouches[0].identifier;\r\n            return evt.changedTouches[0].pageX;\r\n        } else {\r\n            this.drag_touch_id = undefined;\r\n            return evt.pageX;\r\n        }\r\n    };\r\n\r\n    /* Retrieves the Page X coordinate from an event, ensuring that the correct\r\n     * finger is tracked across the entire event chain.\r\n     *\r\n     * Events will be ignored, and FALSE returned, if the event type that\r\n     * started the drag does not match the given event; or, if it's a touch\r\n     * event type, it will be ignored if there is no touch matching the current\r\n     * one.\r\n     */\r\n    VideoPlayer_scrubber.prototype.validate_drag = function (evt) {\r\n        var i;\r\n\r\n        if (this.is_dragging) {\r\n            if (this.drag_touch_id !== undefined) {\r\n                if (evt.changedTouches !== undefined) {\r\n                    for (i = 0; i < evt.changedTouches.length; i += 1) {\r\n                        if (evt.changedTouches[i].identifier === this.drag_touch_id) {\r\n                            return evt.changedTouches[i].pageX;\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                if (evt.changedTouches === undefined) {\r\n                    return evt.pageX;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    };\r\n\r\n    /* Retrieves the Page X coordinate from an event and turns off further drag\r\n     * processing.\r\n     *\r\n     * For the same reasons as validate_drag, non-matching events will not\r\n     * cancel drag processing. This function returns FALSE if this event was\r\n     * ignored.\r\n     */\r\n    VideoPlayer_scrubber.prototype.end_drag = function (evt) {\r\n        var px = this.validate_drag(evt);\r\n        if (px === false) {\r\n            return px;\r\n        }\r\n\r\n        this.is_dragging = false;\r\n        this.drag_touch_id = undefined;\r\n\r\n        return px;\r\n    };\r\n\r\n    /* Process a drag event given the incoming Page X.\r\n     *\r\n     * If FALSE is given, indicating an event filtered by validate_drag, this\r\n     * does nothing.\r\n     */\r\n    VideoPlayer_scrubber.prototype.handle_drag = function (pageX, final) {\r\n        var newtime;\r\n\r\n        if (pageX === false) {\r\n            return;\r\n        }\r\n\r\n        return this.mouse_to_ctime(pageX).then(function (newtime) {\r\n            this.seek_if_valid(newtime, final);\r\n            this.update_scrubber();\r\n        }.bind(this));\r\n    };\r\n\r\n    // Event handlers\r\n\r\n    VideoPlayer_scrubber.prototype.on_timeupdate = function () {\r\n        this.update_scrubber();\r\n    };\r\n\r\n    VideoPlayer_scrubber.prototype.on_dragstart_intent = function (evt) {\r\n        this.handle_drag(this.start_drag(evt), false);\r\n    };\r\n\r\n    VideoPlayer_scrubber.prototype.on_drag_intent = function (evt) {\r\n        this.handle_drag(this.validate_drag(evt), false);\r\n    };\r\n\r\n    VideoPlayer_scrubber.prototype.on_dragend_intent = function (evt) {\r\n        this.handle_drag(this.end_drag(evt), true);\r\n    };\r\n\r\n    VideoPlayer_scrubber.prototype.on_keyboard_nav = function (evt) {\r\n        var currentTime;\r\n        \r\n        this.parent.ready().then(function () {\r\n            return this.parent.get_current_time();\r\n        }.bind(this)).then(function (newCurrentTime) {\r\n            currentTime = newCurrentTime;\r\n            return this.parent.is_active();\r\n        }.bind(this)).then(function (is_active) {\r\n            if (!is_active) {\r\n                return;\r\n            }\r\n            \r\n            if (evt.keyCode === 37) { //LEFT\r\n                evt.preventDefault();\r\n                this.parent.seek(currentTime - 1.0);\r\n                this.update_scrubber();\r\n            } else if (evt.keyCode === 39) { // RIGHT\r\n                evt.preventDefault();\r\n                this.parent.seek(currentTime + 1.0);\r\n                this.update_scrubber();\r\n            }\r\n        });\r\n    };\r\n\r\n    /* Serves as a play/pause button for a connected VideoPlayer.\r\n     */\r\n    function VideoPlayer_mute(elem, parent) {\r\n        var that = this;\r\n        \r\n        Behaviors.init(VideoPlayer_mute, that, arguments);\r\n\r\n        that.parent = parent;\r\n\r\n        that.parent.ready().then(function () {\r\n            that.$elem.on(\"click touchend\", that.on_mute_intent.bind(that));\r\n\r\n            that.update_css_classes();\r\n        });\r\n    }\r\n\r\n    Behaviors.inherit(VideoPlayer_mute, Behaviors.Behavior);\r\n\r\n    VideoPlayer_mute.QUERY = \"[data-videoplayer-mute]\";\r\n\r\n    VideoPlayer_mute.prototype.update_css_classes = function () {\r\n        this.parent.is_muted().then(function (is_muted) {\r\n            if (is_muted) {\r\n                this.$elem.addClass(\"is-VideoPlayer--muted\");\r\n                this.$elem.removeClass(\"is-VideoPlayer--audible\");\r\n            } else {\r\n                this.$elem.removeClass(\"is-VideoPlayer--muted\");\r\n                this.$elem.addClass(\"is-VideoPlayer--audible\");\r\n            }\r\n        }.bind(this));\r\n    };\r\n\r\n    VideoPlayer_mute.prototype.toggle_mute = function () {\r\n        this.parent.is_muted().then(function (is_muted) {\r\n            if (is_muted) {\r\n                this.parent.unmute();\r\n            } else {\r\n                this.parent.mute();\r\n            }\r\n        }.bind(this));\r\n    };\r\n\r\n    VideoPlayer_mute.prototype.on_mute_intent = function () {\r\n        this.toggle_mute();\r\n        this.update_css_classes();\r\n    };\r\n\r\n    // Player API adaptations\r\n\r\n\r\n    /* Thin implementation for a VideoPlayer that consumes an HTML5 video\r\n     * directly. Also provides a good demonstration that the VideoPlayer APIs\r\n     * are a very thin wrapper over HTMLMediaElement.\r\n     */\r\n    function VideoPlayer__html5(elem) {\r\n        this.$video = $(elem).find(\"video\");\r\n\r\n        Behaviors.init(VideoPlayer__html5, this, arguments);\r\n    }\r\n\r\n    Behaviors.inherit(VideoPlayer__html5, VideoPlayer);\r\n\r\n    VideoPlayer__html5.QUERY = \"[data-videoplayer='html5']\";\r\n\r\n    /* Plays the video, if loaded.\r\n     */\r\n    VideoPlayer__html5.prototype.play = function () {\r\n        this.$video[0].play();\r\n    };\r\n\r\n    /* Pauses the video.\r\n     */\r\n    VideoPlayer__html5.prototype.pause = function () {\r\n        this.$video[0].pause();\r\n    };\r\n\r\n    /* Mute the video\r\n     */\r\n    VideoPlayer__html5.prototype.mute = function () {\r\n        this.$video[0].muted = true;\r\n    };\r\n\r\n    /* Unmute the video\r\n     */\r\n    VideoPlayer__html5.prototype.unmute = function () {\r\n        this.$video[0].muted = false;\r\n    };\r\n\r\n    /* Returns the current player position.\r\n     * \r\n     * This function returns a promise which resolves to the current time.\r\n     */\r\n    VideoPlayer__html5.prototype.get_current_time = function () {\r\n        return Promise.resolve(this.$video[0].currentTime);\r\n    };\r\n\r\n    /* Seek the video to the number of seconds indicated in time.\r\n     */\r\n    VideoPlayer__html5.prototype.seek = function (time) {\r\n        this.$video[0].currentTime = time;\r\n    };\r\n\r\n    /* Check the video's duration.\r\n     *\r\n     * Returns the media's length in seconds.\r\n     *\r\n     * NaN is returned if the duration is unknown (check with isNaN).\r\n     * Infinity is returned if this is a streaming video.\r\n     * \r\n     * This function returns a promise which resolves to the aformentioned\r\n     * return value.\r\n     */\r\n    VideoPlayer__html5.prototype.get_duration = function () {\r\n        return Promise.resolve(this.$video[0].duration);\r\n    };\r\n\r\n    /* Check if the video is paused.\r\n     * \r\n     * This function returns a promise which resolves to the aformentioned\r\n     * return value.\r\n     */\r\n    VideoPlayer__html5.prototype.is_paused = function () {\r\n        return Promise.resolve(this.$video[0].paused);\r\n    };\r\n\r\n    /* Check if the video is muted.\r\n     * \r\n     * This function returns a promise which resolves to the aformentioned\r\n     * return value.\r\n     */\r\n    VideoPlayer__html5.prototype.is_muted = function () {\r\n        return Promise.resolve(this.$video[0].muted);\r\n    };\r\n\r\n    /* Check the volume of the video.\r\n     * \r\n     * This function returns a promise which resolves to the aformentioned\r\n     * return value.\r\n     */\r\n    VideoPlayer__html5.prototype.get_volume = function () {\r\n        return Promise.resolve(this.$video[0].volume);\r\n    };\r\n\r\n    /* Register an event handler for changes to the video's playback state.\r\n     *\r\n     * This corresponds exactly to matching the playing, play, and pause events\r\n     * and other video service APIs should ensure their event handler triggers\r\n     * on similar conditions.\r\n     */\r\n    VideoPlayer__html5.prototype.add_statechange_listener = function (listen) {\r\n        this.$video.on(\"playing play pause\", listen);\r\n    };\r\n\r\n    /* Register an event handler for changes to the video's playback time.\r\n     *\r\n     * This corresponds to the timeupdate event on HTMLMediaElement. This event\r\n     * is permitted not to register an event if it returns FALSE, indicating\r\n     * that timeupdates are not provided by this player type.\r\n     */\r\n    VideoPlayer__html5.prototype.add_timeupdate_listener = function (listen) {\r\n        this.$video.on(\"timeupdate\", listen);\r\n    };\r\n\r\n    /* This VideoPlayer consumes a YouTube iframe using the YouTube API.\r\n     * See https://developers.google.com/youtube/iframe_api_reference\r\n     */\r\n    function VideoPlayer__youtube(elem) {\r\n        var that = this;\r\n\r\n        Behaviors.init(VideoPlayer__youtube, that, arguments);\r\n\r\n        this.$iframe = $(elem).find(\"iframe\");\r\n        this.id = this.$iframe.attr(\"id\");\r\n        if (this.id === undefined) {\r\n            //Randomly generate an ID if one was not provided.\r\n            this.id = \"VideoPlayer-random_id--\" + Math.random() * 1024 * 1024;\r\n            this.$iframe.attr(\"id\", this.id);\r\n        }\r\n\r\n        this.player_fully_loaded = false;\r\n    }\r\n\r\n    Behaviors.inherit(VideoPlayer__youtube, VideoPlayer);\r\n\r\n    VideoPlayer__youtube.QUERY = \"[data-videoplayer='youtube']\";\r\n\r\n    /* Install the YouTube API, if not already installed.\r\n     *\r\n     * This is an asynchronous operation, so we return a Promise that resolves\r\n     * when YouTube's API is available. Invocation works like so:\r\n     *\r\n     * VideoPlayer__youtube.api().then(function () {\r\n     *     //do stuff...\r\n     * })\r\n     */\r\n    VideoPlayer__youtube.api = function () {\r\n        if (VideoPlayer__youtube.install_promise === undefined) {\r\n            VideoPlayer__youtube.install_promise = new Promise(function (resolve, reject) {\r\n                var tag, firstScriptTag;\r\n\r\n                tag = document.createElement(\"script\");\r\n                tag.src = \"https://www.youtube.com/iframe_api\";\r\n                firstScriptTag = document.getElementsByTagName('script')[0];\r\n                firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);\r\n\r\n                window.onYouTubeIframeAPIReady = VideoPlayer__youtube.api_ready_handler(resolve, reject);\r\n            });\r\n        }\r\n\r\n        return VideoPlayer__youtube.install_promise;\r\n    };\r\n\r\n    /* Creates the function that gets called when the YouTube API is ready.\r\n     */\r\n    VideoPlayer__youtube.api_ready_handler = function (resolve, reject) {\r\n        return function () {\r\n            resolve();\r\n        };\r\n    };\r\n\r\n    /* Returns a promise which resolves when the player is ready to accept\r\n     * other API calls.\r\n     *\r\n     * Calling those other API calls outside of a then() block from the promise\r\n     * returned by this function is a good way to have a bad time.\r\n     */\r\n    VideoPlayer__youtube.prototype.ready = function () {\r\n        var that = this;\r\n        \r\n        if (that.ready_promise === undefined) {\r\n            that.ready_promise = VideoPlayer__youtube.api().then(function () {\r\n                that.player = new window.YT.Player(that.id, {\r\n                    \"playerVars\": {\r\n                        \"enablejsapi\": true\r\n                    }\r\n                });\r\n\r\n                return new Promise(function (resolve, reject) {\r\n                    if (that.player_fully_loaded) {\r\n                        resolve();\r\n                    } else {\r\n                        that.player.addEventListener(\"onReady\", function () {\r\n                            that.player_fully_loaded = true;\r\n                            resolve();\r\n                        });\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        \r\n        return that.ready_promise;\r\n    };\r\n\r\n    /* Plays the video, if loaded.\r\n     */\r\n    VideoPlayer__youtube.prototype.play = function () {\r\n        this.ready().then(function () {\r\n            this.player.playVideo();\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Pauses the video.\r\n     */\r\n    VideoPlayer__youtube.prototype.pause = function () {\r\n        this.ready().then(function () {\r\n            this.player.pauseVideo();\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Mute the video\r\n     */\r\n    VideoPlayer__youtube.prototype.mute = function () {\r\n        this.ready().then(function () {\r\n            this.player.mute();\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Unmute the video\r\n     */\r\n    VideoPlayer__youtube.prototype.unmute = function () {\r\n        this.ready().then(function () {\r\n            this.player.unMute();\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Returns the current player position.\r\n     * \r\n     * This function returns a promise which resolves to the current time.\r\n     */\r\n    VideoPlayer__youtube.prototype.get_current_time = function () {\r\n        return this.ready().then(function () {\r\n            return this.player.getCurrentTime();\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Seek the video to the number of seconds indicated in time.\r\n     *\r\n     * The seek_commit parameter should be FALSE if and only if the seek\r\n     * resulted from a mousedrag and you expect to get more seek operations.\r\n     */\r\n    VideoPlayer__youtube.prototype.seek = function (time, seek_commit) {\r\n        return this.ready().then(function () {\r\n            return this.player.seekTo(time, seek_commit);\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Check the video's duration.\r\n     *\r\n     * Returns the media's length in seconds.\r\n     *\r\n     * NaN is returned if the duration is unknown (check with isNaN).\r\n     * Infinity is returned if this is a streaming video.\r\n     *\r\n     * SPEC VIOLATION: YouTube does not indicate if the player is playing a\r\n     * live event, so live-streaming players will have incorrect duration info.\r\n     * \r\n     * This function returns a promise which resolves to the aformentioned\r\n     * return value.\r\n     */\r\n    VideoPlayer__youtube.prototype.get_duration = function () {\r\n        return this.ready().then(function () {\r\n            var duration = this.player.getDuration();\r\n\r\n            if (duration === 0) {\r\n                return NaN;\r\n            }\r\n\r\n            return duration;\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Check if the video is paused.\r\n     *\r\n     * TODO: We naively interpret YouTube's player state, does player state 2\r\n     * correspond to HTMLMediaElement/VideoPlayer__html5's .paused attribute?\r\n     * Or are there other player states that count as paused by HTML5?\r\n     * \r\n     * This function returns a promise which resolves to the aformentioned\r\n     * return value.\r\n     */\r\n    VideoPlayer__youtube.prototype.is_paused = function () {\r\n        return this.ready().then(function () {\r\n            var ps = this.player.getPlayerState();\r\n            return ps === 2 || ps === -1 || ps === 5;\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Check if the video is muted.\r\n     * \r\n     * This function returns a promise which resolves to the aformentioned\r\n     * return value.\r\n     */\r\n    VideoPlayer__youtube.prototype.is_muted = function () {\r\n        return this.ready().then(function () {\r\n            return this.player.isMuted();\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Check the volume of the video.\r\n     *\r\n     * YouTube works in percentage units for some reason.\r\n     * \r\n     * This function returns a promise which resolves to the aformentioned\r\n     * return value.\r\n     */\r\n    VideoPlayer__youtube.prototype.get_volume = function () {\r\n        return this.ready().then(function () {\r\n            return this.player.getVolume() / 100;\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Register an event handler for changes to the video's playback state.\r\n     *\r\n     * This corresponds exactly to matching the playing, play, and pause events\r\n     * and other video service APIs should ensure their event handler triggers\r\n     * on similar conditions.\r\n     */\r\n    VideoPlayer__youtube.prototype.add_statechange_listener = function (listen) {\r\n        this.ready().then(function () {\r\n            this.player.addEventListener(\"onStateChange\", listen);\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Register an event handler for changes to the video's playback time.\r\n     *\r\n     * YouTube doesn't have this event type for some reason.\r\n     */\r\n    VideoPlayer__youtube.prototype.add_timeupdate_listener = function (listen) {\r\n        return false;\r\n    };\r\n\r\n    VideoPlayer__youtube.content_ready = function ($context) {\r\n        var Class = this;\r\n\r\n        if ($context.find(Class.QUERY).length > 0) {\r\n            Class.api().then(function () {\r\n                Class.find_markup($context);\r\n            });\r\n        }\r\n    };\r\n    \r\n    /* This VideoPlayer consumes a Vimeo iframe using their player controller.\r\n     * See https://github.com/vimeo/player.js\r\n     */\r\n    function VideoPlayer__vimeo(elem) {\r\n        var that = this;\r\n\r\n        Behaviors.init(VideoPlayer__vimeo, that, arguments);\r\n        \r\n        this.ready();\r\n    }\r\n\r\n    VideoPlayer__vimeo.QUERY = \"[data-videoplayer='vimeo']\";\r\n    \r\n    Behaviors.inherit(VideoPlayer__vimeo, VideoPlayer);\r\n    \r\n    /* Install the Vimeo API, if not already installed.\r\n     *\r\n     * This is an asynchronous operation, so we return a Promise that resolves\r\n     * when Vimeo's API is available. Invocation works like so:\r\n     *\r\n     * VideoPlayer__vimeo.api().then(function () {\r\n     *     //do stuff...\r\n     * })\r\n     */\r\n    VideoPlayer__vimeo.api = function () {\r\n        if (VideoPlayer__vimeo.install_promise === undefined) {\r\n            VideoPlayer__vimeo.install_promise = new Promise(function (resolve, reject) {\r\n                var tag, firstScriptTag;\r\n\r\n                tag = document.createElement(\"script\");\r\n                tag.src = \"https://player.vimeo.com/api/player.js\";\r\n                tag.onload = VideoPlayer__vimeo.api_ready_handler(resolve, reject);\r\n                tag.async = true;\r\n                firstScriptTag = document.getElementsByTagName('script')[0];\r\n                firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);\r\n            });\r\n        }\r\n\r\n        return VideoPlayer__vimeo.install_promise;\r\n    };\r\n\r\n    /* Creates the function that gets called when the Vimeo API is ready.\r\n     */\r\n    VideoPlayer__vimeo.api_ready_handler = function (resolve, reject) {\r\n        function wait_for_vimeo() {\r\n            if (window.Vimeo !== undefined) {\r\n                resolve();\r\n            } else {\r\n                window.setTimeout(wait_for_vimeo, 10);\r\n            }\r\n        }\r\n        \r\n        return wait_for_vimeo;\r\n    };\r\n    \r\n    /* Returns a promise which resolves when the player is ready to accept\r\n     * other API calls.\r\n     *\r\n     * Calling those other API calls outside of a then() block from the promise\r\n     * returned by this function is a good way to have a bad time.\r\n     */\r\n    VideoPlayer__vimeo.prototype.ready = function () {\r\n        var that = this;\r\n        \r\n        if (this.ready_promise === undefined) {\r\n            this.ready_promise = VideoPlayer__vimeo.api().then(function () {\r\n                this.player = new window.Vimeo.Player(this.$elem);\r\n            }.bind(this));\r\n        }\r\n        \r\n        return this.ready_promise;\r\n    };\r\n\r\n    /* Plays the video, if loaded.\r\n     */\r\n    VideoPlayer__vimeo.prototype.play = function () {\r\n        return this.ready().then(function () {\r\n            this.player.play();\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Pauses the video.\r\n     */\r\n    VideoPlayer__vimeo.prototype.pause = function () {\r\n        return this.ready().then(function () {\r\n            this.player.pause();\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Mute the video\r\n     */\r\n    VideoPlayer__vimeo.prototype.mute = function () {\r\n        return this.ready().then(function () {\r\n            return this.player.getVolume();\r\n        }.bind(this)).then(function (volume) {\r\n            this.preMuteVolume = volume;\r\n            this.player.setVolume(0);\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Unmute the video\r\n     */\r\n    VideoPlayer__vimeo.prototype.unmute = function () {\r\n        return this.ready().then(function () {\r\n            return this.player.setVolume(this.preMuteVolume || 1.0);\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Returns the current player position.\r\n     * \r\n     * This function returns a promise which resolves to the current time.\r\n     */\r\n    VideoPlayer__vimeo.prototype.get_current_time = function () {\r\n        return this.ready().then(function () {\r\n            return this.player.getCurrentTime();\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Seek the video to the number of seconds indicated in time.\r\n     *\r\n     * The seek_commit parameter should be FALSE if and only if the seek\r\n     * resulted from a mousedrag and you expect to get more seek operations.\r\n     * \r\n     * As a unique quirk of the Vimeo API, the returned promise will resolve\r\n     * to the actual seek time adopted by the player.\r\n     */\r\n    VideoPlayer__vimeo.prototype.seek = function (time, seek_commit) {\r\n        return this.ready().then(function () {\r\n            return this.player.setCurrentTime(time);\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Check the video's duration.\r\n     *\r\n     * Returns the media's length in seconds.\r\n     *\r\n     * NaN is returned if the duration is unknown (check with isNaN).\r\n     * Infinity is returned if this is a streaming video.\r\n     * \r\n     * This function returns a promise which resolves to the aformentioned\r\n     * return value.\r\n     */\r\n    VideoPlayer__vimeo.prototype.get_duration = function () {\r\n        return this.ready().then(function () {\r\n            return this.player.getDuration();\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Check if the video is paused.\r\n     * \r\n     * This function returns a promise which resolves to the aformentioned\r\n     * return value.\r\n     */\r\n    VideoPlayer__vimeo.prototype.is_paused = function () {\r\n        return this.ready().then(function () {\r\n            return this.player.getPaused();\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Check if the video is muted.\r\n     * \r\n     * This function returns a promise which resolves to the aformentioned\r\n     * return value.\r\n     */\r\n    VideoPlayer__vimeo.prototype.is_muted = function () {\r\n        return this.ready().then(function () {\r\n            return this.get_volume();\r\n        }.bind(this)).then(function (volume) {\r\n            return volume === 0.0;\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Check the volume of the video.\r\n     * \r\n     * This function returns a promise which resolves to the aformentioned\r\n     * return value.\r\n     */\r\n    VideoPlayer__vimeo.prototype.get_volume = function () {\r\n        return this.ready().then(function () {\r\n            return this.player.getVolume();\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Register an event handler for changes to the video's playback state.\r\n     *\r\n     * This corresponds exactly to matching the playing, play, and pause events\r\n     * and other video service APIs should ensure their event handler triggers\r\n     * on similar conditions.\r\n     */\r\n    VideoPlayer__vimeo.prototype.add_statechange_listener = function (listen) {\r\n        return this.ready().then(function () {\r\n            this.player.on(\"play\", listen);\r\n            this.player.on(\"pause\", listen);\r\n            this.player.on(\"ended\", listen);\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Register an event handler for changes to the video's playback time.\r\n     */\r\n    VideoPlayer__vimeo.prototype.add_timeupdate_listener = function (listen) {\r\n        return this.ready().then(function () {\r\n            return this.player.on(\"timeupdate\", listen);\r\n        }.bind(this));\r\n    };\r\n    \r\n    VideoPlayer__vimeo.content_ready = function ($context) {\r\n        var Class = this;\r\n\r\n        if ($context.find(Class.QUERY).length > 0) {\r\n            Class.api().then(function () {\r\n                Class.find_markup($context);\r\n            });\r\n        }\r\n    };\r\n\r\n    Behaviors.register_behavior(VideoPlayer__html5);\r\n    Behaviors.register_behavior(VideoPlayer__youtube);\r\n    Behaviors.register_behavior(VideoPlayer__vimeo);\r\n    \r\n    module.VideoPlayer = VideoPlayer;\r\n    module.VideoPlayer_playpause = VideoPlayer_playpause;\r\n    module.VideoPlayer_scrubber = VideoPlayer_scrubber;\r\n    module.VideoPlayer_mute = VideoPlayer_mute;\r\n    module.VideoPlayer_offcanvas = VideoPlayer_offcanvas;\r\n    module.VideoPlayer_hover = VideoPlayer_hover;\r\n    module.VideoPlayer__html5 = VideoPlayer__html5;\r\n    module.VideoPlayer__youtube = VideoPlayer__youtube;\r\n    module.VideoPlayer__vimeo = VideoPlayer__vimeo;\r\n    return module;\r\n}));\r\n"],"sourceRoot":"/source/"}