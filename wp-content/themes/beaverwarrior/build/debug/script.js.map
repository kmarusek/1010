{"version":3,"sources":["apolyfill_Function.name.js","aPolyfill_promise.min.js","behaviors.js","wow.js","AffixColumn/AffixColumn.js","Animations/Animations.js","CollapseContent/collapse_content.js","Depaginate/depaginate.js","GoogleMap/GoogleMap.js","Offcanvas/betteroffcanvas.js","PageTransition/page_transition.js","ScrollEffects/ScrollEffects.js","SiteHeader/AccountSlideIn.js","SiteHeader/SiteHeader.js","StaffGrid/StaffGrid.js","TabbedContent/tabbed_content.js","VideoPlayer/VideoPlayer.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtHA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/VA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjsBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/6BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7ZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"script.js","sourcesContent":["//https://github.com/JamesMGreene/Function.name/blob/master/Function.name.js\r\n(function() {\r\n\r\nvar fnNameMatchRegex = /^\\s*function\\s+([^\\(\\s]*)\\s*/;\r\n\r\nfunction _name() {\r\n  var match, name;\r\n  if (this === Function || this === Function.prototype.constructor) {\r\n    name = \"Function\";\r\n  }\r\n  else if (this !== Function.prototype) {\r\n    match = (\"\" + this).match(fnNameMatchRegex);\r\n    name = match && match[1];\r\n  }\r\n  return name || \"\";\r\n}\r\n\r\n// Inspect the polyfill-ability of this browser\r\nvar needsPolyfill = !(\"name\" in Function.prototype && \"name\" in (function x() {}));\r\nvar canDefineProp = typeof Object.defineProperty === \"function\" &&\r\n  (function() {\r\n    var result;\r\n    try {\r\n      Object.defineProperty(Function.prototype, \"_xyz\", {\r\n        get: function() {\r\n          return \"blah\";\r\n        },\r\n        configurable: true\r\n      });\r\n      result = Function.prototype._xyz === \"blah\";\r\n      delete Function.prototype._xyz;\r\n    }\r\n    catch (e) {\r\n      result = false;\r\n    }\r\n    return result;\r\n  })();\r\nvar canDefineGetter = typeof Object.prototype.__defineGetter__ === \"function\" &&\r\n  (function() {\r\n    var result;\r\n    try {\r\n      Function.prototype.__defineGetter__(\"_abc\", function() {\r\n        return \"foo\";\r\n      });\r\n      result = Function.prototype._abc === \"foo\";\r\n      delete Function.prototype._abc;\r\n    }\r\n    catch (e) {\r\n      result = false;\r\n    }\r\n    return result;\r\n  })();\r\n\r\n\r\n\r\n// Add the \"private\" property for testing, even if the real property can be polyfilled\r\nFunction.prototype._name = _name;\r\n\r\n\r\n// Polyfill it!\r\n// For:\r\n//  * IE >=9 <12\r\n//  * Chrome <33\r\nif (needsPolyfill) {\r\n  // For:\r\n  //  * IE >=9 <12\r\n  //  * Chrome >=5 <33\r\n  if (canDefineProp) {\r\n    Object.defineProperty(Function.prototype, \"name\", {\r\n      get: function() {\r\n        var name = _name.call(this);\r\n\r\n        // Since named function definitions have immutable names, also memoize the\r\n        // output by defining the `name` property directly on this Function\r\n        // instance so that this polyfill will not need to be invoked again\r\n        if (this !== Function.prototype) {\r\n          Object.defineProperty(this, \"name\", {\r\n            value: name,\r\n            configurable: true\r\n          });\r\n        }\r\n\r\n        return name;\r\n      },\r\n      configurable: true\r\n    });\r\n  }\r\n  // For:\r\n  //  * Chrome <5\r\n  else if (canDefineGetter) {\r\n    // NOTE:\r\n    // The snippet:\r\n    //\r\n    //     x.__defineGetter__('y', z);\r\n    //\r\n    // ...is essentially equivalent to:\r\n    //\r\n    //     Object.defineProperty(x, 'y', {\r\n    //       get: z,\r\n    //       configurable: true,  // <-- key difference #1\r\n    //       enumerable: true     // <-- key difference #2\r\n    //     });\r\n    //\r\n    Function.prototype.__defineGetter__(\"name\", function() {\r\n      var name = _name.call(this);\r\n\r\n      // Since named function definitions have immutable names, also memoize the\r\n      // output by defining the `name` property directly on this Function\r\n      // instance so that this polyfill will not need to be invoked again\r\n      if (this !== Function.prototype) {\r\n        this.__defineGetter__(\"name\", function() { return name; });\r\n      }\r\n\r\n      return name;\r\n    });\r\n  }\r\n}\r\n\r\n})();","!function(e){function n(){}function t(e,n){return function(){e.apply(n,arguments)}}function o(e){if(\"object\"!=typeof this)throw new TypeError(\"Promises must be constructed via new\");if(\"function\"!=typeof e)throw new TypeError(\"not a function\");this._state=0,this._handled=!1,this._value=void 0,this._deferreds=[],s(e,this)}function i(e,n){for(;3===e._state;)e=e._value;return 0===e._state?void e._deferreds.push(n):(e._handled=!0,void o._immediateFn(function(){var t=1===e._state?n.onFulfilled:n.onRejected;if(null===t)return void(1===e._state?r:u)(n.promise,e._value);var o;try{o=t(e._value)}catch(i){return void u(n.promise,i)}r(n.promise,o)}))}function r(e,n){try{if(n===e)throw new TypeError(\"A promise cannot be resolved with itself.\");if(n&&(\"object\"==typeof n||\"function\"==typeof n)){var i=n.then;if(n instanceof o)return e._state=3,e._value=n,void f(e);if(\"function\"==typeof i)return void s(t(i,n),e)}e._state=1,e._value=n,f(e)}catch(r){u(e,r)}}function u(e,n){e._state=2,e._value=n,f(e)}function f(e){2===e._state&&0===e._deferreds.length&&o._immediateFn(function(){e._handled||o._unhandledRejectionFn(e._value)});for(var n=0,t=e._deferreds.length;n<t;n++)i(e,e._deferreds[n]);e._deferreds=null}function c(e,n,t){this.onFulfilled=\"function\"==typeof e?e:null,this.onRejected=\"function\"==typeof n?n:null,this.promise=t}function s(e,n){var t=!1;try{e(function(e){t||(t=!0,r(n,e))},function(e){t||(t=!0,u(n,e))})}catch(o){if(t)return;t=!0,u(n,o)}}var a=setTimeout;o.prototype[\"catch\"]=function(e){return this.then(null,e)},o.prototype.then=function(e,t){var o=new this.constructor(n);return i(this,new c(e,t,o)),o},o.all=function(e){var n=Array.prototype.slice.call(e);return new o(function(e,t){function o(r,u){try{if(u&&(\"object\"==typeof u||\"function\"==typeof u)){var f=u.then;if(\"function\"==typeof f)return void f.call(u,function(e){o(r,e)},t)}n[r]=u,0===--i&&e(n)}catch(c){t(c)}}if(0===n.length)return e([]);for(var i=n.length,r=0;r<n.length;r++)o(r,n[r])})},o.resolve=function(e){return e&&\"object\"==typeof e&&e.constructor===o?e:new o(function(n){n(e)})},o.reject=function(e){return new o(function(n,t){t(e)})},o.race=function(e){return new o(function(n,t){for(var o=0,i=e.length;o<i;o++)e[o].then(n,t)})},o._immediateFn=\"function\"==typeof setImmediate&&function(e){setImmediate(e)}||function(e){a(e,0)},o._unhandledRejectionFn=function(e){\"undefined\"!=typeof console&&console&&console.warn(\"Possible Unhandled Promise Rejection:\",e)},o._setImmediateFn=function(e){o._immediateFn=e},o._setUnhandledRejectionFn=function(e){o._unhandledRejectionFn=e},\"undefined\"!=typeof module&&module.exports?module.exports=o:e.Promise||(e.Promise=o)}(this);","/*global define, window, document*/\r\n\r\n//Polyfill for Object.create.\r\nif (typeof Object.create !== 'function') {\r\n    Object.create = (function () {\r\n        \"use strict\";\r\n        var Temp = function () {};\r\n        return function (prototype) {\r\n            if (arguments.length > 1) {\r\n                throw new Error('Second argument not supported');\r\n            }\r\n            if (typeof prototype !== 'object') {\r\n                throw new TypeError('Argument must be an object');\r\n            }\r\n            Temp.prototype = prototype;\r\n            var result = new Temp();\r\n            Temp.prototype = null;\r\n            return result;\r\n        };\r\n    }());\r\n}\r\n\r\n(function (root, factory) {\r\n    \"use strict\";\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(\"Behaviors\", [\"jquery\"], factory);\r\n    } else {\r\n        root.Behaviors = factory(root.jQuery);\r\n    }\r\n}(this, function ($) {\r\n    \"use strict\";\r\n\r\n    var module = {},\r\n        behavior_registry = {},\r\n        content_ready_listeners = [],\r\n        ElementMissingError = error(\"ElementMissingError\");\r\n    \r\n    /* Throttle an event handler.\r\n     *\r\n     * Returns a function which, no matter how frequently it's called, will\r\n     * only trigger a maximum of once per timeout period. More specifically,\r\n     * the first event will always be processed, then, no events will process\r\n     * until the end of the timeout period. If one or more events occurred\r\n     * during this period, the last event recieved will trigger immediately\r\n     * after the end of the timeout period, as well as restart the throttling\r\n     * period. Any preceding events will be discarded.\r\n     *\r\n     * Not to be confused with a debounce, which only fires the event handler\r\n     * at the end of a string of events spaced closer than the timeout period.\r\n     *\r\n     * The nature of this function means that any passed in function's return\r\n     * value will be discarded.\r\n     */\r\n    function throttle_single(func, timeout) {\r\n        var lastTimeout, afterLastArgs, afterLastThis;\r\n\r\n        function unthrottle() {\r\n            if (afterLastArgs !== undefined) {\r\n                func.apply(afterLastThis, afterLastArgs);\r\n                afterLastArgs = undefined;\r\n                lastTimeout = window.setTimeout(unthrottle, timeout);\r\n            } else {\r\n                lastTimeout = undefined;\r\n            }\r\n        }\r\n\r\n        return function () {\r\n            var myThis = this, myArgs = [], i;\r\n\r\n            for (i = 0; i < arguments.length; i += 1) {\r\n                myArgs.push(arguments[i]);\r\n            }\r\n\r\n            if (lastTimeout === undefined) {\r\n                func.apply(myThis, myArgs);\r\n                lastTimeout = window.setTimeout(unthrottle, timeout);\r\n            } else {\r\n                afterLastArgs = myArgs;\r\n                afterLastThis = myThis;\r\n            }\r\n        };\r\n    }\r\n\r\n    function Behavior(elem) {\r\n        //Do something to elem\r\n        this.$elem = $(elem);\r\n    }\r\n\r\n    /* Find a behavior's markup.\r\n     *\r\n     * The $context argument passed to this function is the jQuery element that\r\n     * will be searched for behaviors. Any additional arguments will be passed\r\n     * to Behavior.locate and ultimately to the behavior's constructor.\r\n     */\r\n    Behavior.find_markup = function ($context) {\r\n        var results = [], i, splitArgs = [], Class = this;\r\n\r\n        for (i = 1; i < arguments.length; i += 1) {\r\n            splitArgs.push(arguments[i]);\r\n        }\r\n        \r\n        function processElem(index, elem) {\r\n            var locateArgs = [elem].concat(splitArgs);\r\n\r\n            results.push(Class.locate.apply(Class, locateArgs));\r\n        }\r\n        \r\n        $context.filter(Class.QUERY).each(processElem);\r\n        $context.find(Class.QUERY).each(processElem);\r\n\r\n        return results;\r\n    };\r\n\r\n    /* Locate a behavior onto an element, returning an instance of that\r\n     * behavior that you can work with.\r\n     *\r\n     * A behavior locates onto an element by instantiating an instance of\r\n     * itself and installing it onto the markup's jQuery data. Therefore, we\r\n     * will only instantiate that behavior once; and further calls to .locate\r\n     * instead return the same object. Thus, it is safe to use .locate as a\r\n     * general accessor - it is idempotent.\r\n     *\r\n     * The elem argument indicates the element that the behavior should locate\r\n     * onto. Further arguments are passed onto the constructor.\r\n     *\r\n     * TODO: Is there a non-jQuery way of handling this?\r\n     */\r\n    Behavior.locate = function (elem) {\r\n        var $elem = $(elem), new_object, i, objectArgs = [elem], Class = this,\r\n            rc = $elem.data(\"behaviors-registered-classes\");\r\n        \r\n        if ($elem.length === 0) {\r\n            throw new ElementMissingError(\"Attempted to locate a Behavior onto an empty element query.\");\r\n        }\r\n\r\n        if (rc === undefined) {\r\n            rc = {};\r\n        }\r\n\r\n        if (rc[Class.name] === undefined) {\r\n            //Grab the other arguments\r\n            for (i = 1; i < arguments.length; i += 1) {\r\n                objectArgs.push(arguments[i]);\r\n            }\r\n\r\n            new_object = Object.create(Class.prototype);\r\n            Class.apply(new_object, objectArgs);\r\n            rc[Class.name] = new_object;\r\n        } else {\r\n            new_object = rc[Class.name];\r\n        }\r\n\r\n        $elem.data(\"behaviors-registered-classes\", rc);\r\n\r\n        return new_object;\r\n    };\r\n\r\n    /* Respond to the presence of new content on the page.\r\n     *\r\n     * By default, we attempt to find markup on all children of the context.\r\n     * Subclasses may do something crazier, like say delay behavior processing\r\n     * until some third-party API is loaded.\r\n     *\r\n     * Consider this roughly equivalent to $(document).ready() callbacks.\r\n     */\r\n    Behavior.content_ready = function ($context) {\r\n        var Class = this;\r\n\r\n        Class.find_markup($context);\r\n    };\r\n    \r\n    /* Respond to the impending removal of content from the page.\r\n     * \r\n     * Most behaviors that only attach event handlers to their own content are\r\n     * safe and do not need to implement content removal support: they will\r\n     * inherently \"fall away\".\r\n     * \r\n     * However, behaviors that run a constant animation kernel or attach event\r\n     * handlers to elements outside of their own ownership must provide a\r\n     * mechanism to detach those event handlers and stop those kernels.\r\n     */\r\n    Behavior.content_removal = function ($context) {\r\n        var Class = this,\r\n            $attached_elems = $context.find(Class.QUERY);\r\n        \r\n        //Iterate through each element and see if our behavior has located upon\r\n        //them. We don't just call .find_markup/.locate since we don't want to\r\n        //risk initializing something just to tear it down one cycle later.\r\n        $attached_elems.each(function (index, attach_elem) {\r\n            var $elem = $(attach_elem),\r\n                rc = $elem.data(\"behaviors-registered-classes\");\r\n            \r\n            if (rc === undefined) {\r\n                return;\r\n            }\r\n            \r\n            if (rc[Class.name] === undefined) {\r\n                return;\r\n            }\r\n            \r\n            if (rc[Class.name].deinitialize === undefined) {\r\n                return;\r\n            }\r\n            \r\n            rc[Class.name].deinitialize();\r\n        });\r\n    };\r\n\r\n    /* Register a behavior so that it can respond to global events such as new\r\n     * content becoming ready.\r\n     *\r\n     * It is not always appropriate to register your behavior to recieve load\r\n     * events. Generally, if this is a behavior you would initialize yourself,\r\n     * perhaps with special arguments, then you should not register that here.\r\n     */\r\n    function register_behavior(Class, name) {\r\n        if (name === undefined) {\r\n            name = Class.name;\r\n        }\r\n\r\n        behavior_registry[name] = Class;\r\n    }\r\n    \r\n    /* Register a function that is called when content is ready.\r\n     * \r\n     * This function should only be used for things that are not a Behavior.\r\n     * Proper behaviors should be registered using register_behavior for future\r\n     * uses. Non-behavior listeners get registered here so that future uses of\r\n     * behavior registration do not conflict with non-Behavior listeners.\r\n     */\r\n    function register_content_listener(func) {\r\n        content_ready_listeners.push(func);\r\n    }\r\n\r\n    /* Indicate that some new content is ready.\r\n     *\r\n     * The given content will be passed onto all registered behaviors.\r\n     *\r\n     * CMS/frameworks with their own ready mechanism will need to ship their\r\n     * own replacement/wrapper for this function that pushes calls to this\r\n     * function over to that mechanism; and calls from that mechanism need to\r\n     * come back here.\r\n     */\r\n    function content_ready($context) {\r\n        var k, i;\r\n        \r\n        function do_later(obj, func) {\r\n            window.setTimeout(func.bind(obj, $context), 0);\r\n        }\r\n        \r\n        for (i = 0; i < content_ready_listeners.length; i += 1) {\r\n            do_later(undefined, content_ready_listeners[i]);\r\n        }\r\n\r\n        for (k in behavior_registry) {\r\n            if (behavior_registry.hasOwnProperty(k)) {\r\n                do_later(behavior_registry[k], behavior_registry[k].content_ready);\r\n            }\r\n        }\r\n    }\r\n    \r\n    /* Indicate that content is about to be removed.\r\n     * \r\n     * Registered behaviors with destructors will be called upon to remove any\r\n     * external event handlers or animation kernels preventing them from being\r\n     * terminated by the JS runtime.\r\n     * \r\n     * TODO: Add content_removal listener functions.\r\n     */\r\n    function content_removal($context) {\r\n        var k, i;\r\n        \r\n        function do_later(obj, func) {\r\n            window.setTimeout(func.bind(obj, $context), 0);\r\n        }\r\n        \r\n        for (k in behavior_registry) {\r\n            if (behavior_registry.hasOwnProperty(k)) {\r\n                do_later(behavior_registry[k], behavior_registry[k].content_removal);\r\n            }\r\n        }\r\n    }\r\n    \r\n    function error(error_class_name, ParentClass) {\r\n        if (error_class_name === undefined) {\r\n            throw new Error(\"Please name your error subclass.\");\r\n        }\r\n\r\n        if (!(ParentClass instanceof Function)) {\r\n            ParentClass = Error;\r\n        }\r\n\r\n        var SubError = function (message) {\r\n            var err = new Error(message);\r\n            err.name = error_class_name;\r\n\r\n            this.name = error_class_name;\r\n            this.message = err.message;\r\n            if (err.stack) {\r\n                this.stack = err.stack;\r\n            }\r\n        };\r\n\r\n        SubError.prototype = new ParentClass(\"u dont c me\");\r\n        SubError.prototype.constructor = SubError;\r\n        SubError.prototype.name = error_class_name;\r\n\r\n        delete SubError.prototype.stack;\r\n\r\n        return SubError;\r\n    }\r\n    \r\n    function inherit(ChildClass, ParentClass) {\r\n        var k;\r\n\r\n        //Use the prototyping system to copy methods from parent to child.\r\n        ChildClass.prototype = Object.create(ParentClass.prototype);\r\n        ChildClass.prototype.constructor = ChildClass;\r\n        ChildClass.prototype.parent = ParentClass.prototype;\r\n\r\n        //Manually copy class-level methods from parent to child.\r\n        for (k in ParentClass) {\r\n            if (ParentClass.hasOwnProperty(k)) {\r\n                ChildClass[k] = ParentClass[k];\r\n            }\r\n        }\r\n    }\r\n\r\n    function init(ChildClass, object, args) {\r\n        ChildClass.prototype.parent.constructor.apply(object, args);\r\n    }\r\n    \r\n    /* By default, report the initial page load to registered behaviors.\r\n     */\r\n    $(document).ready(function () {\r\n        content_ready($(document));\r\n    });\r\n    \r\n    module.ElementMissingError = ElementMissingError;\r\n    module.throttle_single = throttle_single;\r\n    module.Behavior = Behavior;\r\n    module.error = error;\r\n    module.inherit = inherit;\r\n    module.init = init;\r\n    module.register_behavior = register_behavior;\r\n    module.content_ready = content_ready;\r\n    module.content_removal = content_removal;\r\n    module.register_content_listener = register_content_listener;\r\n\r\n    return module;\r\n}));\r\n","(function() {\r\n  var MutationObserver, Util, WeakMap, getComputedStyle, getComputedStyleRX,\r\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\r\n    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\r\n\r\n  Util = (function() {\r\n    function Util() {}\r\n\r\n    Util.prototype.extend = function(custom, defaults) {\r\n      var key, value;\r\n      for (key in defaults) {\r\n        value = defaults[key];\r\n        if (custom[key] == null) {\r\n          custom[key] = value;\r\n        }\r\n      }\r\n      return custom;\r\n    };\r\n\r\n    Util.prototype.isMobile = function(agent) {\r\n      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(agent);\r\n    };\r\n\r\n    Util.prototype.createEvent = function(event, bubble, cancel, detail) {\r\n      var customEvent;\r\n      if (bubble == null) {\r\n        bubble = false;\r\n      }\r\n      if (cancel == null) {\r\n        cancel = false;\r\n      }\r\n      if (detail == null) {\r\n        detail = null;\r\n      }\r\n      if (document.createEvent != null) {\r\n        customEvent = document.createEvent('CustomEvent');\r\n        customEvent.initCustomEvent(event, bubble, cancel, detail);\r\n      } else if (document.createEventObject != null) {\r\n        customEvent = document.createEventObject();\r\n        customEvent.eventType = event;\r\n      } else {\r\n        customEvent.eventName = event;\r\n      }\r\n      return customEvent;\r\n    };\r\n\r\n    Util.prototype.emitEvent = function(elem, event) {\r\n      if (elem.dispatchEvent != null) {\r\n        return elem.dispatchEvent(event);\r\n      } else if (event in (elem != null)) {\r\n        return elem[event]();\r\n      } else if ((\"on\" + event) in (elem != null)) {\r\n        return elem[\"on\" + event]();\r\n      }\r\n    };\r\n\r\n    Util.prototype.addEvent = function(elem, event, fn) {\r\n      if (elem.addEventListener != null) {\r\n        return elem.addEventListener(event, fn, false);\r\n      } else if (elem.attachEvent != null) {\r\n        return elem.attachEvent(\"on\" + event, fn);\r\n      } else {\r\n        return elem[event] = fn;\r\n      }\r\n    };\r\n\r\n    Util.prototype.removeEvent = function(elem, event, fn) {\r\n      if (elem.removeEventListener != null) {\r\n        return elem.removeEventListener(event, fn, false);\r\n      } else if (elem.detachEvent != null) {\r\n        return elem.detachEvent(\"on\" + event, fn);\r\n      } else {\r\n        return delete elem[event];\r\n      }\r\n    };\r\n\r\n    Util.prototype.innerHeight = function() {\r\n      if ('innerHeight' in window) {\r\n        return window.innerHeight;\r\n      } else {\r\n        return document.documentElement.clientHeight;\r\n      }\r\n    };\r\n\r\n    return Util;\r\n\r\n  })();\r\n\r\n  WeakMap = this.WeakMap || this.MozWeakMap || (WeakMap = (function() {\r\n    function WeakMap() {\r\n      this.keys = [];\r\n      this.values = [];\r\n    }\r\n\r\n    WeakMap.prototype.get = function(key) {\r\n      var i, item, j, len, ref;\r\n      ref = this.keys;\r\n      for (i = j = 0, len = ref.length; j < len; i = ++j) {\r\n        item = ref[i];\r\n        if (item === key) {\r\n          return this.values[i];\r\n        }\r\n      }\r\n    };\r\n\r\n    WeakMap.prototype.set = function(key, value) {\r\n      var i, item, j, len, ref;\r\n      ref = this.keys;\r\n      for (i = j = 0, len = ref.length; j < len; i = ++j) {\r\n        item = ref[i];\r\n        if (item === key) {\r\n          this.values[i] = value;\r\n          return;\r\n        }\r\n      }\r\n      this.keys.push(key);\r\n      return this.values.push(value);\r\n    };\r\n\r\n    return WeakMap;\r\n\r\n  })());\r\n\r\n  MutationObserver = this.MutationObserver || this.WebkitMutationObserver || this.MozMutationObserver || (MutationObserver = (function() {\r\n    function MutationObserver() {\r\n      if (typeof console !== \"undefined\" && console !== null) {\r\n        console.warn('MutationObserver is not supported by your browser.');\r\n      }\r\n      if (typeof console !== \"undefined\" && console !== null) {\r\n        console.warn('WOW.js cannot detect dom mutations, please call .sync() after loading new content.');\r\n      }\r\n    }\r\n\r\n    MutationObserver.notSupported = true;\r\n\r\n    MutationObserver.prototype.observe = function() {};\r\n\r\n    return MutationObserver;\r\n\r\n  })());\r\n\r\n  getComputedStyle = this.getComputedStyle || function(el, pseudo) {\r\n    this.getPropertyValue = function(prop) {\r\n      var ref;\r\n      if (prop === 'float') {\r\n        prop = 'styleFloat';\r\n      }\r\n      if (getComputedStyleRX.test(prop)) {\r\n        prop.replace(getComputedStyleRX, function(_, _char) {\r\n          return _char.toUpperCase();\r\n        });\r\n      }\r\n      return ((ref = el.currentStyle) != null ? ref[prop] : void 0) || null;\r\n    };\r\n    return this;\r\n  };\r\n\r\n  getComputedStyleRX = /(\\-([a-z]){1})/g;\r\n\r\n  this.WOW = (function() {\r\n    WOW.prototype.defaults = {\r\n      boxClass: 'wow',\r\n      animateClass: 'animated',\r\n      offset: 0,\r\n      mobile: true,\r\n      live: true,\r\n      callback: null,\r\n      scrollContainer: null\r\n    };\r\n\r\n    function WOW(options) {\r\n      if (options == null) {\r\n        options = {};\r\n      }\r\n      this.scrollCallback = bind(this.scrollCallback, this);\r\n      this.scrollHandler = bind(this.scrollHandler, this);\r\n      this.resetAnimation = bind(this.resetAnimation, this);\r\n      this.start = bind(this.start, this);\r\n      this.scrolled = true;\r\n      this.config = this.util().extend(options, this.defaults);\r\n      if (options.scrollContainer != null) {\r\n        this.config.scrollContainer = document.querySelector(options.scrollContainer);\r\n      }\r\n      this.animationNameCache = new WeakMap();\r\n      this.wowEvent = this.util().createEvent(this.config.boxClass);\r\n    }\r\n\r\n    WOW.prototype.init = function() {\r\n      var ref;\r\n      this.element = window.document.documentElement;\r\n      if ((ref = document.readyState) === \"interactive\" || ref === \"complete\") {\r\n        this.start();\r\n      } else {\r\n        this.util().addEvent(document, 'DOMContentLoaded', this.start);\r\n      }\r\n      return this.finished = [];\r\n    };\r\n\r\n    WOW.prototype.start = function() {\r\n      var box, j, len, ref;\r\n      this.stopped = false;\r\n      this.boxes = (function() {\r\n        var j, len, ref, results;\r\n        ref = this.element.querySelectorAll(\".\" + this.config.boxClass);\r\n        results = [];\r\n        for (j = 0, len = ref.length; j < len; j++) {\r\n          box = ref[j];\r\n          results.push(box);\r\n        }\r\n        return results;\r\n      }).call(this);\r\n      this.all = (function() {\r\n        var j, len, ref, results;\r\n        ref = this.boxes;\r\n        results = [];\r\n        for (j = 0, len = ref.length; j < len; j++) {\r\n          box = ref[j];\r\n          results.push(box);\r\n        }\r\n        return results;\r\n      }).call(this);\r\n      if (this.boxes.length) {\r\n        if (this.disabled()) {\r\n          this.resetStyle();\r\n        } else {\r\n          ref = this.boxes;\r\n          for (j = 0, len = ref.length; j < len; j++) {\r\n            box = ref[j];\r\n            this.applyStyle(box, true);\r\n          }\r\n        }\r\n      }\r\n      if (!this.disabled()) {\r\n        this.util().addEvent(this.config.scrollContainer || window, 'scroll', this.scrollHandler);\r\n        this.util().addEvent(window, 'resize', this.scrollHandler);\r\n        this.interval = setInterval(this.scrollCallback, 50);\r\n      }\r\n      if (this.config.live) {\r\n        return new MutationObserver((function(_this) {\r\n          return function(records) {\r\n            var k, len1, node, record, results;\r\n            results = [];\r\n            for (k = 0, len1 = records.length; k < len1; k++) {\r\n              record = records[k];\r\n              results.push((function() {\r\n                var l, len2, ref1, results1;\r\n                ref1 = record.addedNodes || [];\r\n                results1 = [];\r\n                for (l = 0, len2 = ref1.length; l < len2; l++) {\r\n                  node = ref1[l];\r\n                  results1.push(this.doSync(node));\r\n                }\r\n                return results1;\r\n              }).call(_this));\r\n            }\r\n            return results;\r\n          };\r\n        })(this)).observe(document.body, {\r\n          childList: true,\r\n          subtree: true\r\n        });\r\n      }\r\n    };\r\n\r\n    WOW.prototype.stop = function() {\r\n      this.stopped = true;\r\n      this.util().removeEvent(this.config.scrollContainer || window, 'scroll', this.scrollHandler);\r\n      this.util().removeEvent(window, 'resize', this.scrollHandler);\r\n      if (this.interval != null) {\r\n        return clearInterval(this.interval);\r\n      }\r\n    };\r\n\r\n    WOW.prototype.sync = function(element) {\r\n      if (MutationObserver.notSupported) {\r\n        return this.doSync(this.element);\r\n      }\r\n    };\r\n\r\n    WOW.prototype.doSync = function(element) {\r\n      var box, j, len, ref, results;\r\n      if (element == null) {\r\n        element = this.element;\r\n      }\r\n      if (element.nodeType !== 1) {\r\n        return;\r\n      }\r\n      element = element.parentNode || element;\r\n      ref = element.querySelectorAll(\".\" + this.config.boxClass);\r\n      results = [];\r\n      for (j = 0, len = ref.length; j < len; j++) {\r\n        box = ref[j];\r\n        if (indexOf.call(this.all, box) < 0) {\r\n          this.boxes.push(box);\r\n          this.all.push(box);\r\n          if (this.stopped || this.disabled()) {\r\n            this.resetStyle();\r\n          } else {\r\n            this.applyStyle(box, true);\r\n          }\r\n          results.push(this.scrolled = true);\r\n        } else {\r\n          results.push(void 0);\r\n        }\r\n      }\r\n      return results;\r\n    };\r\n\r\n    WOW.prototype.show = function(box) {\r\n      this.applyStyle(box);\r\n      box.className = box.className + \" \" + this.config.animateClass;\r\n      if (this.config.callback != null) {\r\n        this.config.callback(box);\r\n      }\r\n      this.util().emitEvent(box, this.wowEvent);\r\n      this.util().addEvent(box, 'animationend', this.resetAnimation);\r\n      this.util().addEvent(box, 'oanimationend', this.resetAnimation);\r\n      this.util().addEvent(box, 'webkitAnimationEnd', this.resetAnimation);\r\n      this.util().addEvent(box, 'MSAnimationEnd', this.resetAnimation);\r\n      return box;\r\n    };\r\n\r\n    WOW.prototype.applyStyle = function(box, hidden) {\r\n      var delay, duration, iteration;\r\n      duration = box.getAttribute('data-wow-duration');\r\n      delay = box.getAttribute('data-wow-delay');\r\n      iteration = box.getAttribute('data-wow-iteration');\r\n      return this.animate((function(_this) {\r\n        return function() {\r\n          return _this.customStyle(box, hidden, duration, delay, iteration);\r\n        };\r\n      })(this));\r\n    };\r\n\r\n    WOW.prototype.animate = (function() {\r\n      if ('requestAnimationFrame' in window) {\r\n        return function(callback) {\r\n          return window.requestAnimationFrame(callback);\r\n        };\r\n      } else {\r\n        return function(callback) {\r\n          return callback();\r\n        };\r\n      }\r\n    })();\r\n\r\n    WOW.prototype.resetStyle = function() {\r\n      var box, j, len, ref, results;\r\n      ref = this.boxes;\r\n      results = [];\r\n      for (j = 0, len = ref.length; j < len; j++) {\r\n        box = ref[j];\r\n        results.push(box.style.visibility = 'visible');\r\n      }\r\n      return results;\r\n    };\r\n\r\n    WOW.prototype.resetAnimation = function(event) {\r\n      var target;\r\n      if (event.type.toLowerCase().indexOf('animationend') >= 0) {\r\n        target = event.target || event.srcElement;\r\n        return target.className = target.className.replace(this.config.animateClass, '').trim();\r\n      }\r\n    };\r\n\r\n    WOW.prototype.customStyle = function(box, hidden, duration, delay, iteration) {\r\n      if (hidden) {\r\n        this.cacheAnimationName(box);\r\n      }\r\n      box.style.visibility = hidden ? 'hidden' : 'visible';\r\n      if (duration) {\r\n        this.vendorSet(box.style, {\r\n          animationDuration: duration\r\n        });\r\n      }\r\n      if (delay) {\r\n        this.vendorSet(box.style, {\r\n          animationDelay: delay\r\n        });\r\n      }\r\n      if (iteration) {\r\n        this.vendorSet(box.style, {\r\n          animationIterationCount: iteration\r\n        });\r\n      }\r\n      this.vendorSet(box.style, {\r\n        animationName: hidden ? 'none' : this.cachedAnimationName(box)\r\n      });\r\n      return box;\r\n    };\r\n\r\n    WOW.prototype.vendors = [\"moz\", \"webkit\"];\r\n\r\n    WOW.prototype.vendorSet = function(elem, properties) {\r\n      var name, results, value, vendor;\r\n      results = [];\r\n      for (name in properties) {\r\n        value = properties[name];\r\n        elem[\"\" + name] = value;\r\n        results.push((function() {\r\n          var j, len, ref, results1;\r\n          ref = this.vendors;\r\n          results1 = [];\r\n          for (j = 0, len = ref.length; j < len; j++) {\r\n            vendor = ref[j];\r\n            results1.push(elem[\"\" + vendor + (name.charAt(0).toUpperCase()) + (name.substr(1))] = value);\r\n          }\r\n          return results1;\r\n        }).call(this));\r\n      }\r\n      return results;\r\n    };\r\n\r\n    WOW.prototype.vendorCSS = function(elem, property) {\r\n      var j, len, ref, result, style, vendor;\r\n      style = getComputedStyle(elem);\r\n      result = style.getPropertyCSSValue(property);\r\n      ref = this.vendors;\r\n      for (j = 0, len = ref.length; j < len; j++) {\r\n        vendor = ref[j];\r\n        result = result || style.getPropertyCSSValue(\"-\" + vendor + \"-\" + property);\r\n      }\r\n      return result;\r\n    };\r\n\r\n    WOW.prototype.animationName = function(box) {\r\n      var animationName;\r\n      try {\r\n        animationName = this.vendorCSS(box, 'animation-name').cssText;\r\n      } catch (_error) {\r\n        animationName = getComputedStyle(box).getPropertyValue('animation-name');\r\n      }\r\n      if (animationName === 'none') {\r\n        return '';\r\n      } else {\r\n        return animationName;\r\n      }\r\n    };\r\n\r\n    WOW.prototype.cacheAnimationName = function(box) {\r\n      return this.animationNameCache.set(box, this.animationName(box));\r\n    };\r\n\r\n    WOW.prototype.cachedAnimationName = function(box) {\r\n      return this.animationNameCache.get(box);\r\n    };\r\n\r\n    WOW.prototype.scrollHandler = function() {\r\n      return this.scrolled = true;\r\n    };\r\n\r\n    WOW.prototype.scrollCallback = function() {\r\n      var box;\r\n      if (this.scrolled) {\r\n        this.scrolled = false;\r\n        this.boxes = (function() {\r\n          var j, len, ref, results;\r\n          ref = this.boxes;\r\n          results = [];\r\n          for (j = 0, len = ref.length; j < len; j++) {\r\n            box = ref[j];\r\n            if (!(box)) {\r\n              continue;\r\n            }\r\n            if (this.isVisible(box)) {\r\n              this.show(box);\r\n              continue;\r\n            }\r\n            results.push(box);\r\n          }\r\n          return results;\r\n        }).call(this);\r\n        if (!(this.boxes.length || this.config.live)) {\r\n          return this.stop();\r\n        }\r\n      }\r\n    };\r\n\r\n    WOW.prototype.offsetTop = function(element) {\r\n      var top;\r\n      while (element.offsetTop === void 0) {\r\n        element = element.parentNode;\r\n      }\r\n      top = element.offsetTop;\r\n      while (element = element.offsetParent) {\r\n        top += element.offsetTop;\r\n      }\r\n      return top;\r\n    };\r\n\r\n    WOW.prototype.isVisible = function(box) {\r\n      var bottom, offset, top, viewBottom, viewTop;\r\n      offset = box.getAttribute('data-wow-offset') || this.config.offset;\r\n      viewTop = (this.config.scrollContainer && this.config.scrollContainer.scrollTop) || window.pageYOffset;\r\n      viewBottom = viewTop + Math.min(this.element.clientHeight, this.util().innerHeight()) - offset;\r\n      top = this.offsetTop(box);\r\n      bottom = top + box.clientHeight;\r\n      return top <= viewBottom && bottom >= viewTop;\r\n    };\r\n\r\n    WOW.prototype.util = function() {\r\n      return this._util != null ? this._util : this._util = new Util();\r\n    };\r\n\r\n    WOW.prototype.disabled = function() {\r\n      return !this.config.mobile && this.util().isMobile(navigator.userAgent);\r\n    };\r\n\r\n    return WOW;\r\n\r\n  })();\r\n\r\n}).call(this);\r\n","/*global define, console, document, window*/\r\n/*jslint continue:true*/\r\n(function (root, factory) {\r\n    \"use strict\";\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(\"AffixColumn\", [\"jquery\", \"Behaviors\"], factory);\r\n    } else {\r\n        root.AffixColumn = factory(root.jQuery, root.Behaviors);\r\n    }\r\n}(this, function ($, Behaviors) {\r\n    \"use strict\";\r\n\r\n    var module = {};\r\n    \r\n    function $do(that, target) {\r\n        return function () {\r\n            target.apply(that, arguments);\r\n        };\r\n    }\r\n    \r\n    /* An Affix root is an element which is used to determine the edges of the\r\n     * region that columns stick to. It also provides the core event handlers\r\n     * to drive the AffixColumn and AffixRow behaviors.\r\n     */\r\n    function Affix(elem, scrollElem) {\r\n        Behaviors.init(Affix, this, arguments);\r\n\r\n        this.height = this.$elem.height();\r\n        this.offsetTop = this.$elem.offset().top;\r\n        \r\n        this.columns = [];\r\n        this.$scrollElem = $(scrollElem || document);\r\n        this.$scrollHeightElem = this.$scrollElem;\r\n        \r\n        //weird DOM quirk\r\n        if (this.$scrollElem[0] === document) {\r\n            this.$scrollHeightElem = $(window);\r\n        }\r\n        \r\n        this.$alwaysTopElem = $(this.$elem.data(\"affixcolumn-alwaystop\"));\r\n        this.$alwaysBottomElem = $(this.$elem.data(\"affixcolumn-alwaysbottom\"));\r\n        \r\n        this.bind_event_handlers();\r\n        this.find_columns_and_rows();\r\n        \r\n        this.resized();\r\n        this.scroll_changed();\r\n    }\r\n    \r\n    Behaviors.inherit(Affix, Behaviors.Behavior);\r\n    \r\n    Affix.QUERY = \"[data-affixcolumn='root']\";\r\n    \r\n    Affix.prototype.deinitialize = function () {\r\n        this.unbind_event_handlers();\r\n    };\r\n    \r\n    /* Check our alwaystop/alwaysbottom elements and see if they are floating.\r\n     * If so, add their height to the top and bottom adjustments given to the\r\n     * individual columns.\r\n     */\r\n    Affix.prototype.determine_global_floating_adjustment = function () {\r\n        this.globalTopAdjust = 0;\r\n        \r\n        this.$alwaysTopElem.each(function (index, atelem) {\r\n            var $atelem = $(atelem);\r\n            this.globalTopAdjust += $atelem.height();\r\n        }.bind(this));\r\n        \r\n        this.globalBottomAdjust = 0;\r\n        \r\n        this.$alwaysBottomElem.each(function (index, atelem) {\r\n            var $atelem = $(atelem);\r\n            this.globalBottomAdjust += $atelem.height();\r\n        }.bind(this));\r\n    };\r\n\r\n    Affix.prototype.resized = function () {\r\n        var i, maxColHeight = 0, maxColId, heightSum, disp = 0, topAdjust = 0, bottomAdjust = 0;\r\n        \r\n        this.determine_global_floating_adjustment();\r\n        this.height = this.$elem.height();\r\n        \r\n        if (this.columns.length > 0) {\r\n            //Scan top rows to fix their displacement heights and determine top\r\n            //adjustments.\r\n            for (i = 0; i < this.columns.length; i += 1) {\r\n                //Also, kill floating adjustments plz\r\n                this.columns[i].clear_floating_adjustments();\r\n                \r\n                if (!this.columns[i].has_option(\"top\")) {\r\n                    continue;\r\n                }\r\n                \r\n                //Top rows never get a bottom adjustment.\r\n                this.columns[i].set_floating_adjustments(this.globalTopAdjust, topAdjust, 0, 0);\r\n                \r\n                disp = this.columns[i].displacement_height();\r\n                \r\n                this.columns[i].$height_bearing_element().css(\"min-height\", disp + \"px\");\r\n                topAdjust += disp;\r\n            }\r\n            \r\n            //Scan bottom rows to fix their displacement heights and determine top\r\n            //adjustments. This is done in reverse order so that the bottommost\r\n            //bottom row gets the lowest bottom float adjustment.\r\n            for (i = this.columns.length - 1; i >= 0; i -= 1) {\r\n                if (!this.columns[i].has_option(\"bottom\")) {\r\n                    continue;\r\n                }\r\n                \r\n                //Bottom rows never get a top adjustment.\r\n                this.columns[i].set_floating_adjustments(0, 0, this.globalBottomAdjust, bottomAdjust);\r\n                \r\n                disp = this.columns[i].displacement_height();\r\n                \r\n                this.columns[i].$height_bearing_element().css(\"min-height\", disp + \"px\");\r\n                bottomAdjust += disp;\r\n            }\r\n            \r\n            //Scan columns to select the height-bearing column.\r\n            for (i = 0; i < this.columns.length; i += 1) {\r\n                if (!this.columns[i].has_option(\"column\")) {\r\n                    continue;\r\n                }\r\n                \r\n                //Columns get both the top and bottom adjustment.\r\n                this.columns[i].set_floating_adjustments(this.globalTopAdjust, topAdjust, this.globalBottomAdjust, bottomAdjust);\r\n                \r\n                //Determine which column is height bearing for this Affix.\r\n                if (maxColHeight < this.columns[i].displacement_height() &&\r\n                        !this.columns[i].has_option(\"noheightbearing\")) {\r\n                    maxColHeight = this.columns[i].displacement_height();\r\n                    maxColId = i;\r\n                }\r\n                \r\n                this.columns[i].remove_state(\"tallest\");\r\n            }\r\n            \r\n            if (maxColId !== undefined) {\r\n                this.columns[maxColId].add_state(\"tallest\");\r\n            }\r\n        }\r\n    };\r\n    \r\n    Affix.prototype.scroll_changed = function () {\r\n        var i, maxColHeight = 0, maxColId;\r\n        \r\n        this.height = this.$elem.height();\r\n        this.windowHeight = this.$scrollHeightElem.height();\r\n        this.offsetTop = this.$elem.offset().top;\r\n        this.scrollTop = this.$scrollElem.scrollTop();\r\n        this.offsetBottom = this.offsetTop + this.height;\r\n        this.scrollBottom = this.scrollTop + this.windowHeight;\r\n        \r\n        if (this.columns.length > 0) {\r\n            for (i = 0; i < this.columns.length; i += 1) {\r\n                this.columns[i].viewport_changed(this.height, this.offsetTop, this.offsetBottom, this.scrollTop, this.scrollBottom);\r\n            }\r\n        }\r\n    };\r\n    \r\n    Affix.prototype.unbind_event_handlers = function () {\r\n        if (this.scroll_handler !== undefined) {\r\n            this.$scrollElem.off(\"scroll\", this.scroll_handler);\r\n        }\r\n        \r\n        if (this.resize_handler !== undefined) {\r\n            $(window).off(\"resize\", this.resize_handler);\r\n        }\r\n    };\r\n    \r\n    Affix.prototype.bind_event_handlers = function () {\r\n        this.unbind_event_handlers();\r\n        \r\n        this.scroll_handler = $do(this, this.scroll_changed);\r\n        this.resize_handler = $do(this, this.resized);\r\n        \r\n        this.$scrollElem.on(\"scroll\", this.scroll_handler);\r\n        $(window).on(\"resize\", this.resize_handler);\r\n        $(document).on(\"load\", this.resize_handler);\r\n        $(\"img\").on(\"load\", this.resize_handler);\r\n    };\r\n    \r\n    Affix.prototype.find_columns_and_rows = function () {\r\n        var $likely_columns = this.$elem.find(AffixColumn.QUERY),\r\n            $likely_roots = this.$elem.find(Affix.QUERY);\r\n\r\n        this.columns = [];\r\n        this.roots = [];\r\n\r\n        $likely_columns.each(function (index, lcelem) {\r\n            var $lcelem = $(lcelem),\r\n                $parent_root = $lcelem.parents().filter(Affix.QUERY).first();\r\n\r\n            if ($parent_root[0] === this.$elem) {\r\n                this.columns.push(AffixColumn.locate($lcelem));\r\n            }\r\n        }.bind(this));\r\n\r\n        $likely_roots.each(function (index, lrelem) {\r\n            var $lrelem = $(lrelem),\r\n                $parent_root = $lrelem.parents().filter(Affix.QUERY).first();\r\n\r\n            if ($parent_root[0] === this.$elem) {\r\n                this.roots.push(Affix.locate($lrelem));\r\n            }\r\n        }.bind(this));\r\n    };\r\n    \r\n    /* An AffixColumn is a normally fixed element which sticks to the top or\r\n     * bottom edges of a scrolling viewport (typically the document).\r\n     * \r\n     * AffixColumn itself contains no event handlers. The parent Affix is\r\n     * responsible for propagating viewport scrolling to it's child Columns.\r\n     * \r\n     * Options may be provided which cause the Column to behave differently.\r\n     * Examples of this include the \"noheightbearing\" option, which prevents\r\n     * your AffixColumn from being marked as tallest for the purposes of parent\r\n     * element height preservation. See the parse_option_list function for more\r\n     * information on the option list format, and has_option for what options\r\n     * are available.\r\n     * \r\n     * The name \"AffixColumn\" is a misnomer. \"Columns\" may be configured as rows\r\n     * or columns in CSS. Orientation of the Column is configured with the\r\n     * column/top/bottom options. If neither is active, \"column\" is assumed.\r\n     */\r\n    function AffixColumn(elem) {\r\n        this.$elem = $(elem);\r\n        this.options = this.parse_option_list(this.$elem.data(\"affixcolumn-options\"));\r\n        \r\n        this.top_adjust = 0;\r\n        this.bottom_adjust = 0;\r\n    }\r\n    \r\n    Behaviors.inherit(AffixColumn, Behaviors.Behavior);\r\n    \r\n    AffixColumn.QUERY = \"[data-affixcolumn='column']\";\r\n    \r\n    /* Calculate the height taken up by the AffixColumn if placed in normal\r\n     * document flow.\r\n     * \r\n     * The floating adjustments currently applied to the column may cause\r\n     * invalid displacement height results to occur. For best results, call\r\n     * clear_floating_adjustments to remove them, and then trigger a viewport\r\n     * update from the Affix root once the height has been measured.\r\n     */\r\n    AffixColumn.prototype.displacement_height = function () {\r\n        return this.$elem.height();\r\n    };\r\n    \r\n    /* Change the top/bottom values that this column floats at.\r\n     * \r\n     * Floating adjustments determine the safe area of space that this element\r\n     * may float at without being overlapped or overlapping top or bottom rows.\r\n     * \r\n     * These will override any top/bottom values set via CSS.\r\n     */\r\n    AffixColumn.prototype.set_floating_adjustments = function (globalTop, top, globalBottom, bottom) {\r\n        this.top_adjust = top;\r\n        this.bottom_adjust = bottom;\r\n        \r\n        this.global_top_adjust = globalTop;\r\n        this.global_bottom_adjust = globalBottom;\r\n    };\r\n    \r\n    /* Remove inline CSS applied to make floating adjustments visually present.\r\n     * \r\n     * You must call this method before querying displacement_height, or you\r\n     * will get invalid results. After calling this method, you must trigger a\r\n     * viewport update by calling scroll_changed on the containing Affix root.\r\n     */\r\n    AffixColumn.prototype.clear_floating_adjustments = function () {\r\n        this.$elem.css(\"top\", \"\");\r\n        this.$elem.css(\"bottom\", \"\");\r\n    };\r\n    \r\n    /* Return the element responsible for propagating our displacement height in\r\n     * normal document flow.\r\n     * \r\n     * By default, the height bearing element is our parent element. We do not\r\n     * have a facility to override this currently.\r\n     */\r\n    AffixColumn.prototype.$height_bearing_element = function () {\r\n        return this.$elem.parent();\r\n    };\r\n    \r\n    AffixColumn.prototype.add_state = function (state) {\r\n        this.$elem.addClass(\"is-AffixColumn--\" + state);\r\n    };\r\n    \r\n    AffixColumn.prototype.remove_state = function (state) {\r\n        this.$elem.removeClass(\"is-AffixColumn--\" + state);\r\n    };\r\n    \r\n    /* Determine if an AffixColumn option applies given the current viewport.\r\n     * \r\n     * Valid options include:\r\n     * \r\n     *  - column: AffixColumn to be oriented vertically aside other columns.\r\n     *    The tallest column is marked as \"tallest\" and considered the height\r\n     *    bearing column, whereby it is expected to be positioned in normal\r\n     *    document flow such that the Affix element can grab it's CSS height.\r\n     * \r\n     *  - top: AffixColumn to be oriented above other columns. Top rows are\r\n     *    given a CSS min-height equal to the sum of their childrens' heights\r\n     *    and their children are assumed to float. This minimum height will be\r\n     *    applied as the top value to any following tops or columns.\r\n     *\r\n     *  - bottom: AffixColumn to be oriented below other columns. Bottom rows\r\n     *    are given a CSS min-height in the same fashion as top rows. This\r\n     *    minimum height will be applied as the bottom value to any preceding\r\n     *    bottoms or columns.\r\n     * \r\n     *  - noheightbearing: Column-oriented AffixColumn to be disqualified from\r\n     *    being marked as a height-bearing column.\r\n     */\r\n    AffixColumn.prototype.has_option = function (option_string) {\r\n        var i;\r\n        \r\n        for (i = 0; i < this.options.length; i += 1) {\r\n            if (this.options[i].media === null || window.matchMedia(this.options[i].media).matches) {\r\n                //Column enabled by default\r\n                if (option_string === \"column\" &&\r\n                        this.options[i].options.indexOf(\"top\") === -1 &&\r\n                        this.options[i].options.indexOf(\"bottom\") === -1) {\r\n                    return true;\r\n                }\r\n                \r\n                return this.options[i].options.indexOf(option_string) > -1;\r\n            }\r\n        }\r\n        \r\n        if (option_string === \"column\") {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    };\r\n    \r\n    AffixColumn.MATCH_MEDIA_QUERY_REGEX = /\\(([\\s\\S]*)\\)/g;\r\n    \r\n    /* Parse an option list.\r\n     * \r\n     * The option list determines what options are active on a column. It is\r\n     * comma separated. Each comma indicates a new option list for a particular\r\n     * media query. The first media query to match determines the total option\r\n     * set. The final option set may or may not have a media query; if it does\r\n     * not, then it serves as the default option set.\r\n     * \r\n     * This is very analagous to the sizes attribute of <img> tags in modern\r\n     * browsers. Example format:\r\n     * \r\n     *    (min-width: 450px) column noheightbearing, top\r\n     */\r\n    AffixColumn.prototype.parse_option_list = function (option_list_string) {\r\n        var cases, i, j, rval = [], case_obj = {}, match;\r\n        \r\n        if (option_list_string === undefined) {\r\n            option_list_string = \"\";\r\n        }\r\n        \r\n        cases = option_list_string.split(\",\");\r\n        \r\n        for (i = 0; i < cases.length; i += 1) {\r\n            case_obj = {};\r\n            match = this.constructor.MATCH_MEDIA_QUERY_REGEX.exec(cases[i]);\r\n            \r\n            //Reset the string. Sharing regex objects is dirty...\r\n            this.constructor.MATCH_MEDIA_QUERY_REGEX.lastIndex = 0;\r\n            \r\n            if (match === null || match.length === 0) {\r\n                case_obj.options = cases[i].split(\" \");\r\n                case_obj.media = null;\r\n            } else {\r\n                case_obj.options = cases[i].slice(match[0]).split(\" \");\r\n                case_obj.media = match[0];\r\n            }\r\n            \r\n            //Filter empty options\r\n            for (j = 0; j < case_obj.options.length; j += 0) {\r\n                if (case_obj.options[j] === \"\") {\r\n                    case_obj.options.splice(j, 1);\r\n                } else {\r\n                    j += 1;\r\n                }\r\n            }\r\n            \r\n            rval.push(case_obj);\r\n        }\r\n        \r\n        return rval;\r\n    };\r\n    \r\n    /* Internal method used by Affix to communicate to it's children the new\r\n     * parameters of the scroll viewport.\r\n     */\r\n    AffixColumn.prototype.viewport_changed = function (rootHeight, offsetTop, offsetBottom, scrollTop, scrollBottom) {\r\n        var isTopAnchored = this.has_option(\"column\") || this.has_option(\"top\"),\r\n            isBottomAnchored = this.has_option(\"anchorbottom\") || this.has_option(\"bottom\"),\r\n            bottomStateAdjust = true,\r\n            topStateAdjust = true,\r\n            adjustWithoutGlobal = true;\r\n        \r\n        //Remove existing floating adjustments.\r\n        //Otherwise, our displacement height is incorrect.\r\n        this.clear_floating_adjustments();\r\n        \r\n        //Apply affix states.\r\n        if (isTopAnchored && scrollTop + this.global_top_adjust < offsetTop ||\r\n                isBottomAnchored && scrollBottom - this.displacement_height() < offsetTop) {\r\n            this.add_state(\"top\");\r\n            this.remove_state(\"bottom\");\r\n            bottomStateAdjust = false;\r\n        } else if (isTopAnchored && scrollTop + this.top_adjust + this.global_top_adjust + this.displacement_height() + this.bottom_adjust >= offsetBottom ||\r\n                isBottomAnchored && scrollBottom >= offsetBottom) {\r\n            this.remove_state(\"top\");\r\n            this.add_state(\"bottom\");\r\n            topStateAdjust = false;\r\n        } else {\r\n            this.remove_state(\"top\");\r\n            this.remove_state(\"bottom\");\r\n            adjustWithoutGlobal = false;\r\n        }\r\n        \r\n        //Apply floating adjustments.\r\n        if ((this.has_option(\"column\") || this.has_option(\"top\")) && topStateAdjust) {\r\n            if (adjustWithoutGlobal) {\r\n                this.$elem.css(\"top\", this.top_adjust + \"px\");\r\n            } else {\r\n                this.$elem.css(\"top\", this.top_adjust + this.global_top_adjust + \"px\");\r\n            }\r\n        }\r\n        \r\n        if ((this.has_option(\"column\") || this.has_option(\"bottom\")) && bottomStateAdjust) {\r\n            if (adjustWithoutGlobal) {\r\n                this.$elem.css(\"bottom\", this.bottom_adjust + \"px\");\r\n            } else {\r\n                this.$elem.css(\"bottom\", this.bottom_adjust + this.global_bottom_adjust + \"px\");\r\n            }\r\n        }\r\n    };\r\n    \r\n    Behaviors.register_behavior(Affix);\r\n\r\n    module.Affix = Affix;\r\n    module.AffixColumn = AffixColumn;\r\n\r\n    return module;\r\n}));\r\n","/*global define, console, document, window*/\n(function (root, factory) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(\"Animations\", [\"jquery\", \"Behaviors\"], factory);\n    } else {\n        root.Animations = factory(root.jQuery, root.Behaviors);\n    }\n}(this, function ($, Behaviors) {\n    \"use strict\";\n    \n    var module = {};\n\n    /* Watches for the start and end of an animation.\n     *\n     * The .promise attribute stores a promise which resolves whenever the\n     * animation has completed or no animation events were detected over a\n     * timeout period of 5 second.\n     *\n     * An important caveat: Animations with delay longer than 5 seconds will\n     * fail to fire events and the animation watcher will trigger the timeout\n     * behavior instead. You can avoid this behavior by triggering another\n     * animation of any kind during the timeout period and keeping it alive\n     * until the delayed animation begins.\n     */\n    function AnimationWatcher($elem) {\n        var Class = this.constructor,\n            eventSelector = Class.get_unique_id(),\n            that = this,\n            evtStartNames = \"animationstart.\" + eventSelector +\n                      \" webkitAnimationStart.\" + eventSelector +\n                      \" oanimationstart.\" + eventSelector +\n                      \" MSAnimationStart.\" + eventSelector,\n            evtEndNames = \"animationend.\" + eventSelector +\n                      \" webkitAnimationEnd.\" + eventSelector +\n                      \" oanimationend.\" + eventSelector +\n                      \" MSAnimationEnd.\" + eventSelector,\n            animation_start = this.animation_start.bind(this),\n            animation_end = this.animation_end.bind(this),\n            animation_timeout_delay = 5000;\n\n        this.eventSelector = eventSelector;\n\n        this.$elem = $elem;\n        this.$elem.on(evtStartNames, animation_start);\n        this.$elem.on(evtEndNames, animation_end);\n\n        if (window.Modernizr && window.Modernizr.cssanimations === false) {\n            animation_timeout_delay = 0;\n        }\n\n        this.timeout = window.setTimeout(this.abort_animation.bind(this), animation_timeout_delay);\n        this.remaining_animations = [];\n\n        //We remove event handlers after one of the handlers resolves the\n        //animation promise.\n        this.promise = new Promise(function (resolve, reject) {\n            that.resolve = resolve;\n            that.reject = reject;\n        }).then(function () {\n            that.$elem.off(evtStartNames, animation_start);\n            that.$elem.off(evtEndNames, animation_end);\n        });\n\n        console.log(\"ANIMATIONWATCHER\" + this.eventSelector + \": Created\");\n    }\n\n    AnimationWatcher.count = 0;\n\n    AnimationWatcher.get_unique_id = function () {\n        var Class = this,\n            sel = \".\" + Class.name + \"_\" + Class.count;\n\n        Class.count += 1;\n        return sel;\n    };\n\n    AnimationWatcher.prototype.animation_start = function (evt) {\n        console.log(\"ANIMATIONWATCHER\" + this.eventSelector + \": Begun (\" + evt.originalEvent.animationName + \")\");\n        if (this.timeout !== null) {\n            window.clearTimeout(this.timeout);\n            this.timeout = null;\n        }\n\n        this.remaining_animations.push(evt.originalEvent.animationName);\n    };\n\n    AnimationWatcher.prototype.animation_end = function (evt) {\n        var loc = this.remaining_animations.indexOf(evt.originalEvent.animationName);\n\n        console.log(\"ANIMATIONWATCHER\" + this.eventSelector + \": Ended (\" + evt.originalEvent.animationName + \")\");\n\n        if (loc !== -1) {\n            this.remaining_animations.splice(loc, 1);\n        }\n\n        if (this.remaining_animations.length === 0) {\n            this.resolve();\n        }\n    };\n\n    AnimationWatcher.prototype.abort_animation = function (evt) {\n        console.log(\"ANIMATIONWATCHER\" + this.eventSelector + \": Abort timeout triggered\");\n\n        if (this.remaining_animations.length === 0) {\n            this.resolve();\n        }\n    };\n\n    module.AnimationWatcher = AnimationWatcher;\n\n    return module;\n}));\n","/*global define, console, document, window*/\r\n(function (root, factory) {\r\n    \"use strict\";\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(\"CollapseContent\", [\"jquery\", \"Behaviors\"], factory);\r\n    } else {\r\n        root.CollapseContent = factory(root.jQuery, root.Behaviors);\r\n    }\r\n}(this, function ($, Behaviors) {\r\n    \"use strict\";\r\n\r\n    var module = {};\r\n\r\n    function $do(that, target) {\r\n        return function () {\r\n            target.apply(that, arguments);\r\n        };\r\n    }\r\n\r\n    function CollapseContentRegion(elem) {\r\n        Behaviors.init(CollapseContentRegion, this, arguments);\r\n\r\n        this.$elem = $(elem);\r\n        this.visible = this.$elem.data(\"collapsecontent-region-visible\") !== undefined;\r\n\r\n        this.update_classes();\r\n    }\r\n\r\n    Behaviors.inherit(CollapseContentRegion, Behaviors.Behavior);\r\n\r\n    CollapseContentRegion.QUERY = \"[data-collapsecontent-region]\";\r\n\r\n    CollapseContentRegion.prototype.update_classes = function () {\r\n        this.$elem.find(\"[data-collapsecontent-body]\").each(function (index, body_elem) {\r\n            if (this.visible) {\r\n                $(body_elem).addClass(\"is-CollapseContent--visible\");\r\n                $(body_elem).removeClass(\"is-CollapseContent--hidden\");\r\n            } else {\r\n                $(body_elem).removeClass(\"is-CollapseContent--visible\");\r\n                $(body_elem).addClass(\"is-CollapseContent--hidden\");\r\n            }\r\n        }.bind(this));\r\n\r\n        this.$elem.find(\"[data-collapsecontent-trigger]\").each(function (index, trigger_elem) {\r\n            if (this.visible) {\r\n                $(trigger_elem).addClass(\"is-CollapseContent--visible\");\r\n                $(trigger_elem).removeClass(\"is-CollapseContent--hidden\");\r\n            } else {\r\n                $(trigger_elem).removeClass(\"is-CollapseContent--visible\");\r\n                $(trigger_elem).addClass(\"is-CollapseContent--hidden\");\r\n            }\r\n        }.bind(this));\r\n    };\r\n\r\n    CollapseContentRegion.prototype.make_visible = function () {\r\n        this.visible = true;\r\n        this.update_classes();\r\n    };\r\n\r\n    CollapseContentRegion.prototype.make_hidden = function () {\r\n        this.visible = false;\r\n        this.update_classes();\r\n    };\r\n\r\n    CollapseContentRegion.prototype.toggle = function () {\r\n        this.visible = !this.visible;\r\n        this.update_classes();\r\n\r\n        // Fire custom event when toggles are activated\r\n        newEvent = new $.Event({\r\n            \"type\": \"collapsecontent-toggle\",\r\n            \"visible\": this.visible,\r\n            \"target\": this.$elem,\r\n        });\r\n\r\n        this.$elem.trigger(newEvent);\r\n    };\r\n\r\n    function CollapseContentTrigger(elem) {\r\n        Behaviors.init(CollapseContentTrigger, this, arguments);\r\n\r\n        this.$elem = $(elem);\r\n\r\n        if (this.$elem.data(\"collapsecontent-trigger\") !== undefined) {\r\n            //Mode 1: Trigger explicitly specifies region to toggle.\r\n            this.region = this.set_region($(this.$elem.data(\"collapsecontent-trigger\"))[0]);\r\n        } else if (this.$elem.attr(\"href\") !== undefined) {\r\n            //Mode 1: Trigger explicitly specifies region to toggle, as an href..\r\n            this.region = this.set_region($(this.$elem.data(\"collapsecontent-trigger\"))[0]);\r\n        }\r\n\r\n        if (this.region === undefined) {\r\n            //Mode 2: Find parent element that qualifies as a region.\r\n            this.region = this.set_region(this.$elem.parents().filter(CollapseContentRegion.QUERY)[0]);\r\n        }\r\n\r\n        if (this.region === undefined) {\r\n            console.error(\"There is a CollapseContent trigger that neither points to a valid region nor is a child of a valid region..\");\r\n        }\r\n\r\n        this.$elem.on(\"click\", this.toggle_intent.bind(this));\r\n    }\r\n\r\n    Behaviors.inherit(CollapseContentTrigger, Behaviors.Behavior);\r\n\r\n    CollapseContentTrigger.QUERY = \"[data-collapsecontent-trigger]\";\r\n\r\n    CollapseContentTrigger.prototype.set_region = function (elem) {\r\n        if (elem === undefined) {\r\n            return;\r\n        }\r\n\r\n        return CollapseContentRegion.locate(elem);\r\n    };\r\n\r\n    CollapseContentTrigger.prototype.toggle_intent = function (evt) {\r\n        if (evt) {\r\n            evt.preventDefault();\r\n        }\r\n        \r\n        this.region.toggle();\r\n    };\r\n\r\n    Behaviors.register_behavior(CollapseContentRegion);\r\n    Behaviors.register_behavior(CollapseContentTrigger);\r\n\r\n    module.CollapseContentRegion = CollapseContentRegion;\r\n    module.CollapseContentTrigger = CollapseContentTrigger;\r\n\r\n    return module;\r\n}));\r\n","/* Paginate.js\r\n * A progressively-enhancing infinite scroll library\r\n * ©2014 HUEMOR Designs All Rights Reserved\r\n */\r\n\r\n/*global jQuery, define, console, window, document*/\r\n(function (root, factory) {\r\n    \"use strict\";\r\n    if (typeof define === 'function' && define.amd) {\r\n        define('depaginate', ['jquery', \"Behaviors\"], factory);\r\n    } else if (root.jQuery) {\r\n        root.PaginateJS = factory(root.jQuery, root.Behaviors);\r\n    } else {\r\n        console.error(\"No jQuery found. Load jQuery before this module or use an AMD-compliant loader.\");\r\n    }\r\n}(this, function ($, Behaviors) {\r\n    \"use strict\";\r\n    \r\n    var module = {};\r\n    \r\n    function Pager(elem, page_select_handler) {\r\n        Behaviors.init(Pager, this, arguments);\r\n        \r\n        this.links = {};\r\n        this.current = null;\r\n        this.$pager = $(elem);\r\n        this.min_page_count = Infinity;\r\n        this.max_page_count = 0;\r\n        \r\n        this.$pager.addClass(\"is-Paginate--managed\");\r\n\r\n        this.page_select_handler = page_select_handler;\r\n\r\n        this.features = this.$pager.data(\"paginate-features\");\r\n\r\n        if (this.features === undefined) {\r\n            this.features = \"replaceState\";\r\n        }\r\n\r\n        console.log(\"Pager Features:\" + this.features);\r\n        this.features = this.features.split(\" \");\r\n    }\r\n    \r\n    Behaviors.inherit(Pager, Behaviors.Behavior);\r\n    \r\n    Pager.QUERY = \"[data-paginate='pager']\";\r\n    \r\n    Pager.DEFAULT_LINK = {\r\n        \"loaded\": false,\r\n        \"requested\": false,\r\n        \"pending\": false,\r\n        \"current\": false\r\n    };\r\n    \r\n    Pager.prototype.is_page_loaded = function (pagenumber) {\r\n        return this.links[pagenumber].loaded;\r\n    };\r\n    \r\n    Pager.prototype.set_current_page = function (pagenumber) {\r\n        var i = 0, pageid;\r\n        \r\n        if (this.current === pagenumber) {\r\n            return;\r\n        }\r\n        \r\n        this.current = pagenumber;\r\n        this.links[pagenumber] = this.links[pagenumber] || $.extend({}, Pager.DEFAULT_LINK);\r\n        \r\n        for (pageid in this.links) {\r\n            if (this.links.hasOwnProperty(pageid)) {\r\n                this.links[pageid].current = pageid === pagenumber;\r\n            }\r\n        }\r\n        \r\n        if (this.links[pagenumber].$pagerContents !== undefined) {\r\n            this.$pager.children().detach();\r\n            this.$pager.append(this.links[pagenumber].$pagerContents);\r\n        }\r\n        \r\n        if (this.links[pagenumber].href !== undefined) {\r\n            if (this.features.indexOf(\"replaceState\") > -1 && window.history.replaceState) {\r\n                window.history.replaceState({transition: true, url: this.links[pagenumber].href}, \"\", this.links[pagenumber].href);\r\n            }\r\n        }\r\n    };\r\n    \r\n    Pager.prototype.read_pager = function (pagerElem) {\r\n        var $newPager = $(pagerElem),\r\n            pagerThis = this;\r\n        \r\n        $newPager.find(\"[data-paginate='page']\").each(function (index, pageElem) {\r\n            var $newPage = $(pageElem),\r\n                page = $newPage.data(\"paginate-page\"),\r\n                isCurrent = $newPage.data(\"paginate-current\") !== undefined,\r\n                href = $newPage.attr(\"href\");\r\n            \r\n            pagerThis.links[page] = pagerThis.links[page] || $.extend({}, Pager.DEFAULT_LINK);\r\n            \r\n            pagerThis.links[page].href = href || pagerThis.links[page].href;\r\n            pagerThis.links[page].current = isCurrent;\r\n            \r\n            if (isCurrent) {\r\n                pagerThis.current = page;\r\n            }\r\n            \r\n            if (pagerThis.links[page].pending) {\r\n                pagerThis.load_page(page);\r\n            }\r\n            \r\n            if (page > pagerThis.max_page_count) {\r\n                pagerThis.max_page_count = page;\r\n            }\r\n            \r\n            if (page < pagerThis.min_page_count) {\r\n                pagerThis.min_page_count = page;\r\n            }\r\n\r\n            $newPage.on(\"click\", function (evt) {\r\n                evt.preventDefault();\r\n\r\n                if (pagerThis.page_select_handler) {\r\n                    pagerThis.page_select_handler(pagerThis, page);\r\n                }\r\n            });\r\n        });\r\n        \r\n        this.links[this.current] = this.links[this.current] || $.extend({}, Pager.DEFAULT_LINK);\r\n        this.links[this.current].$pagerContents = $newPager.children();\r\n        \r\n        if (this.links[this.current].$pagerContents !== undefined) {\r\n            this.$pager.children().detach();\r\n            this.$pager.append(this.links[this.current].$pagerContents);\r\n        }\r\n    };\r\n    \r\n    Pager.prototype.load_page = function (pagenumber, on_success, on_failure) {\r\n        var paginateThis = this;\r\n        \r\n        if (this.links[pagenumber] === undefined || this.links[pagenumber].href === undefined) {\r\n            this.links[pagenumber] = $.extend({}, this.links[pagenumber], Pager.DEFAULT_LINK);\r\n            this.links[pagenumber].pending = true;\r\n            this.links[pagenumber].on_success = on_success || this.links[pagenumber].on_success;\r\n            this.links[pagenumber].on_failure = on_failure || this.links[pagenumber].on_failure;\r\n            \r\n            return;\r\n        }\r\n        \r\n        if (this.links[pagenumber].requested || this.links[pagenumber].loaded) {\r\n            return;\r\n        }\r\n        \r\n        this.links[pagenumber].pending = false;\r\n        this.links[pagenumber].requested = true;\r\n        \r\n        $.ajax({\r\n            \"url\": this.links[pagenumber].href,\r\n            \"dataType\": \"html\"\r\n        }).done(function (data, textStatus, jqXHR) {\r\n            if (paginateThis.links[pagenumber].on_success !== undefined) {\r\n                paginateThis.links[pagenumber].on_success(data, textStatus, jqXHR);\r\n            }\r\n            \r\n            if (on_success !== undefined) {\r\n                on_success(data, textStatus, jqXHR);\r\n            }\r\n            \r\n            paginateThis.links[pagenumber].loaded = true;\r\n        }).fail(function (jqXHR, textStatus, errorThrown) {\r\n            if (paginateThis.links[pagenumber].on_failure !== undefined) {\r\n                paginateThis.links[pagenumber].on_failure(jqXHR, textStatus, errorThrown);\r\n            }\r\n            \r\n            if (on_failure !== undefined) {\r\n                on_failure(jqXHR, textStatus, errorThrown);\r\n            }\r\n        });\r\n    };\r\n    \r\n    Pager.prototype.is_first_page = function (test_page) {\r\n        return (test_page !== null && test_page === this.min_page_count);\r\n    };\r\n    \r\n    Pager.prototype.is_last_page = function (test_page) {\r\n        return (test_page !== null && test_page === this.max_page_count);\r\n    };\r\n    \r\n    module.Pager = Pager;\r\n    \r\n    function Region(elem, on_region_scrolled) {\r\n        var $extantRegion = $(elem);\r\n        Behaviors.init(Region, this, arguments);\r\n        \r\n        this.name = $extantRegion.data(\"paginate-region\");\r\n\r\n        this.load_methods = $extantRegion.data(\"paginate-methods\");\r\n\r\n        if (this.load_methods === undefined) {\r\n            this.load_methods = \"scroll\";\r\n        }\r\n\r\n        console.log(\"LoadMethods:\" + this.load_methods);\r\n        this.load_methods = this.load_methods.split(\" \");\r\n\r\n        this.features = $extantRegion.data(\"paginate-features\");\r\n\r\n        if (this.features === undefined) {\r\n            this.features = \"scrollOnLoad\";\r\n        }\r\n\r\n        console.log(\"Region Features:\" + this.features);\r\n        this.features = this.features.split(\" \");\r\n        \r\n        this.pages = {};\r\n        this.pagenumbers = [];\r\n        \r\n        this.min_page_loaded = Infinity;\r\n        this.max_page_loaded = 0;\r\n        \r\n        this.$region = $extantRegion;\r\n        \r\n        this.$parentScroller = null;\r\n        this.lastScrollTop = 0;\r\n        \r\n        this.on_region_scrolled = on_region_scrolled;\r\n        \r\n        this.$region.addClass(\"is-Paginate--managed\");\r\n    }\r\n    \r\n    Behaviors.inherit(Region, Behaviors.Behavior);\r\n    \r\n    Region.QUERY = \"[data-paginate='region']\";\r\n    \r\n    /* Called to append a new page to the region.\r\n     * \r\n     * Region contents will be extracted from the given region element and\r\n     * appended to the existing region, such that any existing content belonging\r\n     * to pages marked with a lower page number will appear before your page\r\n     * content, and any existing content belonging to pages marked with a higher\r\n     * page number will appear after your page content.\r\n     * \r\n     * Already inserted pages will not be reinserted into the region.\r\n     * \r\n     * As this function inserts content into the page, it will be presented to\r\n     * Behaviors to ensure any Behaviors on the new page content can locate\r\n     * correctly.\r\n     * \r\n     * An event will be fired from the region's element called depaginate_load\r\n     * which serves to indicate when a new page has loaded. Do not use this\r\n     * event to check if new content has been added to the page, use Behaviors'\r\n     * register_behavior or register_content_listener functions instead. This\r\n     * event will be called before behaviors have been located on their\r\n     * elements.\r\n     */\r\n    Region.prototype.read_page_region = function (pageNumber, regionElem) {\r\n        var $newRegion = $(regionElem),\r\n            itemSelector = $newRegion.data(\"paginate-selector\") || \"> *\",\r\n            prevPageNumberId = 0,\r\n            nextPageNumberId = this.pagenumbers.length,\r\n            nextPageNumber,\r\n            prevPageNumber,\r\n            pageAlreadyExists = false,\r\n            i = 0,\r\n            $newItems = $newRegion.find(itemSelector),\r\n            $firstItem = $newItems.first(),\r\n            $lastItem = $newItems.last(),\r\n            oldPageTop = 0,\r\n            newPageTop = 0,\r\n            evt;\r\n        \r\n        if (this.firstVisiblePage !== undefined) {\r\n            oldPageTop = this.page_top_position(this.firstVisiblePage);\r\n        }\r\n\r\n        for (i = 0; i < this.pagenumbers.length; i += 1) {\r\n            if (this.pagenumbers[i] < pageNumber) {\r\n                prevPageNumberId = i;\r\n                prevPageNumber = this.pagenumbers[i];\r\n            } else if (this.pagenumbers[i] === pageNumber) {\r\n                pageAlreadyExists = true;\r\n            } else {\r\n                nextPageNumber = this.pagenumbers[i];\r\n                nextPageNumberId = i;\r\n                break;\r\n            }\r\n        }\r\n        \r\n        if (!pageAlreadyExists) {\r\n            this.pagenumbers.splice(nextPageNumberId, 0, pageNumber);\r\n            \r\n            if (this.pages[prevPageNumber] !== undefined) {\r\n                $newItems = $newItems.insertAfter(this.pages[prevPageNumber].$lastItem);\r\n            } else if (this.pages[nextPageNumber] !== undefined) {\r\n                $newItems = $newItems.insertBefore(this.pages[nextPageNumber].$firstItem);\r\n            } //else do nothing since this obviously must be the original region\r\n            \r\n            $firstItem = $newItems.first();\r\n            $lastItem = $newItems.last();\r\n            \r\n            this.pages[pageNumber] = this.pages[pageNumber] || {};\r\n            this.pages[pageNumber].$newItems = $newItems;\r\n            this.pages[pageNumber].$firstItem = $firstItem;\r\n            this.pages[pageNumber].$lastItem = $lastItem;\r\n\r\n            evt = jQuery.Event(\"depaginate_load\");\r\n            evt.region = this;\r\n            evt.target = this.$region[0];\r\n            evt.$newItems = $newItems;\r\n\r\n            this.$region.trigger(evt);\r\n            \r\n            Behaviors.content_ready($newItems);\r\n        }\r\n        \r\n        if (pageNumber < this.min_page_loaded) {\r\n            this.min_page_loaded = pageNumber;\r\n        }\r\n        \r\n        if (pageNumber > this.max_page_loaded) {\r\n            this.max_page_loaded = pageNumber;\r\n        }\r\n\r\n        if (this.firstVisiblePage !== undefined) {\r\n            newPageTop = this.page_top_position(this.firstVisiblePage);\r\n\r\n            if (this.features.indexOf(\"scrollOnLoad\") > -1) {\r\n                window.setTimeout(\r\n                    this.scroll_by_delta.bind(this, newPageTop - oldPageTop),\r\n                    50\r\n                );\r\n            }\r\n        }\r\n    };\r\n    \r\n    Region.prototype.register_scroll_handler = function () {\r\n        var cssOverflowX,\r\n            regionThis = this;\r\n        \r\n        if (this.$parentScroller !== null) {\r\n            this.$parentScroller.off(\"scroll.paginate\");\r\n        }\r\n\r\n        this.$parentScroller = this.$region;\r\n\r\n        while (this.$parentScroller.length !== 0 && this.$parentScroller.get(0) !== document) {\r\n            cssOverflowX = this.$parentScroller.css(\"overflow-x\");\r\n\r\n            if (cssOverflowX === \"visible\" || cssOverflowX === \"hidden\") {\r\n                this.$parentScroller = this.$parentScroller.parent();\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        \r\n        regionThis.on_scroll({\"target\": this.$parentScroller[0]});\r\n        this.$parentScroller.on(\"scroll.paginate\", function (evt) {\r\n            regionThis.on_scroll(evt);\r\n        });\r\n\r\n        this.lastScrollTop = this.$parentScroller.scrollTop();\r\n    };\r\n    \r\n    Region.prototype.on_scroll = function (evt) {\r\n        var $target = $(evt.target),\r\n            scrollTop = $target.scrollTop(),\r\n            scrollBottom = scrollTop + (evt.target !== document ? $target.height() : $(window).height()),\r\n            targetTop = evt.target !== document ? $target.position().top : 0,\r\n            targetAdjust = evt.target !== document ? scrollTop : 0,\r\n            i = 0,\r\n            firstVisibleTop = null,\r\n            firstVisiblePage = null,\r\n            lastVisiblePage = null,\r\n            lastVisibleBottom = null,\r\n            scrollDelta = scrollTop - this.lastScrollTop,\r\n            stopOuterLoopSentinel = false,\r\n            regionThis = this;\r\n        \r\n        this.lastScrollTop = scrollDelta;\r\n        \r\n        function pageEach(index, itemElem) {\r\n            var $itemElem = $(itemElem),\r\n                itemTop = targetAdjust + $itemElem.position().top - targetTop,\r\n                itemBottom = itemTop + $itemElem.height(),\r\n                isVisible = (scrollTop <= itemTop && itemTop <= scrollBottom) ||\r\n                            (scrollTop <= itemBottom && itemBottom <= scrollBottom) ||\r\n                            (itemTop <= scrollTop && scrollBottom <= itemBottom);\r\n            \r\n            if (!isVisible) {\r\n                if (lastVisiblePage !== null) {\r\n                    stopOuterLoopSentinel = true;\r\n                }\r\n\r\n                return true;\r\n            }\r\n\r\n            if (firstVisiblePage === null) {\r\n                firstVisiblePage = regionThis.pagenumbers[i];\r\n                firstVisibleTop = itemTop;\r\n            }\r\n            \r\n            lastVisiblePage = regionThis.pagenumbers[i];\r\n            lastVisibleBottom = itemTop + $itemElem.height();\r\n\r\n            return false;\r\n        }\r\n        \r\n        //Determine what pages are visible now\r\n        if (this.pagenumbers.length === 0) {\r\n            console.log(\"There are no page numbers.\");\r\n        }\r\n        \r\n        for (i = 0; i < this.pagenumbers.length; i += 1) {\r\n            if (this.pages[this.pagenumbers[i]].$newItems === 0) {\r\n                console.log(\"There are no pages within page \" + this.pagenumbers[i]);\r\n            }\r\n            \r\n            this.pages[this.pagenumbers[i]].$newItems.each(pageEach);\r\n            \r\n            if (stopOuterLoopSentinel) {\r\n                stopOuterLoopSentinel = false;\r\n                break;\r\n            }\r\n        }\r\n        \r\n        if (firstVisiblePage === null) {\r\n            console.log(\"First visible page did NOT get set. Dropping the scroll event.\");\r\n            return;\r\n        }\r\n        \r\n        this.firstVisiblePage = firstVisiblePage;\r\n        this.lastVisiblePage = lastVisiblePage;\r\n        this.firstVisibleTop = firstVisibleTop;\r\n        this.lastVisibleBottom = lastVisibleBottom;\r\n\r\n        if (this.load_methods.indexOf(\"scroll\") > -1) {\r\n            this.on_region_scrolled(this, scrollTop, scrollBottom, scrollDelta, firstVisiblePage, lastVisiblePage, firstVisibleTop, lastVisibleBottom);\r\n        }\r\n    };\r\n    \r\n    Region.prototype.first_loaded_page = function () {\r\n        return this.min_page_loaded;\r\n    };\r\n    \r\n    Region.prototype.last_loaded_page = function () {\r\n        return this.max_page_loaded;\r\n    };\r\n    \r\n    Region.prototype.set_additional_content_indicators = function (has_next_page, has_prev_page) {\r\n        if (has_next_page) {\r\n            this.$region.addClass(\"is-Paginate--has_next_page\");\r\n            this.$region.removeClass(\"is-Paginate--no_next_page\");\r\n        } else {\r\n            this.$region.removeClass(\"is-Paginate--has_next_page\");\r\n            this.$region.addClass(\"is-Paginate--no_next_page\");\r\n        }\r\n        \r\n        if (has_prev_page) {\r\n            this.$region.addClass(\"is-Paginate--has_prev_page\");\r\n            this.$region.removeClass(\"is-Paginate--no_prev_page\");\r\n        } else {\r\n            this.$region.removeClass(\"is-Paginate--has_prev_page\");\r\n            this.$region.addClass(\"is-Paginate--no_prev_page\");\r\n        }\r\n    };\r\n    \r\n    /* Returns the position of the top of a particular page.\r\n     */\r\n    Region.prototype.page_top_position = function (pagenumber) {\r\n        var page = this.pages[pagenumber],\r\n            $firstItem,\r\n            measuredOffset,\r\n            $parentScroller = this.$parentScroller,\r\n            scrollerOffset = 0,\r\n            encounteredScroller = false;\r\n        \r\n        if (page === undefined) {\r\n            console.log(\"Missing page: \" + pagenumber);\r\n            console.log(this.pages);\r\n            \r\n            if (pagenumber < this.min_page_loaded || pagenumber === null) {\r\n                pagenumber = this.min_page_loaded;\r\n            }\r\n            \r\n            if (pagenumber > this.max_page_loaded) {\r\n                pagenumber = this.max_page_loaded;\r\n            }\r\n            \r\n            page = this.pages[pagenumber];\r\n        }\r\n        \r\n        $firstItem = page.$firstItem;\r\n        measuredOffset = $firstItem.offset().top;\r\n        if ($parentScroller[0] !== document) {\r\n            scrollerOffset = $parentScroller.offset().top;\r\n        }\r\n        \r\n        return measuredOffset - scrollerOffset;\r\n    };\r\n    \r\n    /* Scroll the region by a particular delta. */\r\n    Region.prototype.scroll_by_delta = function (scrollDelta) {\r\n        var $parentScroller = this.$parentScroller;\r\n        \r\n        $parentScroller.scrollTop($parentScroller.scrollTop() + scrollDelta);\r\n    };\r\n    \r\n    Region.prototype.scroll_absolutely = function (scrollAbs) {\r\n        var $parentScroller = this.$parentScroller;\r\n        \r\n        $parentScroller.scrollTop(scrollAbs);\r\n    };\r\n    \r\n    module.Region = Region;\r\n    \r\n    function Paginate(elem) {\r\n        var $extantPager = $(elem).find(Pager.QUERY),\r\n            $extantRegions = $(elem).find(Region.QUERY),\r\n            currentPage = $(elem).data(\"paginate-page\"),\r\n            paginateThis = this;\r\n        \r\n        Behaviors.init(Paginate, this, arguments);\r\n        \r\n        if ($extantPager.length === 0) {\r\n            console.error(\"No pager was found in this paginage instance.\");\r\n            return;\r\n        }\r\n        \r\n        if (this.$elem.attr('id') === undefined) {\r\n            console.error(\"This paginate needs an id before it can be used.\");\r\n            return;\r\n        }\r\n        \r\n        console.log(\"page: \" + currentPage);\r\n        \r\n        this.$context = $(elem);\r\n        this.id = this.$context.attr(\"id\");\r\n        \r\n        function pshClosure() {\r\n            paginateThis.page_select_handler.apply(paginateThis, arguments);\r\n        }\r\n\r\n        this.pager = Pager.locate($extantPager.get(0), pshClosure);\r\n        \r\n        if ($extantPager.data(\"paginate-count\") === 1) {\r\n            console.log(\"Not activating depaginate on a region with only one page.\");\r\n            return;\r\n        }\r\n        \r\n        this.pager.set_current_page(currentPage);\r\n        this.pager.read_pager($extantPager.get(0));\r\n        \r\n        this.regions = {};\r\n        this.regionNames = [];\r\n        \r\n        this.currentPage = currentPage;\r\n        \r\n        function orsClosure() {\r\n            paginateThis.on_region_scrolled.apply(paginateThis, arguments);\r\n        }\r\n        \r\n        this.features = $extantPager.data(\"paginate-features\");\r\n\r\n        if (this.features === undefined) {\r\n            this.features = \"backScroll\";\r\n        }\r\n\r\n        console.log(\"Paginate Features:\" + this.features);\r\n        this.features = this.features.split(\" \");\r\n\r\n        $extantRegions.each(function (index, elem) {\r\n            var $extantRegion = $(elem),\r\n                regionName = $extantRegion.data(\"paginate-region\"),\r\n                region,\r\n                currentPage = paginateThis.currentPage;\r\n            \r\n            console.log(\"page: \" + currentPage);\r\n            \r\n            function scrollBack() {\r\n                console.log(\"Scrolling back the user to \" + region.page_top_position(currentPage) + \" (page: \" + currentPage + \")\");\r\n                region.scroll_absolutely(region.page_top_position(currentPage));\r\n            }\r\n            \r\n            paginateThis.regionNames.push(regionName);\r\n            \r\n            region = paginateThis.regions[regionName] || Region.locate(elem, orsClosure);\r\n            paginateThis.regions[regionName] = region;\r\n            \r\n            region.read_page_region(currentPage, elem);\r\n            region.register_scroll_handler();\r\n            \r\n            paginateThis.update_region_indicators(region);\r\n            \r\n            if (!paginateThis.pager.is_first_page(currentPage) && paginateThis.features.indexOf(\"backScroll\") > -1) {\r\n                //User pressed back button, scroll the region into view\r\n                \r\n                $(document).ready(scrollBack);\r\n                $(window).on(\"load\", function () {\r\n                    window.setTimeout(scrollBack, 1500);\r\n                });\r\n            }\r\n        });\r\n    }\r\n    \r\n    Behaviors.inherit(Paginate, Behaviors.Behavior);\r\n    \r\n    Paginate.QUERY = \"[data-paginate='paginate']\";\r\n    \r\n    Paginate.prototype.page_load_success = function (data, textStatus, jqXHR) {\r\n        var $data = $(data),\r\n            i = 0,\r\n            $dataPaginate,\r\n            $dataRegion,\r\n            $dataPager,\r\n            region = null,\r\n            paginateThis = this,\r\n            next_page = 0;\r\n\r\n        $dataPaginate = $data.find(\"#\" + this.id);\r\n        \r\n        if ($dataPaginate.length === 0) {\r\n            $dataPaginate = $data.filter(\"#\" + this.id);\r\n        }\r\n        \r\n        if ($dataPaginate.length === 0) {\r\n            console.error(\"DEPAGINATE: The paginate context with ID \" + this.id + \" could not be found in the loaded page. Errors may result.\");\r\n        }\r\n        \r\n        next_page = $dataPaginate.data(\"paginate-page\");\r\n\r\n        for (i = 0; i < this.regionNames.length; i += 1) {\r\n            $dataRegion = $dataPaginate.find(\"[data-paginate-region='\" + this.regionNames[i] + \"']\");\r\n\r\n            if ($dataRegion.length > 0) {\r\n                region = this.regions[this.regionNames[i]];\r\n                region.read_page_region(next_page, $dataRegion[0]);\r\n            }\r\n        }\r\n\r\n        $dataPager = $dataPaginate.find(Pager.QUERY);\r\n        $dataPager.each(function (index, pagerElem) {\r\n            paginateThis.pager.read_pager(pagerElem);\r\n        });\r\n\r\n        this.pager.set_current_page(next_page);\r\n        this.update_region_indicators(region);\r\n    };\r\n\r\n    Paginate.prototype.page_select_handler = function (pager, pagenumber) {\r\n        var paginateThis = this;\r\n        if (this.pager.is_page_loaded(pagenumber)) {\r\n            return;\r\n        }\r\n\r\n        function on_success() {\r\n            paginateThis.page_load_success.apply(paginateThis, arguments);\r\n        }\r\n\r\n        this.pager.load_page(pagenumber, on_success);\r\n    };\r\n\r\n    Paginate.prototype.on_region_scrolled = function (region, scrollTop, scrollBottom, scrollDelta, firstVisiblePage, lastVisiblePage, firstVisibleTop, lastVisibleBottom) {\r\n        var visible_range = lastVisibleBottom - firstVisibleTop,\r\n            visible_pagerange = lastVisiblePage - firstVisiblePage,\r\n            average_page_size = visible_range / visible_pagerange,\r\n            scroll_direction_down = scrollDelta > 0,\r\n            should_load_page,\r\n            next_page,\r\n            paginateThis = this;\r\n        \r\n        function on_success() {\r\n            paginateThis.page_load_success.apply(paginateThis, arguments);\r\n        }\r\n        \r\n        if (scroll_direction_down) {\r\n            should_load_page = scrollBottom + scrollDelta >= lastVisibleBottom;\r\n            next_page = lastVisiblePage + 1;\r\n            \r\n            this.pager.set_current_page(lastVisiblePage);\r\n        } else {\r\n            should_load_page = scrollTop + scrollDelta < firstVisibleTop;\r\n            next_page = firstVisiblePage - 1;\r\n            \r\n            this.pager.set_current_page(firstVisiblePage);\r\n        }\r\n        \r\n        if (next_page < 0) {\r\n            return;\r\n        }\r\n        \r\n        if (should_load_page) {\r\n            this.pager.load_page(next_page, on_success);\r\n        }\r\n    };\r\n    \r\n    Paginate.prototype.update_region_indicators = function (region) {\r\n        region.set_additional_content_indicators(\r\n            !this.pager.is_last_page(region.last_loaded_page()),\r\n            !this.pager.is_first_page(region.first_loaded_page())\r\n        );\r\n    };\r\n    \r\n    module.Paginate = Paginate;\r\n    \r\n    Behaviors.register_behavior(Paginate);\r\n    \r\n    return module;\r\n}));","/*global define,google,Promise*/\r\n(function (root, factory) {\r\n    \"use strict\";\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(\"GoogleMap\", [\"jquery\", \"Behaviors\"], factory);\r\n    } else {\r\n        root.GoogleMap = factory(root.jQuery, root.Behaviors);\r\n    }\r\n}(this, function ($, Behaviors) {\r\n    \"use strict\";\r\n    \r\n    var module = {};\r\n    \r\n    function GoogleMap() {\r\n        Behaviors.init(GoogleMap, this, arguments);\r\n        \r\n        this.load_gmaps().then(this.render_map.bind(this));\r\n    }\r\n    \r\n    Behaviors.inherit(GoogleMap, Behaviors.Behavior);\r\n    \r\n    GoogleMap.QUERY = \"[data-googlemap]\";\r\n    \r\n    GoogleMap.prototype.center_specified_by_markup = function () {\r\n        return this.$elem.data(\"googlemap-lat\") !== undefined && this.$elem.data(\"googlemap-lng\") !== undefined;\r\n    };\r\n    \r\n    GoogleMap.prototype.determine_default_args = function () {\r\n        var args = {\r\n            center: {lat: 0, lng: 0},\r\n            mapTypeId: google.maps.MapTypeId.ROADMAP,\r\n            disableDefaultUI: true,\r\n            draggable: false,\r\n            scrollwheel: false,\r\n            zoom: 15\r\n        };\r\n        \r\n        if (this.$elem.data(\"googlemap-draggable\") !== undefined) {\r\n            args.draggable = true;\r\n        }\r\n        \r\n        if (this.$elem.data(\"googlemap-scrollzoom\") !== undefined) {\r\n            args.scrollwheel = true;\r\n        }\r\n        \r\n        if (this.center_specified_by_markup()) {\r\n            args.center = {lat: this.$elem.data(\"googlemap-lat\"),\r\n                           lng: this.$elem.data(\"googlemap-lng\")};\r\n        }\r\n        \r\n        if (this.$elem.data(\"googlemap-zoom\") !== undefined) {\r\n            args.zoom = this.$elem.data(\"googlemap-zoom\");\r\n        }\r\n        \r\n        return args;\r\n    };\r\n    \r\n    GoogleMap.prototype.load_gmaps = function () {\r\n        return Promise.resolve().then(function () {\r\n            if (window.google) {\r\n                return;\r\n            } else {\r\n                //TODO: Autoload Gmaps API\r\n                throw new Error(\"Google Maps API not loaded at time of initialization.\");\r\n            }\r\n        });\r\n    };\r\n    \r\n    GoogleMap.prototype.render_map = function () {\r\n        var $markers = this.$elem.find('[data-googlemap-marker]'), i;\r\n        \r\n        // create map\r\n        this.map = new google.maps.Map(this.$elem[0], this.determine_default_args());\r\n        \r\n        this.map.markers = [];\r\n        for (i = 0; i < $markers.length; i += 1) {\r\n            this.add_marker($($markers[i]), this.map);\r\n        }\r\n        \r\n        // center map\r\n        this.center_map();\r\n    };\r\n    \r\n    GoogleMap.prototype.add_marker = function ($marker) {\r\n        var latlng = new google.maps.LatLng($marker.data('googlemap-lat'), $marker.data('googlemap-lng')),\r\n            marker = new google.maps.Marker({\r\n                position: latlng,\r\n                map: this.map\r\n            }),\r\n            infowindow;\r\n        \r\n        this.map.markers.push(marker);\r\n        \r\n        // if marker contains HTML, add it to an infoWindow\r\n        if ($marker.html()) {\r\n            infowindow = new google.maps.InfoWindow({\r\n                content\t\t: $marker.html()\r\n            });\r\n            \r\n            google.maps.event.addListener(marker, 'click', this.marker_click_intent.bind(this, marker, infowindow));\r\n        }\r\n    };\r\n    \r\n    GoogleMap.prototype.marker_click_intent = function (marker, infowindow) {\r\n        infowindow.open(this.map, marker);\r\n    };\r\n    \r\n    GoogleMap.prototype.center_map = function () {\r\n        var i, marker, latlng, bounds = new google.maps.LatLngBounds();\r\n        \r\n        // loop through all markers and create bounds\r\n        for (i = 0; i < this.map.markers.length; i += 1) {\r\n            marker = this.map.markers[i];\r\n            latlng = new google.maps.LatLng(marker.position.lat(), marker.position.lng());\r\n            bounds.extend(latlng);\r\n        }\r\n        \r\n        if (!this.center_specified_by_markup()) {\r\n            if (this.map.markers.length === 1) {\r\n                this.map.setCenter(bounds.getCenter());\r\n            } else {\r\n                this.map.fitBounds(bounds);\r\n            }\r\n        }\r\n    };\r\n    \r\n    Behaviors.register_behavior(GoogleMap);\r\n    \r\n    module.GoogleMap = GoogleMap;\r\n    \r\n    return module;\r\n}));","/*global define, console*/\r\n/*jslint bitwise: true */\r\n/* updated 9/14/2016 */\r\n\r\nif (!Array.prototype.indexOf) {\r\n    Array.prototype.indexOf = function (elt) { /*, from*/\r\n        \"use strict\";\r\n        var len = this.length >>> 0, from = Number(arguments[1]) || 0, derparam;\r\n        from = (from < 0) ? Math.ceil(from) : Math.floor(from);\r\n        if (from < 0) {\r\n            from += len;\r\n        }\r\n\r\n        for (derparam; from < len; from += 1) {\r\n            if (from in this && this[from] === elt) {\r\n                return from;\r\n            }\r\n        }\r\n        return -1;\r\n    };\r\n}\r\n\r\n(function (root, factory) {\r\n    \"use strict\";\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(\"betteroffcanvas\", [\"jquery\"], factory);\r\n    } else {\r\n        // Browser globals\r\n        root.betteroffcanvas = factory(root.jQuery);\r\n    }\r\n}(this, function ($) {\r\n    //BetterOffcanvas\r\n    //Works like this:\r\n    /*\r\n    *  <button type=\"button\" data-toggle=\"offcanvas\" data-target=\"#any-selector\">\r\n    */\r\n\r\n    \"use strict\";\r\n\r\n    var $openTarget = null, currentLevel = 0, module = {}, isInDebounce = false,\r\n        target_has_touch = false,\r\n        focus_click_inquiry = false, click_keydown_inquiry = false,\r\n        eligibleTouches = {},\r\n        logger;\r\n    \r\n    /* Logger that throws away all data (default)\r\n     */\r\n    function null_logging() {\r\n        return;\r\n    }\r\n    \r\n    /* Logger that sends all logged data to the JS console.\r\n     */\r\n    function console_logging(log_data) {\r\n        return console.log(log_data);\r\n    }\r\n    \r\n    function switchLoggingMode(mode) {\r\n        switch (mode) {\r\n        case \"console\":\r\n            logger = console_logging;\r\n            break;\r\n        default:\r\n            logger = null_logging;\r\n            break;\r\n        }\r\n    }\r\n    \r\n    //Inform the user they can enable console logging\r\n    console.log(\"Offcanvas: You can enable detailed event logging by typing betteroffcanvas.switchLoggingMode('console').\");\r\n    switchLoggingMode(\"null\");\r\n\r\n    function initOffcanvasToggle($theToggle) {\r\n        var $theTarget = $($theToggle.data(\"target\")), toggleOptions = $theToggle.data(\"toggle-options\"),\r\n            state;\r\n\r\n        if ($theTarget.data(\"offcanvas-state\") === undefined) {\r\n            $theTarget.data(\"offcanvas-state\", {\"open\": false, \"parents\": null, \"$openChild\": null, \"openChildLvl\": 0, \"toggleOptions\": []});\r\n        }\r\n\r\n        state = $theTarget.data(\"offcanvas-state\");\r\n\r\n        if (state.toggleOptions === undefined) {\r\n            state.toggleOptions = [];\r\n        }\r\n\r\n        if (toggleOptions !== undefined) {\r\n            state.toggleOptions.push.apply(state.toggleOptions, toggleOptions.split(\" \"));\r\n        }\r\n\r\n        $theTarget.data(\"offcanvas-state\", state);\r\n\r\n        return $theTarget;\r\n    }\r\n\r\n    function findParentLevels($theTarget) {\r\n        var parents = [], tgtState = $theTarget.data(\"offcanvas-state\");\r\n\r\n        if (tgtState.parents === null) {\r\n            $theTarget.parents().each(function (index, pelem) {\r\n                var $pelem = $(pelem),\r\n                    parState = $pelem.data(\"offcanvas-state\"),\r\n                    $parTgl;\r\n\r\n                if (parState === undefined) {\r\n                    if ($pelem.attr(\"id\") !== undefined) {\r\n                        $parTgl = $(\"[data-toggle='offcanvas'][data-target='#\" + $pelem.attr(\"id\") + \"']\");\r\n                        if ($parTgl.length > 0) {\r\n                            initOffcanvasToggle($parTgl);\r\n                            parents.push(pelem);\r\n                        }\r\n                    }\r\n                } else {\r\n                    parents.push(pelem);\r\n                }\r\n            });\r\n\r\n            tgtState.parents = parents;\r\n            $theTarget.data(\"offcanvas-state\", tgtState);\r\n\r\n            $(tgtState.parents).each(function (index, pelem) {\r\n                findParentLevels($(pelem));\r\n            });\r\n        }\r\n    }\r\n\r\n    function initOffcanvas($theTarget, toggleOptions) {\r\n        if (toggleOptions === undefined) {\r\n            toggleOptions = [];\r\n        }\r\n        \r\n        if ($theTarget.data(\"offcanvas-state\") === undefined) {\r\n            $theTarget.data(\"offcanvas-state\", {\"open\": false, \"parents\": null, \"$openChild\": null, \"openChildLvl\": 0, \"toggleOptions\": toggleOptions});\r\n        }\r\n\r\n        findParentLevels($theTarget);\r\n    }\r\n\r\n    function isOffcanvas($theTargetList) {\r\n        var truth = true;\r\n\r\n        $theTargetList.each(function (index, elem) {\r\n            var $theTarget = $(elem), $toggles;\r\n\r\n            if ($theTarget.data(\"offcanvas-state\") !== undefined) {\r\n                truth = truth & true;\r\n                return;\r\n            }\r\n\r\n            $toggles = $(\"[data-toggle='offcanvas'][data-target='#\" + $theTarget.attr(\"id\") + \"']\");\r\n\r\n            if ($toggles.length > 0) {\r\n                initOffcanvas($theTarget);\r\n\r\n                $toggles.each(function (index, elem) {\r\n                    initOffcanvasToggle($(elem));\r\n                });\r\n\r\n                truth &= true;\r\n                return;\r\n            }\r\n\r\n            truth &= false;\r\n        });\r\n\r\n        return truth;\r\n    }\r\n\r\n    function isChildOffcanvas($theTarget, $potentialParent) {\r\n        if (!isOffcanvas($theTarget) || !isOffcanvas($potentialParent)) {\r\n            return false;\r\n        }\r\n\r\n        if ($theTarget.data(\"offcanvas-state\").parents.indexOf($potentialParent[0]) === -1) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function isTopLevelOffcanvas($theTarget) {\r\n        return isOffcanvas($theTarget) && $theTarget.data(\"offcanvas-state\").parents.length === 0;\r\n    }\r\n\r\n    function updateBackdrop(newLevel, openTargetList) {\r\n        var $backdropDivs = $(\"[data-offcanvas-backdrop]\");\r\n\r\n        $backdropDivs.each(function (index, bdElem) {\r\n            var $bdElem = $(bdElem),\r\n                bdLevel = $bdElem.data(\"offcanvas-backdrop\"),\r\n                bdFor = $bdElem.data(\"offcanvas-backdrop-for\");\r\n\r\n            if (bdFor !== undefined && openTargetList.indexOf(bdFor) === -1) {\r\n                $bdElem.removeClass(\"is-Offcanvas--backdrop_active\");\r\n                $bdElem.addClass(\"is-Offcanvas--backdrop_inactive\");\r\n            } else if (newLevel >= bdLevel) {\r\n                $bdElem.addClass(\"is-Offcanvas--backdrop_active\");\r\n                $bdElem.removeClass(\"is-Offcanvas--backdrop_inactive\");\r\n            } else {\r\n                $bdElem.removeClass(\"is-Offcanvas--backdrop_active\");\r\n                $bdElem.addClass(\"is-Offcanvas--backdrop_inactive\");\r\n            }\r\n        });\r\n\r\n        currentLevel = newLevel;\r\n    }\r\n\r\n    function scanChildrenWithinLevel($theTarget, cbk) {\r\n        $theTarget.each(function (index, elem) {\r\n            var $elem = $(elem);\r\n\r\n            if (isOffcanvas($elem)) {\r\n                return;\r\n            }\r\n\r\n            cbk($elem);\r\n            scanChildrenWithinLevel($elem.children(), cbk);\r\n        });\r\n    }\r\n\r\n    function setFocusableWithinLevel($theTarget, isFocusable) {\r\n        if (isFocusable === undefined) {\r\n            isFocusable = true;\r\n        }\r\n\r\n        logger(\"changing focus state to \" + isFocusable);\r\n\r\n        scanChildrenWithinLevel($theTarget.children(), function ($elem) {\r\n            if ($elem.data(\"offcanvas-tabindex\") === undefined) {\r\n                //Determine if this element should be focusable or not...\r\n                if ($elem.attr(\"tabindex\") !== undefined) {\r\n                    $elem.data(\"offcanvas-tabindex\", $elem.attr(\"offcanvas-tabindex\"));\r\n                } else {\r\n                    $elem.data(\"offcanvas-tabindex\", null);\r\n                }\r\n            }\r\n\r\n            if (isFocusable) {\r\n                if ($elem.data(\"offcanvas-tabindex\") === null) {\r\n                    $elem.removeAttr(\"tabindex\");\r\n                } else {\r\n                    $elem.attr(\"tabindex\", $elem.data(\"offcanvas-tabindex\"));\r\n                }\r\n            } else {\r\n                $elem.attr(\"tabindex\", -1);\r\n            }\r\n        });\r\n    }\r\n\r\n    function openOffcanvas($theTarget, $theToggle, eventType, isRecursive, recursiveCount) {\r\n        var tgtState, $pelem, parState, newLevel = 1, i, targetIDs = [], $topElem, topState, newEvent;\r\n        if ($theTarget !== null && $theTarget !== undefined) {\r\n            logger(\"Open Offcanvas \" + $theTarget.attr(\"id\"));\r\n        } else {\r\n            logger(\"Open Offcanvas (no target)\");\r\n        }\r\n\r\n        if ($theTarget === null) {\r\n            return;\r\n        }\r\n        tgtState = $theTarget.data(\"offcanvas-state\");\r\n\r\n        if (recursiveCount === undefined) {\r\n            recursiveCount = 1;\r\n        }\r\n\r\n        $theTarget.addClass(\"is-Offcanvas--open\");\r\n        $theTarget.removeClass(\"is-Offcanvas--closed\");\r\n        tgtState.open = true;\r\n        tgtState.open_event = eventType;\r\n        $theTarget.data(\"offcanvas-state\", tgtState);\r\n\r\n        $(\"[data-toggle='offcanvas'][data-target='#\" + $theTarget.attr(\"id\") + \"']\").addClass(\"is-Offcanvas--target_open\");\r\n\r\n        setFocusableWithinLevel($theTarget, true);\r\n\r\n        if (tgtState.parents.length > 0) {\r\n            $pelem = $(tgtState.parents[0]);\r\n\r\n            parState = $pelem.data(\"offcanvas-state\");\r\n            parState.$openChild = $theTarget;\r\n            parState.openChildLvl = recursiveCount;\r\n            $pelem.data(\"offcanvas-state\", parState);\r\n\r\n            $pelem.addClass(\"is-Offcanvas--open_sublvl_\" + recursiveCount);\r\n\r\n            openOffcanvas($pelem, $theToggle, eventType, true, recursiveCount + 1);\r\n\r\n            newLevel = newLevel + tgtState.parents.length;\r\n\r\n            $topElem = $(tgtState.parents[tgtState.parents.length - 1]);\r\n            if ($topElem.length > 0) {\r\n                topState = $topElem.data(\"offcanvas-state\");\r\n\r\n                if (topState !== undefined) {\r\n                    if (topState.childDepthLvl !== undefined) {\r\n                        $topElem.removeClass(\"is-Offcanvas--depth_\" + topState.childDepthLvl);\r\n                    }\r\n\r\n                    topState.childDepthLvl = tgtState.parents.length;\r\n                    $topElem.addClass(\"is-Offcanvas--depth_\" + topState.childDepthLvl);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (isRecursive !== true) {\r\n            targetIDs.push($theTarget.attr(\"id\"));\r\n\r\n            for (i = 0; i < tgtState.parents.length; i += 1) {\r\n                targetIDs.push(tgtState.parents[i].getAttribute(\"id\"));\r\n            }\r\n\r\n            updateBackdrop(newLevel, targetIDs);\r\n        }\r\n\r\n        $openTarget = $theTarget;\r\n\r\n        newEvent = new $.Event({\r\n            \"type\": \"offcanvas-open\",\r\n            \"target\": $theTarget,\r\n            \"toggle\": $theToggle,\r\n            \"from_child\": isRecursive,\r\n            \"children_count\": recursiveCount\r\n        });\r\n        $theTarget.trigger(newEvent);\r\n    }\r\n    \r\n    /* Determine if a user-triggered event is allowed to dismiss an offcanvas\r\n     * or not.\r\n     * \r\n     * This function is consistenly called before dismissOffcanvas in order to\r\n     * gate event-driven dismissals consistently. Programmatic dismissals (e.g.\r\n     * by third-party code or for clearing the way for the next offcanvas) are\r\n     * NOT gated in the same way.\r\n     * \r\n     * To gate dismissals in the same fashion, call this function with the\r\n     * following four parameters:\r\n     * \r\n     *  - $_openTarget: The currently open offcanvas at the start of event\r\n     *                 processing. Specify false to automatically select the\r\n     *                 current open target. Specify undefined for no open\r\n     *                 target.\r\n     * \r\n     *  - $newTarget:  The new offcanvas that you plan to open at the end of\r\n     *                 event processing.\r\n     * \r\n     *  - evt:         The event that triggered your current event processing.\r\n     *                 Your code is expected to filter mobile emulation events\r\n     *                 such as emulated click-after-touchend through some means\r\n     *                 so that this function can differentiate between the two.\r\n     * \r\n     *  - $evtToggle:  The element which triggered the event. May be a\r\n     *                 data-toggle or data-dismiss element. This is not,\r\n     *                 strictly speaking, evt.target: client code is allowed and\r\n     *                 expected to traverse the parents of the target to find,\r\n     *                 say, the button containing the actual event target.\r\n     * \r\n     * In the event of recieving false from this function, event handlers should\r\n     * cease any event processing which would cause the open target to be\r\n     * dismissed, including opening other offcanvas hierarchies as that will\r\n     * implicitly dismiss the current one.\r\n     */\r\n    function eventCanDismissOffcanvas($_openTarget, $newTarget, evt, $evtToggle) {\r\n        var openTargetState = {\"toggleOptions\": []}, openTargetIsNoHover = false,\r\n            openTargetWasHovered = false,\r\n            targetsAreIdentical = false,\r\n            evtFromToggle = false, evtFromDismiss = false,\r\n            evtWithinOpenTarget = false,\r\n            evtToggleOptions, evtToggleIsNoHover = false,\r\n            evtToggleTargetsOpenTarget = false,\r\n            hasNewTarget,\r\n            hasOpenTarget,\r\n            hasEventToggle;\r\n        \r\n        if ($_openTarget === false) {\r\n            $_openTarget = $openTarget;\r\n        }\r\n        \r\n        hasNewTarget = $newTarget !== undefined && $newTarget !== null && $newTarget.length >= 1;\r\n        hasOpenTarget = $_openTarget !== undefined && $_openTarget !== null && $_openTarget.length >= 1;\r\n        hasEventToggle = $evtToggle !== undefined && $evtToggle !== null && $evtToggle.length >= 1;\r\n        \r\n        if (hasOpenTarget) {\r\n            openTargetState = $_openTarget.data(\"offcanvas-state\");\r\n            openTargetIsNoHover = openTargetState.toggleOptions.indexOf(\"nohover\") > -1;\r\n            openTargetWasHovered = openTargetState.open_event === \"mouseover\";\r\n            \r\n            if (evt.target) {\r\n                evtWithinOpenTarget = $_openTarget[0] === evt.target || $.contains($_openTarget[0], evt.target);\r\n            }\r\n        } else {\r\n            logger(\"Dismissals are always allowed if no offcanvas is open\");\r\n            return true;\r\n        }\r\n        \r\n        if (hasNewTarget) {\r\n            targetsAreIdentical = $_openTarget[0] === $newTarget[0];\r\n        }\r\n        \r\n        if (hasEventToggle) {\r\n            evtFromToggle = $evtToggle.filter(\"[data-toggle='offcanvas']\").length > 0 ||\r\n                            $evtToggle.parents().filter(\"[data-toggle='offcanvas']\").length > 0;\r\n            evtFromDismiss = $evtToggle.filter(\"[data-dismiss='offcanvas']\").length > 0 ||\r\n                             $evtToggle.parents().filter(\"[data-dismiss='offcanvas']\").length > 0;\r\n            \r\n            evtToggleOptions = $evtToggle.data(\"toggle-options\");\r\n            if (evtToggleOptions !== undefined) {\r\n                evtToggleOptions = evtToggleOptions.split(\" \");\r\n            } else {\r\n                evtToggleOptions = [];\r\n            }\r\n            \r\n            evtToggleIsNoHover = evtToggleOptions.indexOf(\"nohover\") > -1;\r\n            evtToggleTargetsOpenTarget = $evtToggle.data(\"target\") === \"#\" + $_openTarget.attr(\"id\");\r\n        }\r\n        \r\n        //Dismissals by toggling the same target\r\n        if (evt.type === \"click\" && openTargetWasHovered) {\r\n            if (targetsAreIdentical) {\r\n                logger(\"Not going to allow dismiss from click on already hovered nav.\");\r\n                return false;\r\n            }\r\n        }\r\n        \r\n        if (evt.type === \"focusin\") {\r\n            if (targetsAreIdentical) { //TODO: should this be evtWithinOpenTarget?\r\n                logger(\"Not going to allow dismiss from focusin within same target\");\r\n                return false;\r\n            }\r\n            \r\n            if (!hasNewTarget && (evtFromToggle || evtFromDismiss)) {\r\n                logger(\"Ignoring focus-dismiss due to the fact that event target is an offcanvas toggle.\");\r\n                logger(\"Currently focused off-canvas element: \" + $_openTarget.attr(\"id\"));\r\n                return false;\r\n            }\r\n        }\r\n        \r\n        if (evt.type === \"mouseover\" && !evtWithinOpenTarget) {\r\n            if (evtFromDismiss) {\r\n                logger(\"Not going to allow dismiss until user actually clicks hovered dismiss button.\");\r\n                return false;\r\n            } else if (evtToggleIsNoHover || openTargetIsNoHover) {\r\n                logger(\"Not going to allow dismiss as toggle is nohover.\");\r\n                return false;\r\n            } else if (evtFromToggle && targetsAreIdentical) {\r\n                logger(\"Not going to allow dismiss as toggle is for current offcanvas.\");\r\n                return false;\r\n            }\r\n        }\r\n        \r\n        return true;\r\n    }\r\n\r\n    function dismissOffcanvas($theTarget, numLvls) {\r\n        var tgtState = $theTarget.data(\"offcanvas-state\"), newLvl = -1, i, targetIDs = [], $topElem, topState, newEvent;\r\n\r\n        if ($theTarget !== null && $theTarget !== undefined) {\r\n            logger(\"Dismiss Offcanvas \" + $theTarget.attr(\"id\"));\r\n        } else {\r\n            logger(\"Dismiss Offcanvas (no target)\");\r\n        }\r\n\r\n        if (numLvls === undefined) {\r\n            /* NumLvls is the number of recursion levels (children being auto-dismissed) */\r\n            numLvls = 1;\r\n\r\n            $topElem = $(tgtState.parents[tgtState.parents.length - 1]);\r\n            if ($topElem.length > 0) {\r\n                topState = $topElem.data(\"offcanvas-state\");\r\n\r\n                if (topState !== undefined) {\r\n                    if (topState.childDepthLvl !== undefined) {\r\n                        $topElem.removeClass(\"is-Offcanvas--depth_\" + topState.childDepthLvl);\r\n                    }\r\n\r\n                    topState.childDepthLvl = tgtState.parents.length - 1;\r\n                    $topElem.addClass(\"is-Offcanvas--depth_\" + topState.childDepthLvl);\r\n                }\r\n            }\r\n        }\r\n\r\n        $theTarget.removeClass(\"is-Offcanvas--open\");\r\n        $theTarget.addClass(\"is-Offcanvas--closed\");\r\n        tgtState.open = false;\r\n        tgtState.open_event = undefined;\r\n        $theTarget.data(\"offcanvas-state\", tgtState);\r\n\r\n        $(\"[data-toggle='offcanvas'][data-target='#\" + $theTarget.attr(\"id\") + \"']\").removeClass(\"is-Offcanvas--target_open\");\r\n\r\n        newEvent = new $.Event({\r\n            \"type\": \"offcanvas-dismiss\",\r\n            \"target\": $theTarget\r\n        });\r\n        $theTarget.trigger(newEvent);\r\n\r\n        //TODO: How do we actually tell if the offcanvas is visible when closed?\r\n        //(e.g. desktop nav)\r\n        if (!isTopLevelOffcanvas($theTarget)) {\r\n            if ($theTarget !== null) {\r\n                logger(\"Marking non-top-level offcanvas nav \" + $theTarget.attr(\"id\") + \" as untabbable\");\r\n            }\r\n            setFocusableWithinLevel($theTarget, false);\r\n        }\r\n\r\n        if (tgtState.$openChild !== null) {\r\n            dismissOffcanvas(tgtState.$openChild, numLvls + 1);\r\n        } else {\r\n            if (tgtState.parents.length > 0) {\r\n                $openTarget = $(tgtState.parents[numLvls - 1]);\r\n                if ($openTarget.length === 0) {\r\n                    $openTarget = null;\r\n                }\r\n\r\n                $(tgtState.parents).each(function (index, pelem) {\r\n                    var $pelem = $(pelem), parState = $pelem.data(\"offcanvas-state\"), childlvl, newChildLvl = parState.openChildLvl - numLvls;\r\n\r\n                    $pelem.removeClass(\"is-Offcanvas--open_sublvl_\" + parState.openChildLvl);\r\n                    if (newChildLvl > 0) {\r\n                        $pelem.addClass(\"is-Offcanvas--open_sublvl_\" + newChildLvl);\r\n                    } else {\r\n                        parState.$openChild = null;\r\n                    }\r\n\r\n                    parState.openChildLvl = newChildLvl;\r\n                    $pelem.data(\"offcanvas-state\", parState);\r\n\r\n                    if (newChildLvl > newLvl) {\r\n                        newLvl = newChildLvl;\r\n                    }\r\n                });\r\n            } else {\r\n                $openTarget = null;\r\n                newLvl = -1;\r\n            }\r\n\r\n            for (i = 0; i < tgtState.parents.length; i += 1) {\r\n                targetIDs.push(tgtState.parents[i].getAttribute(\"id\"));\r\n            }\r\n\r\n            updateBackdrop(newLvl + 1, targetIDs);\r\n        }\r\n    }\r\n\r\n    function dismissOpenOffcanvas() {\r\n        if ($openTarget !== null) {\r\n            dismissOffcanvas($openTarget);\r\n        }\r\n    }\r\n\r\n    function enableDebounce() {\r\n        if (!isInDebounce) {\r\n            logger(\"Debounce timeout enabled\");\r\n            isInDebounce = true;\r\n            window.setTimeout(function () {\r\n                logger(\"Debounce timeout expired - event processing will resume\");\r\n                isInDebounce = false;\r\n            }, 100);\r\n        }\r\n    }\r\n\r\n    $(document).on(\"keydown\", function (evt) {\r\n        if (evt.keyCode === 27) {\r\n            dismissOpenOffcanvas();\r\n        } else if (evt.keyCode === 13) {\r\n            logger(\"Keydown event - ENTER. Disabling link clickthrough for the next click event.\");\r\n            click_keydown_inquiry = true; //mark that the following click event is\r\n                                        //from a keyboard\r\n        }\r\n    });\r\n\r\n    $(document).on(\"ready\", function (evt) {\r\n        var openIDs = [], openState, i;\r\n\r\n        if ($openTarget !== null) {\r\n            openState = $openTarget.data(\"offcanvas-state\");\r\n\r\n            for (i = 0; i < openState.parents.length; i += 1) {\r\n                openIDs.push(openState.parents[i].getAttribute(\"id\"));\r\n            }\r\n\r\n            updateBackdrop(currentLevel, openIDs);\r\n        }\r\n    });\r\n\r\n    function on_focusin(evt) {\r\n        var $tgt = $(evt.target), $tgtOffcanvas = null,\r\n            $tgtParents = $tgt.parents(), $toggleTarget,\r\n            dismissAllowed;\r\n\r\n        $tgtParents.each(function (index, elem) {\r\n            if ($tgtOffcanvas === null) {\r\n                if (isOffcanvas($(elem))) {\r\n                    $tgtOffcanvas = $(elem);\r\n                }\r\n            }\r\n        });\r\n\r\n        if (isInDebounce) {\r\n            logger(\"Processed event (debounced, type: focusin)\");\r\n            return;\r\n        }\r\n        \r\n        if ($tgt.data(\"toggle\") === \"offcanvas\") {\r\n            $toggleTarget = $($tgt.data(\"target\"));\r\n            if (!isTopLevelOffcanvas($toggleTarget)) {\r\n                if ($toggleTarget !== null) {\r\n                    logger(\"Marking non-top-level offcanvas nav \" + $toggleTarget.attr(\"id\") + \" as untabbable\");\r\n                }\r\n                setFocusableWithinLevel($toggleTarget, false);\r\n            }\r\n        }\r\n        \r\n        if (!eventCanDismissOffcanvas($openTarget, $tgtOffcanvas, evt, $tgt)) {\r\n            return;\r\n        }\r\n\r\n        if ($tgtOffcanvas === null && $openTarget !== null) {\r\n            logger(\"Focused on something outside of off-canvas nav \" + $openTarget.attr(\"id\"));\r\n            logger($tgt);\r\n\r\n            enableDebounce(); //prevent subsequent click event handlers from tripping\r\n\r\n            while ($openTarget !== null) {\r\n                dismissOpenOffcanvas();\r\n            }\r\n        } else {\r\n            if ($tgtOffcanvas !== null) {\r\n                logger(\"Focused inside off-canvas nav \" + $tgtOffcanvas.attr(\"id\"));\r\n            }\r\n\r\n            if ($openTarget !== null) {\r\n                enableDebounce(); //prevent subsequent click event handlers from tripping\r\n\r\n                while ($openTarget !== null && !isChildOffcanvas($tgtOffcanvas, $openTarget)) {\r\n                    logger(\"Dismissing off-canvas menu \" + $openTarget.attr(\"id\"));\r\n                    dismissOffcanvas($openTarget);\r\n                }\r\n            }\r\n            openOffcanvas($tgtOffcanvas, $tgt, evt.type);\r\n        }\r\n    }\r\n    \r\n    //Track a specific set of focus events to ensure they don't result in a\r\n    //click.\r\n    $(document).on(\"focusin\", function (evt) {\r\n        logger(evt.type);\r\n\r\n        focus_click_inquiry = true;\r\n\r\n        window.setTimeout(function () {\r\n            if (focus_click_inquiry) { //e.g. if a click event hasn't happened\r\n                on_focusin(evt);\r\n            }\r\n        }, 300);\r\n    });\r\n    \r\n    //Activate touch-specific behaviors if we have ever recieved a touch event.\r\n    $(document).on(\"touchstart touchend touchmove touchcancel\", function (evt) {\r\n        target_has_touch = true;\r\n    });\r\n    \r\n    /* Track the starting position of every touch we get. */\r\n    $(document).on(\"touchstart\", function (evt) {\r\n        var i, touch;\r\n        \r\n        for (i = 0; i < evt.originalEvent.changedTouches.length; i += 1) {\r\n            touch = evt.originalEvent.changedTouches.item(i);\r\n            eligibleTouches[touch.identifier] = {\r\n                \"x\": touch.screenX,\r\n                \"y\": touch.screenY\r\n            };\r\n        }\r\n    });\r\n    \r\n    /* Track and remove touches which have become drags.\r\n     * Assumes a minimum drag distance of 15px.\r\n     * Returns true if any of the given touches are still eligible.\r\n     */\r\n    function testAndPruneTouchList(changedTouches) {\r\n        var i, touch, stTouch, dist, MAX_DIST = 15, num_valid_touches = 0;\r\n        \r\n        for (i = 0; i < changedTouches.length; i += 1) {\r\n            touch = changedTouches.item(i);\r\n            \r\n            if (eligibleTouches.hasOwnProperty(touch.identifier)) {\r\n                stTouch = eligibleTouches[touch.identifier];\r\n                dist = Math.sqrt(Math.pow((touch.screenX - stTouch.x), 2.0)\r\n                               + Math.pow((touch.screenY - stTouch.y), 2.0));\r\n                \r\n                if (dist > MAX_DIST) {\r\n                    delete eligibleTouches[touch.identifier];\r\n                } else {\r\n                    num_valid_touches += 1;\r\n                }\r\n            }\r\n        }\r\n        \r\n        return num_valid_touches > 0;\r\n    }\r\n    \r\n    /* Remove touches that have become drags.\r\n     * This function assumes a minimum drag distance of 15px.\r\n     */\r\n    $(document).on(\"touchmove\", function (evt) {\r\n        testAndPruneTouchList(evt.originalEvent.changedTouches);\r\n    });\r\n    \r\n    /* Remove touches that have cancelled for hardware or OS specific reasons.\r\n     */\r\n    $(document).on(\"touchcancel\", function (evt) {\r\n        var i, touch;\r\n        \r\n        for (i = 0; i < evt.originalEvent.changedTouches.length; i += 1) {\r\n            touch = evt.originalEvent.changedTouches.item(i);\r\n            delete eligibleTouches[touch.identifier];\r\n        }\r\n    });\r\n    \r\n    /* Our main, extremely complicated event handler.\r\n     * We have to track a whole bunch of corner cases, since users expect the\r\n     * following out of their navigation structures:\r\n     * \r\n     *  1. Hovering over a toggle should open it\r\n     *  2. Touching a toggle with a finger should open it\r\n     *  3. Clicking on a toggle should navigate to it's link target, as it has\r\n     *     already opened from a hover\r\n     *  4. Tab-focusing content should cause offcanvas's open/close state to\r\n     *     follow through it\r\n     *  5. Touches should only be honored if they were not the end of a drag\r\n     */\r\n    $(document).on(\"click touchend mouseover\", function (evt) {\r\n        var i, sentinel = false,\r\n            $theToggle = $(evt.target),\r\n            $theTarget,\r\n            tgtStatus,\r\n            tgtState,\r\n            $btnParent = $theToggle.parents().filter(\"[data-toggle='offcanvas']\"),\r\n            skipToggle = false,\r\n            hoverMin = $(\"body\").data(\"offcanvas-hover-min\"),\r\n            toggleOptions,\r\n            hasEligibleTouches;\r\n\r\n        logger(evt.type);\r\n\r\n        focus_click_inquiry = false;\r\n\r\n        if (hoverMin === undefined) {\r\n            hoverMin = 0;\r\n        }\r\n\r\n        if (evt.type === \"mouseover\") {\r\n            if ($(window).width() < hoverMin) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        if ($theToggle.data(\"toggle\") !== \"offcanvas\" && $btnParent.length > 0) { //Fixup hits on child text, graphical bits, etc\r\n            $theToggle = $btnParent;\r\n        }\r\n\r\n        if (($openTarget === null || $openTarget === undefined || $openTarget.length === 0) && $theToggle.data(\"toggle\") !== \"offcanvas\") {\r\n            return;\r\n        }\r\n\r\n        if (evt.type !== \"mouseover\" && isInDebounce) {\r\n            logger(\"Processed event (debounced)\");\r\n            evt.preventDefault();\r\n            return;\r\n        }\r\n        \r\n        //Check if any of our touches were actually drags so we can ignore em\r\n        if (evt.type === \"touchend\") {\r\n            hasEligibleTouches = testAndPruneTouchList(evt.originalEvent.changedTouches);\r\n            \r\n            if (!hasEligibleTouches) {\r\n                logger(\"Ignoring touch event as it is the result of a drag\");\r\n                return;\r\n            }\r\n        }\r\n\r\n        toggleOptions = $theToggle.data(\"toggle-options\");\r\n        if (toggleOptions !== undefined) {\r\n            toggleOptions = toggleOptions.split(\" \");\r\n        } else {\r\n            toggleOptions = [];\r\n        }\r\n\r\n        if (evt.type === \"mouseover\" && toggleOptions.indexOf(\"nohover\") > -1) {\r\n            logger(\"Not opening a no-hover toggle\");\r\n            return;\r\n        }\r\n        \r\n        //Used to allow using the <a>nchor portion of a dropdown toggle\r\n        //but only after it was opened using a mouse\r\n        if ($(window).width() >= hoverMin &&\r\n                $theToggle[0].tagName === \"A\" &&\r\n                evt.type === \"click\" &&\r\n                !target_has_touch &&\r\n                !click_keydown_inquiry && //and event is not generated by a keyboard\r\n                toggleOptions.indexOf(\"nohover\") === -1 &&\r\n                toggleOptions.indexOf(\"nohref\") === -1) {\r\n\r\n            logger(\"Allowing link to resolve instead of opening toggle\");\r\n            return;\r\n        }\r\n\r\n        click_keydown_inquiry = false; //clear the \"click event was generated by\r\n                                     //a keyboard event\" flag so the user can\r\n                                     //switch back to mouse input\r\n        \r\n        if ($openTarget !== null && $openTarget !== undefined && $openTarget.length > 0) {\r\n            //Determine if it's okay to do anything that might dismiss an offcanvas\r\n            //based on this event\r\n            tgtState = $openTarget.data(\"offcanvas-state\");\r\n            if (tgtState === undefined) {\r\n                //This step is needed if the offcanvas elements were deleted and\r\n                //recreated behind our back (e.g. because PageTransitions). In that\r\n                //case all we can do is drop the current $openTarget entirely.\r\n                $openTarget = undefined;\r\n            }\r\n        }\r\n        \r\n        if ($theToggle.data(\"toggle\") === \"offcanvas\") {\r\n            $theTarget = initOffcanvasToggle($theToggle);\r\n            findParentLevels($theTarget);\r\n        }\r\n\r\n        if (!eventCanDismissOffcanvas($openTarget, $theTarget, evt, $theToggle)) {\r\n            return;\r\n        }\r\n        \r\n        logger(\"Processed event\");\r\n        \r\n        if ($openTarget !== null &&\r\n                $openTarget !== undefined &&\r\n                $openTarget.length > 0 &&\r\n                !$.contains($openTarget[0], evt.target) &&\r\n                $openTarget[0] !== evt.target) {\r\n            \r\n            //Dismiss offcanvas by clicking outside it's area\r\n            if (\"#\" + $openTarget.attr(\"id\") === $theToggle.data(\"target\")) {\r\n                skipToggle = true;\r\n            }\r\n            \r\n            if ($theToggle.filter(\"[data-dismiss='offcanvas']\").length > 0) {\r\n                logger(\"Not overridding a click on an existing dismiss button just because the click handler happened to win a race condition\");\r\n            } else {\r\n                logger(tgtState.toggleOptions);\r\n                logger(toggleOptions);\r\n\r\n                enableDebounce();\r\n\r\n                if ($($theToggle.data(\"target\"))[0] === $openTarget[0]) {\r\n                    //If we have clicked on a toggle for the currently open offcanvas, eat the event\r\n                    evt.preventDefault();\r\n                    evt.stopPropagation();\r\n                    evt.stopImmediatePropagation();\r\n                }\r\n\r\n                dismissOffcanvas($openTarget);\r\n            }\r\n        }\r\n\r\n        if ($theTarget !== undefined && !skipToggle) { //Open offcanvas via a toggle link\r\n            enableDebounce();\r\n\r\n            tgtState = $theTarget.data(\"offcanvas-state\");\r\n\r\n            //Determine if a different offcanvas tree is active, and, if so, dismiss it first.\r\n            while ($openTarget !== null && $openTarget !== undefined) {\r\n                sentinel = $openTarget[0] === $theTarget[0];\r\n\r\n                for (i = 0; i < tgtState.parents.length; i += 1) {\r\n                    if ($openTarget[0] === tgtState.parents[i]) {\r\n                        sentinel = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (sentinel) {\r\n                    break;\r\n                }\r\n\r\n                dismissOffcanvas($openTarget);\r\n            }\r\n\r\n            if (tgtState.open) {\r\n                dismissOffcanvas($theTarget);\r\n            } else {\r\n                openOffcanvas($theTarget, $theToggle, evt.type);\r\n            }\r\n\r\n            if ($theToggle[0].tagName.toLowerCase() === \"a\" || $theToggle[0].tagName.toLowerCase() === \"button\") {\r\n                evt.preventDefault();\r\n            }\r\n        }\r\n    });\r\n    \r\n    /* Another, slightly less complex event handler for dismissing open content\r\n     */\r\n    $(document).on(\"click touchend\", function (evt) {\r\n        var $theToggle = $(evt.target), $theTarget, tgtStatus, tgtState, $btnParent = $theToggle.parents().filter(\"[data-dismiss='offcanvas']\"), skipToggle = false, i, sentinel = false, $toDismiss = $openTarget;\r\n\r\n        if ($theToggle.data(\"dismiss\") !== \"offcanvas\" && $btnParent.length > 0) { //Fixup hits on child text, graphical bits, etc\r\n            $theToggle = $btnParent;\r\n        }\r\n\r\n        if ($theToggle.data(\"dismiss\") !== \"offcanvas\") {\r\n            return;\r\n        }\r\n\r\n        if (isInDebounce) {\r\n            logger(\"Processed event (debounced)\");\r\n            evt.preventDefault();\r\n            return;\r\n        }\r\n\r\n        enableDebounce();\r\n\r\n        if ($theToggle.data(\"target\") !== undefined) {\r\n            $toDismiss = $($theToggle.data(\"target\"));\r\n        }\r\n\r\n        if ($toDismiss.length > 0) {\r\n            dismissOffcanvas($toDismiss);\r\n        }\r\n        \r\n        evt.preventDefault();\r\n    });\r\n\r\n    module.isOffcanvas = isOffcanvas;\r\n    module.isChildOffcanvas = isChildOffcanvas;\r\n    module.isTopLevelOffcanvas = isTopLevelOffcanvas;\r\n    module.initOffcanvas = initOffcanvas;\r\n    module.initOffcanvasToggle = initOffcanvasToggle;\r\n    module.dismissOpenOffcanvas = dismissOpenOffcanvas;\r\n    module.openOffcanvas = openOffcanvas;\r\n    module.dismissOffcanvas = dismissOffcanvas;\r\n    module.enableDebounce = enableDebounce;\r\n    module.switchLoggingMode = switchLoggingMode;\r\n\r\n    return module;\r\n}));\r\n","/*global define, console, document, window, Promise*/\r\n(function (root, factory) {\r\n    \"use strict\";\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(\"PageTransition\", [\"jquery\", \"Behaviors\", \"Animations\"], factory);\r\n    } else {\r\n        root.PageTransition = factory(root.jQuery, root.Behaviors, root.Animations);\r\n    }\r\n}(this, function ($, Behaviors, Animations) {\r\n    \"use strict\";\r\n\r\n    var module = {};\r\n\r\n    function $do(that, target) {\r\n        return function () {\r\n            target.apply(that, arguments);\r\n        };\r\n    }\r\n\r\n    /* A page transition region is an element on the page with a unique ID that\r\n     * is the same from page load to page load. It is a good idea for there to\r\n     * be only one page transition region covering as much is it can on the\r\n     * page.\r\n     *\r\n     * An ID is mandatory for page transition regions.\r\n     */\r\n    function PageTransitionRegion(elem) {\r\n        Behaviors.init(PageTransitionRegion, this, arguments);\r\n\r\n        this.id = this.$elem.attr(\"id\");\r\n\r\n        this.$elem.on(\"click\", this.navigation_intent.bind(this));\r\n\r\n        this.claim_current_state();\r\n        $(window).on(\"popstate\", this.pop_state_intent.bind(this));\r\n    }\r\n\r\n    Behaviors.inherit(PageTransitionRegion, Behaviors.Behavior);\r\n\r\n    PageTransitionRegion.QUERY = \"[data-pagetransition-region]\";\r\n    \r\n    /* Determine if we can transition to a new page or not.\r\n     * \r\n     * This does not actually replace the content. Thus, you can make the check\r\n     * without committing to the new page.\r\n     */\r\n    PageTransitionRegion.prototype.can_replace = function ($new_document) {\r\n        var $other_region = $new_document.find(\"#\" + this.id);\r\n        if ($other_region.length === 0) {\r\n            $other_region = $new_document.filter(\"#\" + this.id);\r\n        }\r\n        \r\n        if ($other_region.length === 0) {\r\n            return false;\r\n        }\r\n        \r\n        return true;\r\n    };\r\n    \r\n    /* Prepare to replace the old content with the new one.\r\n     */\r\n    PageTransitionRegion.prototype.prepare_to_replace = function ($old_document) {\r\n        Behaviors.content_removal($old_document.children().filter(\":not([data-pagetransition-backdrop])\"));\r\n    };\r\n\r\n    /* Replace current content with content pulled from a new page we're trying\r\n     * to transition into.\r\n     *\r\n     * Returns false if we could not extract content from the new document.\r\n     * In this case, calling method should perform a traditional navigation to\r\n     * the new document.\r\n     */\r\n    PageTransitionRegion.prototype.replace = function ($new_document) {\r\n        var $other_region = $new_document.find(\"#\" + this.id), $children;\r\n        if ($other_region.length === 0) {\r\n            $other_region = $new_document.filter(\"#\" + this.id);\r\n        }\r\n\r\n        if ($other_region.length === 0) {\r\n            return false;\r\n        }\r\n        \r\n        $children = $other_region.children().filter(\":not([data-pagetransition-backdrop])\");\r\n\r\n        this.$elem.children().filter(\":not([data-pagetransition-backdrop])\").remove();\r\n        this.$elem.append($children);\r\n        $(window).scrollTop(0);\r\n        \r\n        Behaviors.content_ready($children.parent());\r\n\r\n        return true;\r\n    };\r\n\r\n    /* Replace the backdrop element.\r\n     *\r\n     * This is replaced separately so that each page can specify it's own outro\r\n     * backdrop without interrupting the incoming animation.\r\n     *\r\n     * This should only be called after the promise returned by transition_in\r\n     * resolves.\r\n     *\r\n     * Returns false if we could not extract content from the new document.\r\n     * In this case, calling method should perform a traditional navigation to\r\n     * the new document.\r\n     */\r\n    PageTransitionRegion.prototype.replace_backdrop = function ($new_document) {\r\n        var $other_region = $new_document.find(\"#\" + this.id);\r\n        if ($other_region.length === 0) {\r\n            $other_region = $new_document.filter(\"#\" + this.id);\r\n        }\r\n\r\n        if ($other_region.length === 0) {\r\n            return false;\r\n        }\r\n\r\n        this.$elem.attr(\"class\", $other_region.attr(\"class\"));\r\n        this.$elem.children().filter(\"[data-pagetransition-backdrop]\").remove();\r\n        this.$elem.append($other_region.children().filter(\"[data-pagetransition-backdrop]\"));\r\n\r\n        return true;\r\n    };\r\n\r\n    /* Change the browser URL to point to the new URL, and also fix relative\r\n     * links such that they resolve correctly.\r\n     *\r\n     * The transition property in the pushState data indicates that this entry\r\n     * was placed here by the PageTransitionRegion class. This lets us avoid\r\n     * applying transitions to things that shouldn't get them.\r\n     */\r\n    PageTransitionRegion.prototype.replace_state = function (url) {\r\n        window.history.pushState({transition: true, url: url}, \"\", url);\r\n        this.claim_current_state();\r\n    };\r\n    \r\n    /* Changes the document head to match what is present in the new document.\r\n     * \r\n     * Currently, only title replacement is supported, but this function may\r\n     * also be extended to \r\n     */\r\n    PageTransitionRegion.prototype.replace_head = function ($new_document) {\r\n        var $new_title = $new_document.filter(\"title\"),\r\n            $title = $(\"title\");\r\n        \r\n        if ($new_title.length === 0) {\r\n            $new_title = $new_document.find(\"title\");\r\n        }\r\n        \r\n        $title.text($new_title.text());\r\n    };\r\n    \r\n    /* Retrigger analytics scripts if so marked.\r\n     */\r\n    PageTransitionRegion.prototype.replace_analytics = function () {\r\n        var $reloadable_tags;\r\n        \r\n        //Step 1: Find tags marked for reloading.\r\n        $reloadable_tags = $(this.constructor.RELOADABLE_SCRIPT_QUERY);\r\n        \r\n        //Step 2: Reinsert them, hopefully causing them to be included again.\r\n        //We need to try this two separate ways based on if it's an inline\r\n        //script or external.\r\n        $reloadable_tags.detach();\r\n        \r\n        $reloadable_tags.each(function (index, elem) {\r\n            var $elem = $(elem), src = $elem.attr(\"src\");\r\n            \r\n            if (src !== undefined) {\r\n                //External script, recreate the tag\r\n                $elem.remove();\r\n                $elem = $(\"<script></script>\");\r\n                $elem.attr(\"src\", src);\r\n            }\r\n            \r\n            $(\"body\").append($elem);\r\n        });\r\n    };\r\n    \r\n    /* Indicates an analytics tag that can be retriggered for the new page load\r\n     * by just reloading it's tag.\r\n     */\r\n    PageTransitionRegion.RELOADABLE_SCRIPT_QUERY = \"[data-pagetransition-analytics='reloadable']\";\r\n\r\n    /* Claim the current history state for ourselves.\r\n     *\r\n     * By default, this is only called at the start of the page load.\r\n     */\r\n    PageTransitionRegion.prototype.claim_current_state = function () {\r\n        var url = window.location.href;\r\n        window.history.replaceState({transition: true, url: url}, \"\", url);\r\n    };\r\n\r\n    /* Determine if link is internal or external.\r\n     *\r\n     * The purpose of distinguishing between internal and external links is to\r\n     * check if we can transition to them properly or not. We can only\r\n     * transition into pages with compatible regions; so we assume that all\r\n     * internal links will use the same compatible theming.\r\n     *\r\n     * Also, transitioning to an external page requires specially configured\r\n     * web servers that allow CORS, which is a pain.\r\n     *\r\n     * Returns LINK_INTERNAL, LINK_EXTERNAL, LINK_POPUP, or LINK_HASH.\r\n     */\r\n    PageTransitionRegion.prototype.is_internal_link = function (url, $a) {\r\n        var extRegex = new RegExp(\"(\\/\\/|:)\"),\r\n            hashRegex = new RegExp(\"^#\"),\r\n            domainRelativeHashRegex = new RegExp(\"^\" + window.location.pathname + \"/#\"),\r\n            protRelativeRegex = new RegExp(\"^//\" + window.location.host),\r\n            protAbsoluteRegex = new RegExp('^' + window.location.protocol + \"//\" + window.location.host),\r\n            protRelativeHashRegex = new RegExp('^//' + window.location.host + window.location.pathname + \"#\"),\r\n            absoluteHashRegex = new RegExp('^' + window.location.protocol + \"//\" + window.location.host + window.location.pathname + \"#\");\r\n\r\n        if ($a.attr(\"target\") !== undefined && $a.attr(\"target\") !== \"\") {\r\n            return PageTransitionRegion.LINK_POPUP;\r\n        }\r\n        \r\n        if (hashRegex.test(url) || absoluteHashRegex.test(url) || protRelativeHashRegex.test(url) || domainRelativeHashRegex.test(url)) {\r\n            return PageTransitionRegion.LINK_HASH;\r\n        } else if (!extRegex.test(url) || protRelativeRegex.test(url) || protAbsoluteRegex.test(url)) {\r\n            return PageTransitionRegion.LINK_INTERNAL;\r\n        } else {\r\n            return PageTransitionRegion.LINK_EXTERNAL;\r\n        }\r\n    };\r\n\r\n    /* Transition out the current page.\r\n     *\r\n     * Returns a promise which resolves when the transition has completed.\r\n     *\r\n     * This default implementation uses a CSS class and waits for transitionEnd\r\n     * events.\r\n     */\r\n    PageTransitionRegion.prototype.transition_out = function () {\r\n        var aw;\r\n\r\n        this.$elem.removeClass(\"is-PageTransition--transition_loading\");\r\n        this.$elem.addClass(\"is-PageTransition--transition_out\");\r\n        this.$elem.removeClass(\"is-PageTransition--transition_in\");\r\n        aw = new Animations.AnimationWatcher(this.$elem.find(\"[data-pagetransition-backdrop]\"));\r\n\r\n        return aw.promise;\r\n    };\r\n\r\n    /* Transition to a loading animation.\r\n     *\r\n     * Returns a promise which resolves when the transition has completed.\r\n     *\r\n     * This default implementation uses a CSS class and waits for transitionEnd\r\n     * events.\r\n     */\r\n    PageTransitionRegion.prototype.transition_loading = function () {\r\n        var aw;\r\n\r\n        this.$elem.addClass(\"is-PageTransition--transition_loading\");\r\n        this.$elem.removeClass(\"is-PageTransition--transition_out\");\r\n        this.$elem.removeClass(\"is-PageTransition--transition_in\");\r\n        aw = new Animations.AnimationWatcher(this.$elem.find(\"[data-pagetransition-backdrop]\"));\r\n\r\n        return aw.promise;\r\n    };\r\n\r\n    /* Transition in the current page.\r\n     *\r\n     * Returns a promise which resolves when the transition has completed.\r\n     *\r\n     * This default implementation uses a CSS class and waits for transitionEnd\r\n     * events.\r\n     */\r\n    PageTransitionRegion.prototype.transition_in = function () {\r\n        var aw;\r\n\r\n        this.$elem.removeClass(\"is-PageTransition--transition_loading\");\r\n        this.$elem.removeClass(\"is-PageTransition--transition_out\");\r\n        this.$elem.addClass(\"is-PageTransition--transition_in\");\r\n        aw = new Animations.AnimationWatcher(this.$elem.find(\"[data-pagetransition-backdrop]\"));\r\n\r\n        return aw.promise;\r\n    };\r\n\r\n    /* Transition to the \"done\" state, which should just have the site be\r\n     * plainly visible.\r\n     *\r\n     * Returns a promise which resolves any final transitions have completed.\r\n     * However, most transition effects should not be starting animations here,\r\n     * so it may never resolve.\r\n     *\r\n     * This default implementation removes all CSS classes and waits for\r\n     * transitionEnd events.\r\n     */\r\n    PageTransitionRegion.prototype.transition_done = function () {\r\n        var aw;\r\n\r\n        this.$elem.removeClass(\"is-PageTransition--transition_loading\");\r\n        this.$elem.removeClass(\"is-PageTransition--transition_out\");\r\n        this.$elem.removeClass(\"is-PageTransition--transition_in\");\r\n        aw = new Animations.AnimationWatcher(this.$elem.find(\"[data-pagetransition-backdrop]\"));\r\n\r\n        return aw.promise;\r\n    };\r\n\r\n    /* Given a URL, actually transition the page to a new page.\r\n     *\r\n     * The default method of transitioning the page is to:\r\n     *\r\n     *   1. AJAX the new page in\r\n     *   2. Transition out the current page\r\n     *   3. Call .replace() to get the new page's content in here.\r\n     *   4. Transition in the new page\r\n     *\r\n     * Subclasses of PageTransitionRegion may implement more complicated\r\n     * behavior based on their own individual requirements. Generally, however,\r\n     * you will want to call .replace() to get the content in.\r\n     *\r\n     * If the replacement fails, we will attempt traditional navigation instead\r\n     * of silently or catastrophically failing.\r\n     */\r\n    PageTransitionRegion.prototype.retrieve_document_by_url = function (url, isPopState) {\r\n        var ajaxPromise = new Promise(function (resolve, reject) {\r\n            $.get(url, undefined, resolve, \"html\");\r\n        }),\r\n            theData;\r\n\r\n        return this.transition_out().then(function () {\r\n            console.log(\"Out transition finished\");\r\n            this.transition_loading();\r\n            return ajaxPromise;\r\n        }.bind(this)).then(function (data) {\r\n            this.prepare_to_replace(this.$elem);\r\n            return new Promise(function (resolve, reject) {\r\n                window.setTimeout(resolve.bind(this, data), 1);\r\n            });\r\n        }.bind(this)).then(function (data) {\r\n            var couldReplace;\r\n\r\n            console.log(\"Load finished\");\r\n            theData = data;\r\n\r\n            couldReplace = this.can_replace($(theData));\r\n            if (!couldReplace) {\r\n                window.location.href = url;\r\n                throw new Error(\"Location \" + url + \" does not have transitionable links!\");\r\n            } else if (isPopState !== true) {\r\n                this.replace_state(url);\r\n            }\r\n            \r\n            this.replace($(theData));\r\n            this.replace_head($(theData));\r\n            this.replace_analytics($(theData));\r\n            \r\n            return this.transition_in();\r\n        }.bind(this)).then(function () {\r\n            console.log(\"In transition finished\");\r\n            this.replace_backdrop($(theData));\r\n            this.transition_done();\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Link which resolves to the same origin server. */\r\n    PageTransitionRegion.LINK_INTERNAL = 0;\r\n\r\n    /* Link which resolves to a different origin server. */\r\n    PageTransitionRegion.LINK_EXTERNAL = 1;\r\n\r\n    /* Link which resolves in another window */\r\n    PageTransitionRegion.LINK_POPUP = 2;\r\n\r\n    /* Link which resolves to the same page.\r\n     * Also covers links which do JavaScripty things and should be buttons, but\r\n     * aren't because some developers think their pages will always load with\r\n     * the correct JS and don't consider fallback cases\r\n     */\r\n    PageTransitionRegion.LINK_HASH = 3;\r\n\r\n    /* Event handler for when a link within the region is clicked.\r\n     */\r\n    PageTransitionRegion.prototype.navigation_intent = function (evt) {\r\n        var $target = $(evt.target), $parent_tgt = $target.parents().filter(\"a\"),\r\n            href;\r\n\r\n        if ($target.filter(\"a\").length === 0) {\r\n            $target = $parent_tgt;\r\n        }\r\n\r\n        if ($target.filter(\"a\").length === 0) {\r\n            //Not a link.\r\n            return;\r\n        }\r\n\r\n        href = $target.attr(\"href\");\r\n\r\n        if (this.is_internal_link(href, $target) === PageTransitionRegion.LINK_INTERNAL) {\r\n            //It's AJAX time!\r\n            evt.preventDefault();\r\n            this.retrieve_document_by_url(href);\r\n        }\r\n    };\r\n\r\n    /* Event handler for when the user presses the back button. */\r\n    PageTransitionRegion.prototype.pop_state_intent = function (evt) {\r\n        if (evt.originalEvent.state !== undefined &&\r\n                evt.originalEvent.state !== null &&\r\n                evt.originalEvent.state.transition === true) {\r\n            evt.preventDefault();\r\n            this.retrieve_document_by_url(evt.originalEvent.state.url, true);\r\n        }\r\n    };\r\n\r\n    Behaviors.register_behavior(PageTransitionRegion);\r\n\r\n    module.PageTransitionRegion = PageTransitionRegion;\r\n\r\n    return module;\r\n}));\r\n","/*global define, console*/\r\n\r\n(function (root, factory) {\r\n    \"use strict\";\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(\"ScrollEffects\", [\"jquery\", \"Behaviors\"], factory);\r\n    } else {\r\n        root.ScrollEffects = factory(root.jQuery, root.Behaviors);\r\n    }\r\n}(this, function ($, Behaviors) {\r\n    \"use strict\";\r\n\r\n    var module = {};\r\n\r\n    function ScrollEffects(elem) {\r\n        Behaviors.init(ScrollEffects, this, arguments);\r\n\r\n        this.$elem = $(elem);\r\n        this.$scrollCtxt = $(window); //TODO: Allow CSS overflow scrolling\r\n        \r\n        this.scrollHandler = this.on_scroll_intent.bind(this);\r\n\r\n        this.$scrollCtxt.on(\"scroll\", this.scrollHandler);\r\n    }\r\n\r\n    Behaviors.inherit(ScrollEffects, Behaviors.Behavior);\r\n\r\n    ScrollEffects.QUERY = \"[data-scrolleffects]\";\r\n    ScrollEffects.THROTTLE_TIMEOUT = 200;\r\n    \r\n    /* Deinitialize our scroll handler if needed.\r\n     */\r\n    ScrollEffects.prototype.deinitialize = function () {\r\n        this.$scrollCtxt.off(\"scroll\", this.scrollHandler);\r\n    };\r\n    \r\n    /* Return a list of all available scroll effect modes on this bit.\r\n     */\r\n    ScrollEffects.prototype.activation_modes = function () {\r\n        return this.$elem.data(\"scrolleffects\").split(\" \");\r\n    };\r\n\r\n    ScrollEffects.prototype.update_css_classes = function () {\r\n        var activation_modes = this.activation_modes(),\r\n            active = false;\r\n\r\n        if (this.isTopVisible && activation_modes.indexOf(\"top_visible\") !== -1) {\r\n            active = true;\r\n        }\r\n\r\n        if (this.isBottomVisible && activation_modes.indexOf(\"bottom_visible\") !== -1) {\r\n            active = true;\r\n        }\r\n\r\n        if (this.isVisible && activation_modes.indexOf(\"visible\") !== -1) {\r\n            active = true;\r\n        }\r\n\r\n        if (this.onceTopVisible && activation_modes.indexOf(\"top_visible_once\") !== -1) {\r\n            active = true;\r\n        }\r\n\r\n        if (this.onceBottomVisible && activation_modes.indexOf(\"bottom_visible_once\") !== -1) {\r\n            active = true;\r\n        }\r\n\r\n        if (this.onceVisible && activation_modes.indexOf(\"visible_once\") !== -1) {\r\n            active = true;\r\n        }\r\n\r\n        if (active) {\r\n            this.$elem.addClass(\"is-ScrollEffects--active\");\r\n            this.$elem.removeClass(\"is-ScrollEffects--inactive\");\r\n        } else {\r\n            this.$elem.removeClass(\"is-ScrollEffects--active\");\r\n            this.$elem.addClass(\"is-ScrollEffects--inactive\");\r\n        }\r\n    };\r\n\r\n    ScrollEffects.prototype.on_scroll_intent = function () {\r\n        var top = this.$elem.offset().top,\r\n            height = this.$elem.height(),\r\n            bottom = top + height,\r\n            contextOffset = this.$scrollCtxt.offset(),\r\n            contextScrollTop = contextOffset !== undefined\r\n                                ? contextOffset.top + this.$scrollCtxt.scrollTop()\r\n                                : this.$scrollCtxt.scrollTop(),\r\n            contextHeight = this.$scrollCtxt.height(),\r\n            contextScrollBottom = contextScrollTop + contextHeight;\r\n\r\n        this.isTopVisible = contextScrollTop <= top && top <= contextScrollBottom;\r\n        this.isBottomVisible = contextScrollTop <= bottom && bottom <= contextScrollBottom;\r\n        this.isVisible = this.isTopVisible || this.isBottomVisible\r\n            || (top <= contextScrollTop && contextScrollTop <= bottom)\r\n            || (top <= contextScrollBottom && contextScrollBottom <= bottom);\r\n\r\n        this.onceTopVisible = this.onceTopVisible || this.isTopVisible;\r\n        this.onceBottomVisible = this.onceBottomVisible || this.isBottomVisible;\r\n        this.onceVisible = this.onceVisible || this.isVisible;\r\n\r\n        this.top = top;\r\n        this.bottom = bottom;\r\n        this.contextScrollTop = contextScrollTop;\r\n        this.contextScrollBottom = contextScrollBottom;\r\n\r\n        this.update_css_classes();\r\n    };\r\n\r\n    Behaviors.register_behavior(ScrollEffects);\r\n\r\n    function ScrollAlax() {\r\n        Behaviors.init(ScrollAlax, this, arguments);\r\n\r\n        this.$layers = this.$elem.find(\"li\");\r\n        this.depth = this.$elem.height() * -0.5;\r\n\r\n        if (this.$elem.data('scrollalax-depthrange') === 'outside') {\r\n            this.anim_scale = 1;\r\n        } else {\r\n            this.anim_scale = -1;\r\n        }\r\n\r\n        this.weights = this.weight_layers(this.$layers);\r\n\r\n        this.on_scroll_intent();\r\n    }\r\n\r\n    Behaviors.inherit(ScrollAlax, ScrollEffects);\r\n\r\n    ScrollAlax.QUERY = \"[data-scrollalax]\";\r\n\r\n    /* Determine the weights of each layer on the parallax group. */\r\n    ScrollAlax.prototype.weight_layers = function ($layers) {\r\n        var min = Infinity, max = -Infinity, w = [];\r\n\r\n        $layers.each(function (index, elem) {\r\n            var depth = $(elem).data(\"scrollalax-depth\");\r\n\r\n            if (min > depth) {\r\n                min = depth;\r\n            }\r\n\r\n            if (max < depth) {\r\n                max = depth;\r\n            }\r\n        }.bind(this));\r\n\r\n        $layers.each(function (index, elem) {\r\n            var depth = $(elem).data(\"scrollalax-depth\");\r\n\r\n            if (this.anim_scale === -1) {\r\n                w.push(-1 + (depth - min) / (max - min));\r\n            } else {\r\n                w.push((depth - min) / (max - min));\r\n            }\r\n        }.bind(this));\r\n\r\n        return w;\r\n    }\r\n\r\n    /* Calculate X or Y positions of a layer. */\r\n    ScrollAlax.prototype.apply_transform_css = function(style, index, xPct, yPct) {\r\n        var pct_Xdrag = this.weights[index] * xPct * this.anim_scale,\r\n            pct_Ydrag = this.weights[index] * yPct * this.anim_scale,\r\n            xDisp = this.depth * pct_Xdrag * this.anim_scale,\r\n            yDisp = this.depth * pct_Ydrag * this.anim_scale;\r\n\r\n        //style.left = xDisp + \"px\";\r\n        //style.top = yDisp + \"px\";\r\n\r\n        style.transform = \"translate3D(\" + xDisp + \"px, \" + yDisp + \"px, 0px)\";\r\n    };\r\n\r\n    /* Update the scroll animation. */\r\n    ScrollAlax.prototype.update_css_classes = function (evt) {\r\n        this.$layers.each(function (index, layer_elem) {\r\n            var pct_down = Math.max(Math.min((this.contextScrollTop - this.top) / this.$elem.height(), 1.0), 0.0),\r\n                $layer_elem = $(layer_elem);\r\n\r\n            this.apply_transform_css(layer_elem.style, index, 0, pct_down);\r\n        }.bind(this));\r\n    };\r\n\r\n    Behaviors.register_behavior(ScrollAlax);\r\n\r\n    module.ScrollEffects = ScrollEffects;\r\n    module.ScrollAlax = ScrollAlax;\r\n\r\n    return module;\r\n}));\r\n","(function (root, factory) {\r\n    \"use strict\";\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(\"accountslidein\", [\"jquery\", \"betteroffcanvas\"], factory);\r\n    } else {\r\n        // Browser globals\r\n        root.accountslidein = factory(root.jQuery, root.betteroffcanvas);\r\n    }\r\n}(this, function ($, betteroffcanvas) {\r\n    \"use strict\";\r\n    \"feel good\";\r\n\r\n    $('.Account_slide-login--button').click(function(){\r\n        $(this).hide();\r\n        $('.Account_slide-form--password').removeClass('Account_slide-form--visible')\r\n        $('.Account_slide-form--login').addClass('Account_slide-form--visible');\r\n        return false;\r\n    });\r\n\r\n    $('.Account_slide-password_recovery').click(function(){\r\n        $('.Account_slide-login--button').show();\r\n        $('.Account_slide-form--login').removeClass('Account_slide-form--visible');\r\n        $('.Account_slide-form--password').addClass('Account_slide-form--visible');\r\n        return false;\r\n    });\r\n\r\n\r\n    $('.Account_slide-close').click(function(){\r\n        betteroffcanvas.dismissOffcanvas($('#SiteHeader-accounts'));\r\n    });\r\n}));\r\n","(function (root, factory) {\r\n    \"use strict\";\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(\"siteheader\", [\"jquery\", \"betteroffcanvas\"], factory);\r\n    } else {\r\n        // Browser globals\r\n        root.siteheader = factory(root.jQuery, root.betteroffcanvas);\r\n    }\r\n}(this, function ($, betteroffcanvas, ajaxCart, Handlebars) {\r\n    \"use strict\";\r\n    \"feel good\";\r\n\r\n    function update_scroll() {\r\n        var scrollTop = $(window).scrollTop(),\r\n            $SiteHeader = $(\"[data-siteheader='siteheader']\");\r\n\r\n        if (scrollTop === 0) {\r\n            $SiteHeader.addClass(\"is-SiteHeader--at_top\");\r\n            $SiteHeader.removeClass(\"is-SiteHeader--scrolled\");\r\n        } else {\r\n            $SiteHeader.removeClass(\"is-SiteHeader--at_top\");\r\n            $SiteHeader.addClass(\"is-SiteHeader--scrolled\");\r\n        }\r\n    };\r\n\r\n    $(window).on(\"scroll\", update_scroll);\r\n\r\n    update_scroll();\r\n}));\r\n","(function (root, factory) {\r\n    \"use strict\";\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(\"StaffGrid\", [\"jquery\", \"Behaviors\"], factory);\r\n    } else {\r\n        root.StaffGrid = factory(root.jQuery, root.Behaviors);\r\n    }\r\n}(this, function ($, Behaviors) {\r\n    \"use strict\";\r\n\r\n    var module = {};\r\n    \r\n    function StaffGridSlider() {\r\n        Behaviors.init(StaffGridSlider, this, arguments);\r\n        \r\n        this.$elem.slick({\r\n            prevArrow: this.$elem.find('[data-staffgrid-prev]'),\r\n            nextArrow: this.$elem.find('[data-staffgrid-next]')\r\n        });\r\n    }\r\n    \r\n    Behaviors.inherit(StaffGridSlider, Behaviors.Behavior);\r\n    \r\n    StaffGridSlider.QUERY = \"[data-staffgrid-slider]\";\r\n    \r\n    StaffGridSlider.prototype.goto = function (id, animate) {\r\n        this.$elem.slick('slickGoTo', id, animate);\r\n    }\r\n    \r\n    function StaffGridModal() {\r\n        Behaviors.init(StaffGridModal, this, arguments);\r\n        \r\n        this.slider = StaffGridSlider.locate(this.$elem.find('[data-staffgrid-slider]'));\r\n        this.$elem.on(\"offcanvas-open\", this.modal_reveal_intent.bind(this));\r\n    }\r\n    \r\n    Behaviors.inherit(StaffGridModal, Behaviors.Behavior);\r\n    \r\n    StaffGridModal.QUERY = \"[data-staffgrid-modal]\";\r\n    \r\n    StaffGridModal.prototype.modal_reveal_intent = function (evt) {\r\n        var slideIndex = $(evt.originalEvent.toggle).data('staffgrid-slider-index');\r\n        \r\n        this.slider.goto(slideIndex, true);\r\n    };\r\n    \r\n    Behaviors.register_behavior(StaffGridModal);\r\n    Behaviors.register_behavior(StaffGridSlider);\r\n    \r\n    module.StaffGridModal = StaffGridModal;\r\n    module.StaffGridSlider = StaffGridSlider;\r\n    \r\n    return module;\r\n}));\r\n","/*global define, console, document, window*/\n(function (root, factory) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(\"TabbedContent\", [\"jquery\", \"Behaviors\"], factory);\n    } else {\n        root.TabbedContent = factory(root.jQuery, root.Behaviors);\n    }\n}(this, function ($, Behaviors) {\n    \"use strict\";\n\n    var module = {};\n\n    function $do(that, target) {\n        return function () {\n            target.apply(that, arguments);\n        };\n    }\n\n    function TabbedContentRegion(elem) {\n        Behaviors.init(TabbedContentRegion, this, arguments);\n\n        this.$elem = $(elem);\n        this.id = this.$elem.attr(\"id\");\n        this.active = this.$elem.data(\"tabbedcontent-region-active\") !== undefined;\n\n        this.links = [];\n\n        this.reflect_status();\n    }\n\n    Behaviors.inherit(TabbedContentRegion, Behaviors.Behavior);\n\n    TabbedContentRegion.QUERY = \"[data-tabbedcontent-region]\";\n\n    TabbedContentRegion.prototype.reflect_status = function (status) {\n        var i;\n\n        if (status === undefined) {\n            status = this.active;\n        }\n\n        if (status) {\n            this.$elem.addClass(\"is-TabbedContent--active\");\n            this.$elem.removeClass(\"is-TabbedContent--inactive\");\n        } else {\n            this.$elem.removeClass(\"is-TabbedContent--active\");\n            this.$elem.addClass(\"is-TabbedContent--inactive\");\n        }\n\n        for (i = 0; i < this.links.length; i += 1) {\n            if (status) {\n                this.links[i].addClass(\"is-TabbedContent--target_active\");\n                this.links[i].removeClass(\"is-TabbedContent--target_inactive\");\n            } else {\n                this.links[i].removeClass(\"is-TabbedContent--target_active\");\n                this.links[i].addClass(\"is-TabbedContent--target_inactive\");\n            }\n        }\n    };\n\n    TabbedContentRegion.prototype.add_incoming_link = function ($li) {\n        this.links.push($li);\n    };\n\n    function TabbedContentSet(elem) {\n        Behaviors.init(TabbedContentSet, this, arguments);\n\n        this.$elem = $(elem);\n\n        this.tabset_name = this.$elem.attr(\"data-tabbedcontent-set\");\n        if (this.tabset_name === undefined) {\n            this.tabset_name = this.$elem.attr(\"id\");\n        }\n\n        this.tab_members = {};\n        this.list = [];\n\n        this.find_links();\n    }\n\n    Behaviors.inherit(TabbedContentSet, Behaviors.Behavior);\n\n    TabbedContentSet.QUERY = \"[data-tabbedcontent-set]\";\n\n    TabbedContentSet.prototype.new_tab = function (id) {\n        var $elem = $(\"#\" + id);\n\n        if ($elem.length === 0) {\n            return false;\n        }\n\n        if (this.tab_members[id] === undefined) {\n            this.tab_members[id] = {\n                \"toggles\": [],\n                \"content\": TabbedContentRegion.locate($elem)\n            };\n        }\n\n        return true;\n    };\n\n    TabbedContentSet.prototype.set_active_tab = function (id) {\n        var k;\n\n        for (k in this.tab_members) {\n            if (this.tab_members.hasOwnProperty(k)) {\n                this.tab_members[k].content.active = k === id;\n                this.tab_members[k].content.reflect_status();\n            }\n        }\n    };\n\n    TabbedContentSet.prototype.navigate_tab_intent = function (id, evt) {\n        this.set_active_tab(id);\n\n        if (evt) {\n            evt.preventDefault();\n        }\n    };\n\n    TabbedContentSet.prototype.import_list_item = function (li) {\n        var $li = $(li),\n            $link = $li.find(\"a\"),\n            href = $link.attr(\"href\"),\n            id;\n\n        if ($link.length === 0) {\n            return;\n        }\n\n        if (href.indexOf(\"#\") !== -1) {\n            id = href.slice(1);\n        }\n\n        if (id === undefined) {\n            return;\n        }\n\n        if (this.tab_members[id] === undefined && !this.new_tab(id)) {\n            return;\n        }\n\n        this.list.push({\n            \"li\": $li,\n            \"id\": id\n        });\n        this.tab_members[id].content.add_incoming_link($li);\n        this.tab_members[id].content.reflect_status();\n        $link.on(\"touchend click\", this.navigate_tab_intent.bind(this, id));\n    };\n\n    TabbedContentSet.prototype.find_links = function () {\n        var that = this;\n\n        this.$elem.find(\"li\").each(function (index, elem) {\n            return that.import_list_item(elem);\n        });\n    };\n\n    Behaviors.register_behavior(TabbedContentSet);\n\n    module.TabbedContentSet = TabbedContentSet;\n\n    return module;\n}));\n","/*global define, window, document, Promise*/\r\n(function (root, factory) {\r\n    \"use strict\";\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(\"VideoPlayer\", [\"jquery\", \"Behaviors\"], factory);\r\n    } else {\r\n        root.VideoPlayer = factory(root.jQuery, root.Behaviors);\r\n    }\r\n}(this, function ($, Behaviors) {\r\n    \"use strict\";\r\n\r\n    var module = {};\r\n\r\n    function VideoPlayer(elem) {\r\n        Behaviors.init(VideoPlayer, this, arguments);\r\n\r\n        this.$elem = $(elem);\r\n        \r\n        if (this.ready) {\r\n            this.ready().then(this.locate_children.bind(this));\r\n        } else {\r\n            this.locate_children();\r\n        }\r\n    }\r\n\r\n    Behaviors.inherit(VideoPlayer, Behaviors.Behavior);\r\n\r\n    /* Returns a promise which resolves when the player is ready to accept\r\n     * other API calls.\r\n     *\r\n     * Calling those other API calls outside of a then() block from the promise\r\n     * returned by this function is a good way to have a bad time.\r\n     *\r\n     * By default, the video player is always ready.\r\n     */\r\n    VideoPlayer.prototype.ready = function () {\r\n        return new Promise(function (resolve, reject) {\r\n            resolve();\r\n        });\r\n    };\r\n\r\n    //No QUERY is defined for the base VideoPlayer class as it is not intended\r\n    //to be locatable. Derived classes should locate their VideoPlayer subclass\r\n    //once it's attendant APIs have been loaded.\r\n    //VideoPlayer.QUERY = \"\";\r\n\r\n    VideoPlayer.prototype.locate_children = function () {\r\n        var $parent_modal;\r\n        \r\n        this.playpause = VideoPlayer_playpause.find_markup(this.$elem, this);\r\n        this.scrubbers = VideoPlayer_scrubber.find_markup(this.$elem, this);\r\n        this.mute_btns = VideoPlayer_mute.find_markup(this.$elem, this);\r\n        \r\n        //This is an example of how to locate upwards\r\n        $parent_modal = this.$elem.parents().filter(VideoPlayer_offcanvas.QUERY);\r\n        \r\n        if ($parent_modal.length > 0) {\r\n            this.modal = VideoPlayer_offcanvas.locate($parent_modal[0], this);\r\n        }\r\n        \r\n        //Now see if we're supposed to autoplay...\r\n        if (this.$elem.data(\"videoplayer-autoplay\") !== undefined) {\r\n            this.play();\r\n            \r\n            if (this.$elem.data(\"videoplayer-loop\") !== undefined) {\r\n                this.add_statechange_listener(this.loopcheck.bind(this));\r\n            }\r\n        }\r\n    };\r\n    \r\n    VideoPlayer.prototype.loopcheck = function () {\r\n        Promise.all([this.is_paused(), this.get_current_time(), this.get_duration()]).then(function (values) {\r\n            var is_paused = values[0];\r\n            var current_time = values[1];\r\n            var duration = values[2];\r\n            \r\n            if (is_paused && current_time === duration) {\r\n                this.seek(0);\r\n                this.play();\r\n            }\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Determine if the video player is active.\r\n     *\r\n     * Most keyboard events only process on the active video's controls, not\r\n     * other videos. This ensures that you can have multiple VideoPlayers\r\n     * running without them all being controlled by the same limited set of\r\n     * keyboard shortcuts.\r\n     *\r\n     * A video player is active if any of the following apply:\r\n     *\r\n     *  - The video is marked primary with [data-videoplayer-primary].\r\n     *  - The video is currently playing.\r\n     *  - The VideoPlayer element or one of it's children has keyboard focus.\r\n     * \r\n     * This function returns a promise which resolves to the return value.\r\n     */\r\n    VideoPlayer.prototype.is_active = function () {\r\n        return this.is_paused(function (is_paused) {\r\n            if (this.$elem.data(\"videoplayer-primary\") !== undefined) {\r\n                return true;\r\n            }\r\n\r\n            if (!is_paused) {\r\n                return true;\r\n            }\r\n\r\n            if (this.$elem.find(\":focus\").length > 0) {\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Serves as a play/pause button for a connected VideoPlayer.\r\n     */\r\n    function VideoPlayer_playpause(elem, parent) {\r\n        var that = this;\r\n\r\n        Behaviors.init(VideoPlayer_playpause, that, arguments);\r\n\r\n        that.parent = parent;\r\n\r\n        that.parent.ready().then(function () {\r\n            that.parent.add_statechange_listener(that.on_statechange.bind(that));\r\n            that.$elem.on(\"click touchend\", that.on_play_intent.bind(that));\r\n\r\n            that.update_css_classes();\r\n        });\r\n    }\r\n\r\n    Behaviors.inherit(VideoPlayer_playpause, Behaviors.Behavior);\r\n\r\n    VideoPlayer_playpause.QUERY = \"[data-videoplayer-playpause]\";\r\n\r\n    VideoPlayer_playpause.prototype.update_css_classes = function () {\r\n        this.parent.is_paused().then(function (is_paused) {\r\n            if (is_paused) {\r\n                this.$elem.addClass(\"is-VideoPlayer--paused\");\r\n                this.$elem.removeClass(\"is-VideoPlayer--playing\");\r\n            } else {\r\n                this.$elem.removeClass(\"is-VideoPlayer--paused\");\r\n                this.$elem.addClass(\"is-VideoPlayer--playing\");\r\n            }\r\n        }.bind(this));\r\n    };\r\n\r\n    VideoPlayer_playpause.prototype.toggle_playback = function () {\r\n        this.parent.is_paused().then(function (is_paused) {\r\n            if (is_paused) {\r\n                this.parent.play();\r\n            } else {\r\n                this.parent.pause();\r\n            }\r\n        }.bind(this));\r\n    };\r\n\r\n    VideoPlayer_playpause.prototype.on_statechange = function () {\r\n        this.update_css_classes();\r\n    };\r\n\r\n    VideoPlayer_playpause.prototype.on_play_intent = function () {\r\n        this.toggle_playback();\r\n    };\r\n\r\n    /* Allows a video modal to be started and stopped as the modal is opened\r\n     * and closed.\r\n     * \r\n     * Place this on the Offcanvas element that gets dismissed and/or opened.\r\n     */\r\n    function VideoPlayer_offcanvas(elem, parent) {\r\n        var that = this;\r\n\r\n        Behaviors.init(VideoPlayer_offcanvas, that, arguments);\r\n\r\n        that.parent = parent;\r\n\r\n        that.$elem.on(\"offcanvas-open\", that.on_open_intent.bind(that));\r\n        that.$elem.on(\"offcanvas-dismiss\", that.on_dismiss_intent.bind(that));\r\n    }\r\n\r\n    Behaviors.inherit(VideoPlayer_offcanvas, Behaviors.Behavior);\r\n\r\n    VideoPlayer_offcanvas.QUERY = \"[data-videoplayer-offcanvas]\";\r\n\r\n    VideoPlayer_offcanvas.prototype.on_open_intent = function () {\r\n        var that = this;\r\n\r\n        that.parent.is_paused().then(function (is_paused) {\r\n            if (is_paused) {\r\n                that.parent.play();\r\n            }\r\n        });\r\n    };\r\n\r\n    VideoPlayer_offcanvas.prototype.on_dismiss_intent = function () {\r\n        var that = this;\r\n\r\n        that.parent.is_paused().then(function (is_paused) {\r\n            if (!is_paused) {\r\n                that.parent.pause();\r\n            }\r\n        });\r\n    };\r\n\r\n    /* Serves as a scrub bar for a connected VideoPlayer.\r\n     *\r\n     * A Scrubber contains additional elements inside of it that do not have an\r\n     * associated behavior:\r\n     *\r\n     *  - [data-videoplayer-scrubberfill]: The filled range of the scrubber.\r\n     *  - [data-videoplayer-scrubberknob]: A knob which indicates the current\r\n     *     scrubber point.\r\n     */\r\n    function VideoPlayer_scrubber(elem, parent) {\r\n        var err, that = this;\r\n\r\n        Behaviors.init(VideoPlayer_scrubber, that, arguments);\r\n\r\n        that.parent = parent;\r\n\r\n        //EVENT STATE VARIABLES\r\n        that.is_dragging = false;\r\n        that.in_debounce = false;\r\n\r\n        //OPTIONAL COMPONENTS\r\n        that.$scrubfill = that.$elem.find(\"[data-videoplayer-scrubberfill]\");\r\n        that.$scrubknob = that.$elem.find(\"[data-videoplayer-scrubberknob]\");\r\n\r\n        that.parent.ready().then(function () {\r\n            //EVENT HANDLERS\r\n            that.$elem.on(\"mousedown touchstart\", that.on_dragstart_intent.bind(that));\r\n            that.$elem.on(\"mousemove touchmove\", that.on_drag_intent.bind(that));\r\n            $(document).on(\"mouseup touchend touchcancel\", that.on_dragend_intent.bind(that));\r\n            $(document).on(\"keydown\", that.on_keyboard_nav.bind(that));\r\n\r\n            err = that.parent.add_timeupdate_listener(that.on_timeupdate.bind(that));\r\n            if (err === false) {\r\n                window.setInterval(that.on_timeupdate.bind(that), 1000);\r\n            }\r\n        });\r\n\r\n        that.update_scrubber();\r\n    }\r\n\r\n    Behaviors.inherit(VideoPlayer_scrubber, Behaviors.Behavior);\r\n\r\n    VideoPlayer_scrubber.QUERY = \"[data-videoplayer-scrubber]\";\r\n\r\n    VideoPlayer_scrubber.prototype.css_percent = function (value) {\r\n        return (value * 100) + \"%\";\r\n    };\r\n\r\n    /* This defines the dynamic CSS properties that are applied to scrubber\r\n     * elements.\r\n     *\r\n     * Specifically, fills get a width equal to the current play percentage;\r\n     * knobs get a left position equal to the current play percentage.\r\n     *\r\n     * This assumes knobs and fills get positioned relative to the scrubber.\r\n     */\r\n    VideoPlayer_scrubber.prototype.update_scrubber = function () {\r\n        var that = this, currentTime, ratio;\r\n        \r\n        that.parent.ready().then(function () {\r\n            return that.parent.get_current_time();\r\n        }.bind(this)).then(function (newCurrentTime) {\r\n            currentTime = newCurrentTime;\r\n            return that.parent.get_duration();\r\n        }.bind(this)).then(function (duration) {\r\n            ratio = 0;\r\n\r\n            if (!isFinite(duration)) {\r\n                //Livestreams always show as complete.\r\n                ratio = 1;\r\n            } else if (!isNaN(duration)) {\r\n                ratio = currentTime / duration;\r\n            }\r\n\r\n            that.$scrubfill.css(\"width\", that.css_percent(ratio));\r\n            that.$scrubknob.css(\"left\", that.css_percent(ratio));\r\n        });\r\n    };\r\n\r\n    /* Given an X coordinate, calculate the corresponding video seek time and\r\n     * return it.\r\n     *\r\n     * Input is in page co-ordinates. Input is scaled to output based on the\r\n     * CSS width and position of the scrubber. Output is bounded within the\r\n     * closed range [0, 1].\r\n     * \r\n     * Returns a promise with the correct seek time.\r\n     */\r\n    VideoPlayer_scrubber.prototype.mouse_to_ctime = function (page_x) {\r\n        return this.parent.get_duration().then(function (duration) {\r\n            return (page_x - this.$elem.offset().left) / this.$elem.width() * duration;\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Seek the parent player, but only if the proposed new time is valid.\r\n     */\r\n    VideoPlayer_scrubber.prototype.seek_if_valid = function (newTime, isFinal) {\r\n        if (isNaN(newTime) || !isFinite(newTime)) {\r\n            return;\r\n        }\r\n\r\n        this.parent.seek(newTime, isFinal);\r\n    };\r\n\r\n    // Drag event filtering\r\n\r\n    /* Start a drag operation; configuring the event filtering machinery to\r\n     * only recognize the click or touch that started the event chain.\r\n     */\r\n    VideoPlayer_scrubber.prototype.start_drag = function (evt) {\r\n        this.is_dragging = true;\r\n\r\n        if (evt.changedTouches !== undefined && evt.changedTouches.length > 0) {\r\n            this.drag_touch_id = evt.changedTouches[0].identifier;\r\n            return evt.changedTouches[0].pageX;\r\n        } else {\r\n            this.drag_touch_id = undefined;\r\n            return evt.pageX;\r\n        }\r\n    };\r\n\r\n    /* Retrieves the Page X coordinate from an event, ensuring that the correct\r\n     * finger is tracked across the entire event chain.\r\n     *\r\n     * Events will be ignored, and FALSE returned, if the event type that\r\n     * started the drag does not match the given event; or, if it's a touch\r\n     * event type, it will be ignored if there is no touch matching the current\r\n     * one.\r\n     */\r\n    VideoPlayer_scrubber.prototype.validate_drag = function (evt) {\r\n        var i;\r\n\r\n        if (this.is_dragging) {\r\n            if (this.drag_touch_id !== undefined) {\r\n                if (evt.changedTouches !== undefined) {\r\n                    for (i = 0; i < evt.changedTouches.length; i += 1) {\r\n                        if (evt.changedTouches[i].identifier === this.drag_touch_id) {\r\n                            return evt.changedTouches[i].pageX;\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                if (evt.changedTouches === undefined) {\r\n                    return evt.pageX;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    };\r\n\r\n    /* Retrieves the Page X coordinate from an event and turns off further drag\r\n     * processing.\r\n     *\r\n     * For the same reasons as validate_drag, non-matching events will not\r\n     * cancel drag processing. This function returns FALSE if this event was\r\n     * ignored.\r\n     */\r\n    VideoPlayer_scrubber.prototype.end_drag = function (evt) {\r\n        var px = this.validate_drag(evt);\r\n        if (px === false) {\r\n            return px;\r\n        }\r\n\r\n        this.is_dragging = false;\r\n        this.drag_touch_id = undefined;\r\n\r\n        return px;\r\n    };\r\n\r\n    /* Process a drag event given the incoming Page X.\r\n     *\r\n     * If FALSE is given, indicating an event filtered by validate_drag, this\r\n     * does nothing.\r\n     */\r\n    VideoPlayer_scrubber.prototype.handle_drag = function (pageX, final) {\r\n        var newtime;\r\n\r\n        if (pageX === false) {\r\n            return;\r\n        }\r\n\r\n        return this.mouse_to_ctime(pageX).then(function (newtime) {\r\n            this.seek_if_valid(newtime, final);\r\n            this.update_scrubber();\r\n        }.bind(this));\r\n    };\r\n\r\n    // Event handlers\r\n\r\n    VideoPlayer_scrubber.prototype.on_timeupdate = function () {\r\n        this.update_scrubber();\r\n    };\r\n\r\n    VideoPlayer_scrubber.prototype.on_dragstart_intent = function (evt) {\r\n        this.handle_drag(this.start_drag(evt), false);\r\n    };\r\n\r\n    VideoPlayer_scrubber.prototype.on_drag_intent = function (evt) {\r\n        this.handle_drag(this.validate_drag(evt), false);\r\n    };\r\n\r\n    VideoPlayer_scrubber.prototype.on_dragend_intent = function (evt) {\r\n        this.handle_drag(this.end_drag(evt), true);\r\n    };\r\n\r\n    VideoPlayer_scrubber.prototype.on_keyboard_nav = function (evt) {\r\n        var currentTime;\r\n        \r\n        this.parent.ready().then(function () {\r\n            return this.parent.get_current_time();\r\n        }.bind(this)).then(function (newCurrentTime) {\r\n            currentTime = newCurrentTime;\r\n            return this.parent.is_active();\r\n        }.bind(this)).then(function (is_active) {\r\n            if (!is_active) {\r\n                return;\r\n            }\r\n            \r\n            if (evt.keyCode === 37) { //LEFT\r\n                evt.preventDefault();\r\n                this.parent.seek(currentTime - 1.0);\r\n                this.update_scrubber();\r\n            } else if (evt.keyCode === 39) { // RIGHT\r\n                evt.preventDefault();\r\n                this.parent.seek(currentTime + 1.0);\r\n                this.update_scrubber();\r\n            }\r\n        });\r\n    };\r\n\r\n    /* Serves as a play/pause button for a connected VideoPlayer.\r\n     */\r\n    function VideoPlayer_mute(elem, parent) {\r\n        var that = this;\r\n        \r\n        Behaviors.init(VideoPlayer_mute, that, arguments);\r\n\r\n        that.parent = parent;\r\n\r\n        that.parent.ready().then(function () {\r\n            that.$elem.on(\"click touchend\", that.on_mute_intent.bind(that));\r\n\r\n            that.update_css_classes();\r\n        });\r\n    }\r\n\r\n    Behaviors.inherit(VideoPlayer_mute, Behaviors.Behavior);\r\n\r\n    VideoPlayer_mute.QUERY = \"[data-videoplayer-mute]\";\r\n\r\n    VideoPlayer_mute.prototype.update_css_classes = function () {\r\n        this.parent.is_muted().then(function (is_muted) {\r\n            if (is_muted) {\r\n                this.$elem.addClass(\"is-VideoPlayer--muted\");\r\n                this.$elem.removeClass(\"is-VideoPlayer--audible\");\r\n            } else {\r\n                this.$elem.removeClass(\"is-VideoPlayer--muted\");\r\n                this.$elem.addClass(\"is-VideoPlayer--audible\");\r\n            }\r\n        }.bind(this));\r\n    };\r\n\r\n    VideoPlayer_mute.prototype.toggle_mute = function () {\r\n        this.parent.is_muted().then(function (is_muted) {\r\n            if (is_muted) {\r\n                this.parent.unmute();\r\n            } else {\r\n                this.parent.mute();\r\n            }\r\n        }.bind(this));\r\n    };\r\n\r\n    VideoPlayer_mute.prototype.on_mute_intent = function () {\r\n        this.toggle_mute();\r\n        this.update_css_classes();\r\n    };\r\n\r\n    // Player API adaptations\r\n\r\n\r\n    /* Thin implementation for a VideoPlayer that consumes an HTML5 video\r\n     * directly. Also provides a good demonstration that the VideoPlayer APIs\r\n     * are a very thin wrapper over HTMLMediaElement.\r\n     */\r\n    function VideoPlayer__html5(elem) {\r\n        this.$video = $(elem).find(\"video\");\r\n\r\n        Behaviors.init(VideoPlayer__html5, this, arguments);\r\n    }\r\n\r\n    Behaviors.inherit(VideoPlayer__html5, VideoPlayer);\r\n\r\n    VideoPlayer__html5.QUERY = \"[data-videoplayer='html5']\";\r\n\r\n    /* Plays the video, if loaded.\r\n     */\r\n    VideoPlayer__html5.prototype.play = function () {\r\n        this.$video[0].play();\r\n    };\r\n\r\n    /* Pauses the video.\r\n     */\r\n    VideoPlayer__html5.prototype.pause = function () {\r\n        this.$video[0].pause();\r\n    };\r\n\r\n    /* Mute the video\r\n     */\r\n    VideoPlayer__html5.prototype.mute = function () {\r\n        this.$video[0].muted = true;\r\n    };\r\n\r\n    /* Unmute the video\r\n     */\r\n    VideoPlayer__html5.prototype.unmute = function () {\r\n        this.$video[0].muted = false;\r\n    };\r\n\r\n    /* Returns the current player position.\r\n     * \r\n     * This function returns a promise which resolves to the current time.\r\n     */\r\n    VideoPlayer__html5.prototype.get_current_time = function () {\r\n        return Promise.resolve(this.$video[0].currentTime);\r\n    };\r\n\r\n    /* Seek the video to the number of seconds indicated in time.\r\n     */\r\n    VideoPlayer__html5.prototype.seek = function (time) {\r\n        this.$video[0].currentTime = time;\r\n    };\r\n\r\n    /* Check the video's duration.\r\n     *\r\n     * Returns the media's length in seconds.\r\n     *\r\n     * NaN is returned if the duration is unknown (check with isNaN).\r\n     * Infinity is returned if this is a streaming video.\r\n     * \r\n     * This function returns a promise which resolves to the aformentioned\r\n     * return value.\r\n     */\r\n    VideoPlayer__html5.prototype.get_duration = function () {\r\n        return Promise.resolve(this.$video[0].duration);\r\n    };\r\n\r\n    /* Check if the video is paused.\r\n     * \r\n     * This function returns a promise which resolves to the aformentioned\r\n     * return value.\r\n     */\r\n    VideoPlayer__html5.prototype.is_paused = function () {\r\n        return Promise.resolve(this.$video[0].paused);\r\n    };\r\n\r\n    /* Check if the video is muted.\r\n     * \r\n     * This function returns a promise which resolves to the aformentioned\r\n     * return value.\r\n     */\r\n    VideoPlayer__html5.prototype.is_muted = function () {\r\n        return Promise.resolve(this.$video[0].muted);\r\n    };\r\n\r\n    /* Check the volume of the video.\r\n     * \r\n     * This function returns a promise which resolves to the aformentioned\r\n     * return value.\r\n     */\r\n    VideoPlayer__html5.prototype.get_volume = function () {\r\n        return Promise.resolve(this.$video[0].volume);\r\n    };\r\n\r\n    /* Register an event handler for changes to the video's playback state.\r\n     *\r\n     * This corresponds exactly to matching the playing, play, and pause events\r\n     * and other video service APIs should ensure their event handler triggers\r\n     * on similar conditions.\r\n     */\r\n    VideoPlayer__html5.prototype.add_statechange_listener = function (listen) {\r\n        this.$video.on(\"playing play pause\", listen);\r\n    };\r\n\r\n    /* Register an event handler for changes to the video's playback time.\r\n     *\r\n     * This corresponds to the timeupdate event on HTMLMediaElement. This event\r\n     * is permitted not to register an event if it returns FALSE, indicating\r\n     * that timeupdates are not provided by this player type.\r\n     */\r\n    VideoPlayer__html5.prototype.add_timeupdate_listener = function (listen) {\r\n        this.$video.on(\"timeupdate\", listen);\r\n    };\r\n\r\n    /* This VideoPlayer consumes a YouTube iframe using the YouTube API.\r\n     * See https://developers.google.com/youtube/iframe_api_reference\r\n     */\r\n    function VideoPlayer__youtube(elem) {\r\n        var that = this;\r\n\r\n        Behaviors.init(VideoPlayer__youtube, that, arguments);\r\n\r\n        this.$iframe = $(elem).find(\"iframe\");\r\n        this.id = this.$iframe.attr(\"id\");\r\n        if (this.id === undefined) {\r\n            //Randomly generate an ID if one was not provided.\r\n            this.id = \"VideoPlayer-random_id--\" + Math.random() * 1024 * 1024;\r\n            this.$iframe.attr(\"id\", this.id);\r\n        }\r\n\r\n        this.player_fully_loaded = false;\r\n    }\r\n\r\n    Behaviors.inherit(VideoPlayer__youtube, VideoPlayer);\r\n\r\n    VideoPlayer__youtube.QUERY = \"[data-videoplayer='youtube']\";\r\n\r\n    /* Install the YouTube API, if not already installed.\r\n     *\r\n     * This is an asynchronous operation, so we return a Promise that resolves\r\n     * when YouTube's API is available. Invocation works like so:\r\n     *\r\n     * VideoPlayer__youtube.api().then(function () {\r\n     *     //do stuff...\r\n     * })\r\n     */\r\n    VideoPlayer__youtube.api = function () {\r\n        if (VideoPlayer__youtube.install_promise === undefined) {\r\n            VideoPlayer__youtube.install_promise = new Promise(function (resolve, reject) {\r\n                var tag, firstScriptTag;\r\n\r\n                tag = document.createElement(\"script\");\r\n                tag.src = \"https://www.youtube.com/iframe_api\";\r\n                firstScriptTag = document.getElementsByTagName('script')[0];\r\n                firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);\r\n\r\n                window.onYouTubeIframeAPIReady = VideoPlayer__youtube.api_ready_handler(resolve, reject);\r\n            });\r\n        }\r\n\r\n        return VideoPlayer__youtube.install_promise;\r\n    };\r\n\r\n    /* Creates the function that gets called when the YouTube API is ready.\r\n     */\r\n    VideoPlayer__youtube.api_ready_handler = function (resolve, reject) {\r\n        return function () {\r\n            resolve();\r\n        };\r\n    };\r\n\r\n    /* Returns a promise which resolves when the player is ready to accept\r\n     * other API calls.\r\n     *\r\n     * Calling those other API calls outside of a then() block from the promise\r\n     * returned by this function is a good way to have a bad time.\r\n     */\r\n    VideoPlayer__youtube.prototype.ready = function () {\r\n        var that = this;\r\n        \r\n        if (that.ready_promise === undefined) {\r\n            that.ready_promise = VideoPlayer__youtube.api().then(function () {\r\n                that.player = new window.YT.Player(that.id, {\r\n                    \"playerVars\": {\r\n                        \"enablejsapi\": true\r\n                    }\r\n                });\r\n\r\n                return new Promise(function (resolve, reject) {\r\n                    if (that.player_fully_loaded) {\r\n                        resolve();\r\n                    } else {\r\n                        that.player.addEventListener(\"onReady\", function () {\r\n                            that.player_fully_loaded = true;\r\n                            resolve();\r\n                        });\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        \r\n        return that.ready_promise;\r\n    };\r\n\r\n    /* Plays the video, if loaded.\r\n     */\r\n    VideoPlayer__youtube.prototype.play = function () {\r\n        this.ready().then(function () {\r\n            this.player.playVideo();\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Pauses the video.\r\n     */\r\n    VideoPlayer__youtube.prototype.pause = function () {\r\n        this.ready().then(function () {\r\n            this.player.pauseVideo();\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Mute the video\r\n     */\r\n    VideoPlayer__youtube.prototype.mute = function () {\r\n        this.ready().then(function () {\r\n            this.player.mute();\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Unmute the video\r\n     */\r\n    VideoPlayer__youtube.prototype.unmute = function () {\r\n        this.ready().then(function () {\r\n            this.player.unMute();\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Returns the current player position.\r\n     * \r\n     * This function returns a promise which resolves to the current time.\r\n     */\r\n    VideoPlayer__youtube.prototype.get_current_time = function () {\r\n        return this.ready().then(function () {\r\n            return this.player.getCurrentTime();\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Seek the video to the number of seconds indicated in time.\r\n     *\r\n     * The seek_commit parameter should be FALSE if and only if the seek\r\n     * resulted from a mousedrag and you expect to get more seek operations.\r\n     */\r\n    VideoPlayer__youtube.prototype.seek = function (time, seek_commit) {\r\n        return this.ready().then(function () {\r\n            return this.player.seekTo(time, seek_commit);\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Check the video's duration.\r\n     *\r\n     * Returns the media's length in seconds.\r\n     *\r\n     * NaN is returned if the duration is unknown (check with isNaN).\r\n     * Infinity is returned if this is a streaming video.\r\n     *\r\n     * SPEC VIOLATION: YouTube does not indicate if the player is playing a\r\n     * live event, so live-streaming players will have incorrect duration info.\r\n     * \r\n     * This function returns a promise which resolves to the aformentioned\r\n     * return value.\r\n     */\r\n    VideoPlayer__youtube.prototype.get_duration = function () {\r\n        return this.ready().then(function () {\r\n            var duration = this.player.getDuration();\r\n\r\n            if (duration === 0) {\r\n                return NaN;\r\n            }\r\n\r\n            return duration;\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Check if the video is paused.\r\n     *\r\n     * TODO: We naively interpret YouTube's player state, does player state 2\r\n     * correspond to HTMLMediaElement/VideoPlayer__html5's .paused attribute?\r\n     * Or are there other player states that count as paused by HTML5?\r\n     * \r\n     * This function returns a promise which resolves to the aformentioned\r\n     * return value.\r\n     */\r\n    VideoPlayer__youtube.prototype.is_paused = function () {\r\n        return this.ready().then(function () {\r\n            var ps = this.player.getPlayerState();\r\n            return ps === 2 || ps === -1 || ps === 5;\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Check if the video is muted.\r\n     * \r\n     * This function returns a promise which resolves to the aformentioned\r\n     * return value.\r\n     */\r\n    VideoPlayer__youtube.prototype.is_muted = function () {\r\n        return this.ready().then(function () {\r\n            return this.player.isMuted();\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Check the volume of the video.\r\n     *\r\n     * YouTube works in percentage units for some reason.\r\n     * \r\n     * This function returns a promise which resolves to the aformentioned\r\n     * return value.\r\n     */\r\n    VideoPlayer__youtube.prototype.get_volume = function () {\r\n        return this.ready().then(function () {\r\n            return this.player.getVolume() / 100;\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Register an event handler for changes to the video's playback state.\r\n     *\r\n     * This corresponds exactly to matching the playing, play, and pause events\r\n     * and other video service APIs should ensure their event handler triggers\r\n     * on similar conditions.\r\n     */\r\n    VideoPlayer__youtube.prototype.add_statechange_listener = function (listen) {\r\n        this.ready().then(function () {\r\n            this.player.addEventListener(\"onStateChange\", listen);\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Register an event handler for changes to the video's playback time.\r\n     *\r\n     * YouTube doesn't have this event type for some reason.\r\n     */\r\n    VideoPlayer__youtube.prototype.add_timeupdate_listener = function (listen) {\r\n        return false;\r\n    };\r\n\r\n    VideoPlayer__youtube.content_ready = function ($context) {\r\n        var Class = this;\r\n\r\n        if ($context.find(Class.QUERY).length > 0) {\r\n            Class.api().then(function () {\r\n                Class.find_markup($context);\r\n            });\r\n        }\r\n    };\r\n    \r\n    /* This VideoPlayer consumes a Vimeo iframe using their player controller.\r\n     * See https://github.com/vimeo/player.js\r\n     */\r\n    function VideoPlayer__vimeo(elem) {\r\n        var that = this;\r\n\r\n        Behaviors.init(VideoPlayer__vimeo, that, arguments);\r\n        \r\n        this.ready();\r\n    }\r\n\r\n    VideoPlayer__vimeo.QUERY = \"[data-videoplayer='vimeo']\";\r\n    \r\n    Behaviors.inherit(VideoPlayer__vimeo, VideoPlayer);\r\n    \r\n    /* Install the Vimeo API, if not already installed.\r\n     *\r\n     * This is an asynchronous operation, so we return a Promise that resolves\r\n     * when Vimeo's API is available. Invocation works like so:\r\n     *\r\n     * VideoPlayer__vimeo.api().then(function () {\r\n     *     //do stuff...\r\n     * })\r\n     */\r\n    VideoPlayer__vimeo.api = function () {\r\n        if (VideoPlayer__vimeo.install_promise === undefined) {\r\n            VideoPlayer__vimeo.install_promise = new Promise(function (resolve, reject) {\r\n                var tag, firstScriptTag;\r\n\r\n                tag = document.createElement(\"script\");\r\n                tag.src = \"https://player.vimeo.com/api/player.js\";\r\n                tag.onload = VideoPlayer__vimeo.api_ready_handler(resolve, reject);\r\n                tag.async = true;\r\n                firstScriptTag = document.getElementsByTagName('script')[0];\r\n                firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);\r\n            });\r\n        }\r\n\r\n        return VideoPlayer__vimeo.install_promise;\r\n    };\r\n\r\n    /* Creates the function that gets called when the Vimeo API is ready.\r\n     */\r\n    VideoPlayer__vimeo.api_ready_handler = function (resolve, reject) {\r\n        function wait_for_vimeo() {\r\n            if (window.Vimeo !== undefined) {\r\n                resolve();\r\n            } else {\r\n                window.setTimeout(wait_for_vimeo, 10);\r\n            }\r\n        }\r\n        \r\n        return wait_for_vimeo;\r\n    };\r\n    \r\n    /* Returns a promise which resolves when the player is ready to accept\r\n     * other API calls.\r\n     *\r\n     * Calling those other API calls outside of a then() block from the promise\r\n     * returned by this function is a good way to have a bad time.\r\n     */\r\n    VideoPlayer__vimeo.prototype.ready = function () {\r\n        var that = this;\r\n        \r\n        if (this.ready_promise === undefined) {\r\n            this.ready_promise = VideoPlayer__vimeo.api().then(function () {\r\n                this.player = new window.Vimeo.Player(this.$elem);\r\n            }.bind(this));\r\n        }\r\n        \r\n        return this.ready_promise;\r\n    };\r\n\r\n    /* Plays the video, if loaded.\r\n     */\r\n    VideoPlayer__vimeo.prototype.play = function () {\r\n        return this.ready().then(function () {\r\n            this.player.play();\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Pauses the video.\r\n     */\r\n    VideoPlayer__vimeo.prototype.pause = function () {\r\n        return this.ready().then(function () {\r\n            this.player.pause();\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Mute the video\r\n     */\r\n    VideoPlayer__vimeo.prototype.mute = function () {\r\n        return this.ready().then(function () {\r\n            return this.player.getVolume();\r\n        }.bind(this)).then(function (volume) {\r\n            this.preMuteVolume = volume;\r\n            this.player.setVolume(0);\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Unmute the video\r\n     */\r\n    VideoPlayer__vimeo.prototype.unmute = function () {\r\n        return this.ready().then(function () {\r\n            return this.player.setVolume(this.preMuteVolume || 1.0);\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Returns the current player position.\r\n     * \r\n     * This function returns a promise which resolves to the current time.\r\n     */\r\n    VideoPlayer__vimeo.prototype.get_current_time = function () {\r\n        return this.ready().then(function () {\r\n            return this.player.getCurrentTime();\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Seek the video to the number of seconds indicated in time.\r\n     *\r\n     * The seek_commit parameter should be FALSE if and only if the seek\r\n     * resulted from a mousedrag and you expect to get more seek operations.\r\n     * \r\n     * As a unique quirk of the Vimeo API, the returned promise will resolve\r\n     * to the actual seek time adopted by the player.\r\n     */\r\n    VideoPlayer__vimeo.prototype.seek = function (time, seek_commit) {\r\n        return this.ready().then(function () {\r\n            return this.player.setCurrentTime(time);\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Check the video's duration.\r\n     *\r\n     * Returns the media's length in seconds.\r\n     *\r\n     * NaN is returned if the duration is unknown (check with isNaN).\r\n     * Infinity is returned if this is a streaming video.\r\n     * \r\n     * This function returns a promise which resolves to the aformentioned\r\n     * return value.\r\n     */\r\n    VideoPlayer__vimeo.prototype.get_duration = function () {\r\n        return this.ready().then(function () {\r\n            return this.player.getDuration();\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Check if the video is paused.\r\n     * \r\n     * This function returns a promise which resolves to the aformentioned\r\n     * return value.\r\n     */\r\n    VideoPlayer__vimeo.prototype.is_paused = function () {\r\n        return this.ready().then(function () {\r\n            return this.player.getPaused();\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Check if the video is muted.\r\n     * \r\n     * This function returns a promise which resolves to the aformentioned\r\n     * return value.\r\n     */\r\n    VideoPlayer__vimeo.prototype.is_muted = function () {\r\n        return this.ready().then(function () {\r\n            return this.get_volume();\r\n        }.bind(this)).then(function (volume) {\r\n            return volume === 0.0;\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Check the volume of the video.\r\n     * \r\n     * This function returns a promise which resolves to the aformentioned\r\n     * return value.\r\n     */\r\n    VideoPlayer__vimeo.prototype.get_volume = function () {\r\n        return this.ready().then(function () {\r\n            return this.player.getVolume();\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Register an event handler for changes to the video's playback state.\r\n     *\r\n     * This corresponds exactly to matching the playing, play, and pause events\r\n     * and other video service APIs should ensure their event handler triggers\r\n     * on similar conditions.\r\n     */\r\n    VideoPlayer__vimeo.prototype.add_statechange_listener = function (listen) {\r\n        return this.ready().then(function () {\r\n            return this.player.on(\"play\", listen);\r\n            return this.player.on(\"pause\", listen);\r\n            return this.player.on(\"ended\", listen);\r\n        }.bind(this));\r\n    };\r\n\r\n    /* Register an event handler for changes to the video's playback time.\r\n     */\r\n    VideoPlayer__vimeo.prototype.add_timeupdate_listener = function (listen) {\r\n        return this.ready().then(function () {\r\n            return this.player.on(\"timeupdate\", listen);\r\n        }.bind(this));\r\n    };\r\n    \r\n    VideoPlayer__vimeo.content_ready = function ($context) {\r\n        var Class = this;\r\n\r\n        if ($context.find(Class.QUERY).length > 0) {\r\n            Class.api().then(function () {\r\n                Class.find_markup($context);\r\n            });\r\n        }\r\n    };\r\n\r\n    Behaviors.register_behavior(VideoPlayer__html5);\r\n    Behaviors.register_behavior(VideoPlayer__youtube);\r\n    Behaviors.register_behavior(VideoPlayer__vimeo);\r\n    \r\n    module.VideoPlayer = VideoPlayer;\r\n    module.VideoPlayer_playpause = VideoPlayer_playpause;\r\n    module.VideoPlayer_scrubber = VideoPlayer_scrubber;\r\n    module.VideoPlayer_mute = VideoPlayer_mute;\r\n    module.VideoPlayer_offcanvas = VideoPlayer_offcanvas;\r\n    module.VideoPlayer__html5 = VideoPlayer__html5;\r\n    module.VideoPlayer__youtube = VideoPlayer__youtube;\r\n    module.VideoPlayer__vimeo = VideoPlayer__vimeo;\r\n    return module;\r\n}));\r\n"],"sourceRoot":"/source/"}