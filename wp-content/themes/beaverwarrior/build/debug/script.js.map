{"version":3,"sources":["aPolyfill_promise.min.js","apolyfill_Array.includes.js","apolyfill_Function.name.js","apolyfill_String.endsWith.js","apolyfill_String.includes.js","apolyfill_String.startsWith.js","behaviors.js","functions.js","wow.js","AffixColumn/AffixColumn.js","AnimatedBackgrounds/AtlasPlayer.js","Animations/Animations.js","CollapseContent/collapse_content.js","ContentSlider/ContentSlider.js","Depaginate/depaginate.js","FiftyFiftySplit/FiftyFiftySplit.js","GoogleMap/GoogleMap.js","Offcanvas/betteroffcanvas.js","OpenPositionDetails/OpenPositionDetails.js","PageTransition/page_transition.js","ScrollEffects/ScrollEffects.js","SiteHeader/AccountSlideIn.js","SiteHeader/SiteHeader.js","StaffGrid/StaffGrid.js","TabbedContent/tabbed_content.js","TenTenHero/FiftyFiftySplit.js","ThreePostsGrid/ThreePostsGrid.js","UTM/utm_preserve.js","VideoPlayer/VideoPlayer.js"],"names":[],"mappings":"AAAA,6lFCAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ECjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MCtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ECPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ECbA;AACA;AACA;AACA;AACA,ECJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CChVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ECjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CCjgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CClcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CCzZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CCjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CCnIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KCpTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KCjsBA,CCAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KCnIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CC/6BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IC3KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CC7ZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CCtUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CCtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CCtKA,CCAA,CCAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../script.js","sourcesContent":["!function(e){function n(){}function t(e,n){return function(){e.apply(n,arguments)}}function o(e){if(\"object\"!=typeof this)throw new TypeError(\"Promises must be constructed via new\");if(\"function\"!=typeof e)throw new TypeError(\"not a function\");this._state=0,this._handled=!1,this._value=void 0,this._deferreds=[],s(e,this)}function i(e,n){for(;3===e._state;)e=e._value;return 0===e._state?void e._deferreds.push(n):(e._handled=!0,void o._immediateFn(function(){var t=1===e._state?n.onFulfilled:n.onRejected;if(null===t)return void(1===e._state?r:u)(n.promise,e._value);var o;try{o=t(e._value)}catch(i){return void u(n.promise,i)}r(n.promise,o)}))}function r(e,n){try{if(n===e)throw new TypeError(\"A promise cannot be resolved with itself.\");if(n&&(\"object\"==typeof n||\"function\"==typeof n)){var i=n.then;if(n instanceof o)return e._state=3,e._value=n,void f(e);if(\"function\"==typeof i)return void s(t(i,n),e)}e._state=1,e._value=n,f(e)}catch(r){u(e,r)}}function u(e,n){e._state=2,e._value=n,f(e)}function f(e){2===e._state&&0===e._deferreds.length&&o._immediateFn(function(){e._handled||o._unhandledRejectionFn(e._value)});for(var n=0,t=e._deferreds.length;n<t;n++)i(e,e._deferreds[n]);e._deferreds=null}function c(e,n,t){this.onFulfilled=\"function\"==typeof e?e:null,this.onRejected=\"function\"==typeof n?n:null,this.promise=t}function s(e,n){var t=!1;try{e(function(e){t||(t=!0,r(n,e))},function(e){t||(t=!0,u(n,e))})}catch(o){if(t)return;t=!0,u(n,o)}}var a=setTimeout;o.prototype[\"catch\"]=function(e){return this.then(null,e)},o.prototype.then=function(e,t){var o=new this.constructor(n);return i(this,new c(e,t,o)),o},o.all=function(e){var n=Array.prototype.slice.call(e);return new o(function(e,t){function o(r,u){try{if(u&&(\"object\"==typeof u||\"function\"==typeof u)){var f=u.then;if(\"function\"==typeof f)return void f.call(u,function(e){o(r,e)},t)}n[r]=u,0===--i&&e(n)}catch(c){t(c)}}if(0===n.length)return e([]);for(var i=n.length,r=0;r<n.length;r++)o(r,n[r])})},o.resolve=function(e){return e&&\"object\"==typeof e&&e.constructor===o?e:new o(function(n){n(e)})},o.reject=function(e){return new o(function(n,t){t(e)})},o.race=function(e){return new o(function(n,t){for(var o=0,i=e.length;o<i;o++)e[o].then(n,t)})},o._immediateFn=\"function\"==typeof setImmediate&&function(e){setImmediate(e)}||function(e){a(e,0)},o._unhandledRejectionFn=function(e){\"undefined\"!=typeof console&&console&&console.warn(\"Possible Unhandled Promise Rejection:\",e)},o._setImmediateFn=function(e){o._immediateFn=e},o._setUnhandledRejectionFn=function(e){o._unhandledRejectionFn=e},\"undefined\"!=typeof module&&module.exports?module.exports=o:e.Promise||(e.Promise=o)}(this);","// From https://github.com/kevlatus/polyfill-array-includes/blob/master/array-includes.js\nif (!Array.prototype.includes) {\n    Object.defineProperty(Array.prototype, 'includes', {\n        value: function (searchElement, fromIndex) {\n            // 1. Let O be ? ToObject(this value).\n            if (this == null) {\n                throw new TypeError('\"this\" is null or not defined');\n            }\n\n            var o = Object(this);\n\n            // 2. Let len be ? ToLength(? Get(O, \"length\")).\n            var len = o.length >>> 0;\n\n            // 3. If len is 0, return false.\n            if (len === 0) {\n                return false;\n            }\n\n            // 4. Let n be ? ToInteger(fromIndex).\n            //    (If fromIndex is undefined, this step produces the value 0.)\n            var n = fromIndex | 0;\n\n            // 5. If n â‰¥ 0, then\n            //  a. Let k be n.\n            // 6. Else n < 0,\n            //  a. Let k be len + n.\n            //  b. If k < 0, let k be 0.\n            var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);\n\n            function sameValueZero(x, y) {\n                return x === y || (typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y));\n            }\n\n            // 7. Repeat, while k < len\n            while (k < len) {\n                // a. Let elementK be the result of ? Get(O, ! ToString(k)).\n                // b. If SameValueZero(searchElement, elementK) is true, return true.\n                // c. Increase k by 1.\n                if (sameValueZero(o[k], searchElement)) {\n                    return true;\n                }\n                k++;\n            }\n\n            // 8. Return false\n            return false;\n        }\n    });\n}","//https://github.com/JamesMGreene/Function.name/blob/master/Function.name.js\n(function() {\n\nvar fnNameMatchRegex = /^\\s*function\\s+([^\\(\\s]*)\\s*/;\n\nfunction _name() {\n  var match, name;\n  if (this === Function || this === Function.prototype.constructor) {\n    name = \"Function\";\n  }\n  else if (this !== Function.prototype) {\n    match = (\"\" + this).match(fnNameMatchRegex);\n    name = match && match[1];\n  }\n  return name || \"\";\n}\n\n// Inspect the polyfill-ability of this browser\nvar needsPolyfill = !(\"name\" in Function.prototype && \"name\" in (function x() {}));\nvar canDefineProp = typeof Object.defineProperty === \"function\" &&\n  (function() {\n    var result;\n    try {\n      Object.defineProperty(Function.prototype, \"_xyz\", {\n        get: function() {\n          return \"blah\";\n        },\n        configurable: true\n      });\n      result = Function.prototype._xyz === \"blah\";\n      delete Function.prototype._xyz;\n    }\n    catch (e) {\n      result = false;\n    }\n    return result;\n  })();\nvar canDefineGetter = typeof Object.prototype.__defineGetter__ === \"function\" &&\n  (function() {\n    var result;\n    try {\n      Function.prototype.__defineGetter__(\"_abc\", function() {\n        return \"foo\";\n      });\n      result = Function.prototype._abc === \"foo\";\n      delete Function.prototype._abc;\n    }\n    catch (e) {\n      result = false;\n    }\n    return result;\n  })();\n\n\n\n// Add the \"private\" property for testing, even if the real property can be polyfilled\nFunction.prototype._name = _name;\n\n\n// Polyfill it!\n// For:\n//  * IE >=9 <12\n//  * Chrome <33\nif (needsPolyfill) {\n  // For:\n  //  * IE >=9 <12\n  //  * Chrome >=5 <33\n  if (canDefineProp) {\n    Object.defineProperty(Function.prototype, \"name\", {\n      get: function() {\n        var name = _name.call(this);\n\n        // Since named function definitions have immutable names, also memoize the\n        // output by defining the `name` property directly on this Function\n        // instance so that this polyfill will not need to be invoked again\n        if (this !== Function.prototype) {\n          Object.defineProperty(this, \"name\", {\n            value: name,\n            configurable: true\n          });\n        }\n\n        return name;\n      },\n      configurable: true\n    });\n  }\n  // For:\n  //  * Chrome <5\n  else if (canDefineGetter) {\n    // NOTE:\n    // The snippet:\n    //\n    //     x.__defineGetter__('y', z);\n    //\n    // ...is essentially equivalent to:\n    //\n    //     Object.defineProperty(x, 'y', {\n    //       get: z,\n    //       configurable: true,  // <-- key difference #1\n    //       enumerable: true     // <-- key difference #2\n    //     });\n    //\n    Function.prototype.__defineGetter__(\"name\", function() {\n      var name = _name.call(this);\n\n      // Since named function definitions have immutable names, also memoize the\n      // output by defining the `name` property directly on this Function\n      // instance so that this polyfill will not need to be invoked again\n      if (this !== Function.prototype) {\n        this.__defineGetter__(\"name\", function() { return name; });\n      }\n\n      return name;\n    });\n  }\n}\n\n})();","if (!String.prototype.endsWith) {\n    String.prototype.endsWith = function(search, this_len) {\n        if (this_len === undefined || this_len > this.length) {\n            this_len = this.length;\n        }\n        return this.substring(this_len - search.length, this_len) === search;\n    };\n}","if (!String.prototype.includes) {\n    String.prototype.includes = function(search, start) {\n        'use strict';\n        if (typeof start !== 'number') {\n            start = 0;\n        }\n\n        if (start + search.length > this.length) {\n            return false;\n        } else {\n            return this.indexOf(search, start) !== -1;\n        }\n    };\n}","if (!String.prototype.startsWith) {\n    String.prototype.startsWith = function(search, pos) {\n        return this.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n    };\n}","/*global define, window, document*/\n\n(function (root, factory) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(\"Behaviors\", [\"jquery\"], factory);\n    } else {\n        root.Behaviors = factory(root.jQuery);\n    }\n}(this, function ($) {\n    \"use strict\";\n\n    var module = {},\n        behavior_registry = {},\n        content_ready_listeners = [],\n        ElementMissingError = error(\"ElementMissingError\");\n    \n    /* Throttle an event handler.\n     *\n     * Returns a function which, no matter how frequently it's called, will\n     * only trigger a maximum of once per timeout period. More specifically,\n     * the first event will always be processed, then, no events will process\n     * until the end of the timeout period. If one or more events occurred\n     * during this period, the last event recieved will trigger immediately\n     * after the end of the timeout period, as well as restart the throttling\n     * period. Any preceding events will be discarded.\n     *\n     * Not to be confused with a debounce, which only fires the event handler\n     * at the end of a string of events spaced closer than the timeout period.\n     *\n     * The nature of this function means that any passed in function's return\n     * value will be discarded.\n     */\n    function throttle_single(func, timeout) {\n        var lastTimeout, afterLastArgs, afterLastThis;\n\n        function unthrottle() {\n            if (afterLastArgs !== undefined) {\n                func.apply(afterLastThis, afterLastArgs);\n                afterLastArgs = undefined;\n                lastTimeout = window.setTimeout(unthrottle, timeout);\n            } else {\n                lastTimeout = undefined;\n            }\n        }\n\n        return function () {\n            var myThis = this, myArgs = [], i;\n\n            for (i = 0; i < arguments.length; i += 1) {\n                myArgs.push(arguments[i]);\n            }\n\n            if (lastTimeout === undefined) {\n                func.apply(myThis, myArgs);\n                lastTimeout = window.setTimeout(unthrottle, timeout);\n            } else {\n                afterLastArgs = myArgs;\n                afterLastThis = myThis;\n            }\n        };\n    }\n\n    function Behavior(elem) {\n        //Do something to elem\n        this.$elem = $(elem);\n    }\n\n    /* Find a behavior's markup.\n     *\n     * The $context argument passed to this function is the jQuery element that\n     * will be searched for behaviors. Any additional arguments will be passed\n     * to Behavior.locate and ultimately to the behavior's constructor.\n     */\n    Behavior.find_markup = function ($context) {\n        var results = [], i, splitArgs = [], Class = this;\n\n        for (i = 1; i < arguments.length; i += 1) {\n            splitArgs.push(arguments[i]);\n        }\n        \n        function processElem(index, elem) {\n            var locateArgs = [elem].concat(splitArgs);\n\n            results.push(Class.locate.apply(Class, locateArgs));\n        }\n        \n        $context.filter(Class.QUERY).each(processElem);\n        $context.find(Class.QUERY).each(processElem);\n\n        return results;\n    };\n\n    /* Locate a behavior onto an element, returning an instance of that\n     * behavior that you can work with.\n     *\n     * A behavior locates onto an element by instantiating an instance of\n     * itself and installing it onto the markup's jQuery data. Therefore, we\n     * will only instantiate that behavior once; and further calls to .locate\n     * instead return the same object. Thus, it is safe to use .locate as a\n     * general accessor - it is idempotent.\n     *\n     * The elem argument indicates the element that the behavior should locate\n     * onto. Further arguments are passed onto the constructor.\n     *\n     * TODO: Is there a non-jQuery way of handling this?\n     */\n    Behavior.locate = function (elem, ...objectArgs) {\n        var $elem = $(elem), new_object, i, Class = this,\n            rc = $elem.data(\"behaviors-registered-classes\");\n        \n        if ($elem.length === 0) {\n            throw new ElementMissingError(\"Attempted to locate a Behavior onto an empty element query.\");\n        }\n\n        if (rc === undefined) {\n            rc = {};\n        }\n\n        if (rc[Class.QUERY] === undefined) {\n            rc[Class.QUERY] = new Class(elem, ...objectArgs);\n        } else {\n            new_object = rc[Class.QUERY];\n        }\n\n        $elem.data(\"behaviors-registered-classes\", rc);\n\n        return new_object;\n    };\n\n    /* Respond to the presence of new content on the page.\n     *\n     * By default, we attempt to find markup on all children of the context.\n     * Subclasses may do something crazier, like say delay behavior processing\n     * until some third-party API is loaded.\n     *\n     * Consider this roughly equivalent to $(document).ready() callbacks.\n     */\n    Behavior.content_ready = function ($context) {\n        var Class = this;\n\n        Class.find_markup($context);\n    };\n    \n    /* Respond to the impending removal of content from the page.\n     * \n     * Most behaviors that only attach event handlers to their own content are\n     * safe and do not need to implement content removal support: they will\n     * inherently \"fall away\".\n     * \n     * However, behaviors that run a constant animation kernel or attach event\n     * handlers to elements outside of their own ownership must provide a\n     * mechanism to detach those event handlers and stop those kernels.\n     */\n    Behavior.content_removal = function ($context) {\n        var Class = this,\n            $attached_elems = $context.find(Class.QUERY);\n        \n        //Iterate through each element and see if our behavior has located upon\n        //them. We don't just call .find_markup/.locate since we don't want to\n        //risk initializing something just to tear it down one cycle later.\n        $attached_elems.each(function (index, attach_elem) {\n            var $elem = $(attach_elem),\n                rc = $elem.data(\"behaviors-registered-classes\");\n            \n            if (rc === undefined) {\n                return;\n            }\n            \n            if (rc[Class.QUERY] === undefined) {\n                return;\n            }\n            \n            if (rc[Class.QUERY].deinitialize === undefined) {\n                return;\n            }\n            \n            rc[Class.QUERY].deinitialize();\n        });\n    };\n\n    /* Register a behavior so that it can respond to global events such as new\n     * content becoming ready.\n     *\n     * It is not always appropriate to register your behavior to recieve load\n     * events. Generally, if this is a behavior you would initialize yourself,\n     * perhaps with special arguments, then you should not register that here.\n     */\n    function register_behavior(Class, name) {\n        if (name === undefined) {\n            name = Class.QUERY;\n        }\n\n        if (behavior_registry[name] === Class) {\n            console.warn(\"Attempted to register the same behavior twice to the same CSS selector \\\"\" + name + \"\\\".\");\n            return;\n        } else if (behavior_registry[name] !== undefined) {\n            console.error(\"Attempted to register a second behavior onto CSS selector \\\"\"\n                + name + \"\\\". Only one behavior may be registered to a given CSS selector \"\n                + \"at a given time. The offending classes are \" + Class.name\n                + \" and \" + behavior_registry[name].name + \".\");\n            \n            return;\n        }\n\n        behavior_registry[name] = Class;\n    }\n    \n    /* Register a function that is called when content is ready.\n     * \n     * This function should only be used for things that are not a Behavior.\n     * Proper behaviors should be registered using register_behavior for future\n     * uses. Non-behavior listeners get registered here so that future uses of\n     * behavior registration do not conflict with non-Behavior listeners.\n     */\n    function register_content_listener(func) {\n        content_ready_listeners.push(func);\n    }\n\n    /* Indicate that some new content is ready.\n     *\n     * The given content will be passed onto all registered behaviors.\n     *\n     * CMS/frameworks with their own ready mechanism will need to ship their\n     * own replacement/wrapper for this function that pushes calls to this\n     * function over to that mechanism; and calls from that mechanism need to\n     * come back here.\n     */\n    function content_ready($context) {\n        var k, i;\n        \n        function do_later(obj, func) {\n            window.setTimeout(func.bind(obj, $context), 0);\n        }\n        \n        for (i = 0; i < content_ready_listeners.length; i += 1) {\n            do_later(undefined, content_ready_listeners[i]);\n        }\n\n        for (k in behavior_registry) {\n            if (behavior_registry.hasOwnProperty(k)) {\n                do_later(behavior_registry[k], behavior_registry[k].content_ready);\n            }\n        }\n    }\n    \n    /* Indicate that content is about to be removed.\n     * \n     * Registered behaviors with destructors will be called upon to remove any\n     * external event handlers or animation kernels preventing them from being\n     * terminated by the JS runtime.\n     * \n     * TODO: Add content_removal listener functions.\n     */\n    function content_removal($context) {\n        var k, i;\n        \n        function do_later(obj, func) {\n            window.setTimeout(func.bind(obj, $context), 0);\n        }\n        \n        for (k in behavior_registry) {\n            if (behavior_registry.hasOwnProperty(k)) {\n                do_later(behavior_registry[k], behavior_registry[k].content_removal);\n            }\n        }\n    }\n    \n    function error(error_class_name, ParentClass) {\n        if (error_class_name === undefined) {\n            throw new Error(\"Please name your error subclass.\");\n        }\n\n        if (!(ParentClass instanceof Function)) {\n            ParentClass = Error;\n        }\n\n        var SubError = function (message) {\n            var err = new Error(message);\n            err.name = error_class_name;\n\n            this.name = error_class_name;\n            this.message = err.message;\n            if (err.stack) {\n                this.stack = err.stack;\n            }\n        };\n\n        SubError.prototype = new ParentClass(\"u dont c me\");\n        SubError.prototype.constructor = SubError;\n        SubError.prototype.name = error_class_name;\n\n        delete SubError.prototype.stack;\n\n        return SubError;\n    }\n    \n    function inherit(ChildClass, ParentClass) {\n        var k;\n\n        //Use the prototyping system to copy methods from parent to child.\n        ChildClass.prototype = Object.create(ParentClass.prototype);\n        ChildClass.prototype.constructor = ChildClass;\n        ChildClass.prototype.parent = ParentClass.prototype;\n\n        //Manually copy class-level methods from parent to child.\n        for (k in ParentClass) {\n            if (ParentClass.hasOwnProperty(k)) {\n                ChildClass[k] = ParentClass[k];\n            }\n        }\n    }\n\n    function init(ChildClass, object, args) {\n        ChildClass.prototype.parent.constructor.apply(object, args);\n    }\n    \n    /* By default, report the initial page load to registered behaviors.\n     */\n    $(document).ready(function () {\n        content_ready($(document));\n    });\n    \n    module.ElementMissingError = ElementMissingError;\n    module.throttle_single = throttle_single;\n    module.Behavior = Behavior;\n    module.error = error;\n    module.inherit = inherit;\n    module.init = init;\n    module.register_behavior = register_behavior;\n    module.content_ready = content_ready;\n    module.content_removal = content_removal;\n    module.register_content_listener = register_content_listener;\n\n    return module;\n}));\n","/**\n * Function used to get the height of the admin bar in pixels.\n *\n * @return {int} The height of the admin bar (in pixels)\n */\n function get_wp_admin_bar_height(){\n    // Start by getting the admin bar\n    var admin_bar = document.getElementById( 'wpadminbar' );\n    // If the admin bar doesn't exist, just return zero\n    if ( !admin_bar ){\n        return 0;\n    }\n    // Otherwise, get the current height\n    else {\n        return admin_bar.offsetHeight;\n    }\n}\n\n/**\n * Function for registering callbacks based on a window resize.\n *\n * @param     {Function}    callback                 The callback\n * @param     {object}      context                  The context for the callback\n * @param     {int}         window_resize_timeout    The timeout for the window resize\n *\n * @return    {void}        \n */\n function bind_callback_to_window_resize(callback, context, window_resize_timeout){\n    if ( !window_resize_timeout ){\n        window_resize_timeout = 500;\n    }\n    // To allow for the timeout\n    var id;\n    window.addEventListener(\"resize\", function(){\n        // Clear the timeout\n        clearTimeout(id);\n        // Create the function and callback\n        id = setTimeout(function(){\n            callback.call(context);\n        }, window_resize_timeout);\n    });\n}\n\n/**\n * Function used to get the height of the header in pixels.\n *\n * @return {int} The height of the header (in pixels)\n */\n function get_header_height(){\n    // Start by getting the header\n    var header = document.querySelector( 'header' );\n    return header.offsetHeight;\n}\n\n/**\n * Function used to determine if the header is sticky or not.\n *\n * @return {bool} True if the header is sticky\n */\n function header_is_sticky(){\n    // Start by getting the header\n    var header = document.querySelector( 'header' );\n    // Get the classes attached to the header\n    header_classes = header.classList;\n    return header_classes.contains( 'fl-theme-builder-header-sticky' );\n}","(function() {\n  var MutationObserver, Util, WeakMap, getComputedStyle, getComputedStyleRX,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n  Util = (function() {\n    function Util() {}\n\n    Util.prototype.extend = function(custom, defaults) {\n      var key, value;\n      for (key in defaults) {\n        value = defaults[key];\n        if (custom[key] == null) {\n          custom[key] = value;\n        }\n      }\n      return custom;\n    };\n\n    Util.prototype.isMobile = function(agent) {\n      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(agent);\n    };\n\n    Util.prototype.createEvent = function(event, bubble, cancel, detail) {\n      var customEvent;\n      if (bubble == null) {\n        bubble = false;\n      }\n      if (cancel == null) {\n        cancel = false;\n      }\n      if (detail == null) {\n        detail = null;\n      }\n      if (document.createEvent != null) {\n        customEvent = document.createEvent('CustomEvent');\n        customEvent.initCustomEvent(event, bubble, cancel, detail);\n      } else if (document.createEventObject != null) {\n        customEvent = document.createEventObject();\n        customEvent.eventType = event;\n      } else {\n        customEvent.eventName = event;\n      }\n      return customEvent;\n    };\n\n    Util.prototype.emitEvent = function(elem, event) {\n      if (elem.dispatchEvent != null) {\n        return elem.dispatchEvent(event);\n      } else if (event in (elem != null)) {\n        return elem[event]();\n      } else if ((\"on\" + event) in (elem != null)) {\n        return elem[\"on\" + event]();\n      }\n    };\n\n    Util.prototype.addEvent = function(elem, event, fn) {\n      if (elem.addEventListener != null) {\n        return elem.addEventListener(event, fn, false);\n      } else if (elem.attachEvent != null) {\n        return elem.attachEvent(\"on\" + event, fn);\n      } else {\n        return elem[event] = fn;\n      }\n    };\n\n    Util.prototype.removeEvent = function(elem, event, fn) {\n      if (elem.removeEventListener != null) {\n        return elem.removeEventListener(event, fn, false);\n      } else if (elem.detachEvent != null) {\n        return elem.detachEvent(\"on\" + event, fn);\n      } else {\n        return delete elem[event];\n      }\n    };\n\n    Util.prototype.innerHeight = function() {\n      if ('innerHeight' in window) {\n        return window.innerHeight;\n      } else {\n        return document.documentElement.clientHeight;\n      }\n    };\n\n    return Util;\n\n  })();\n\n  WeakMap = this.WeakMap || this.MozWeakMap || (WeakMap = (function() {\n    function WeakMap() {\n      this.keys = [];\n      this.values = [];\n    }\n\n    WeakMap.prototype.get = function(key) {\n      var i, item, j, len, ref;\n      ref = this.keys;\n      for (i = j = 0, len = ref.length; j < len; i = ++j) {\n        item = ref[i];\n        if (item === key) {\n          return this.values[i];\n        }\n      }\n    };\n\n    WeakMap.prototype.set = function(key, value) {\n      var i, item, j, len, ref;\n      ref = this.keys;\n      for (i = j = 0, len = ref.length; j < len; i = ++j) {\n        item = ref[i];\n        if (item === key) {\n          this.values[i] = value;\n          return;\n        }\n      }\n      this.keys.push(key);\n      return this.values.push(value);\n    };\n\n    return WeakMap;\n\n  })());\n\n  MutationObserver = this.MutationObserver || this.WebkitMutationObserver || this.MozMutationObserver || (MutationObserver = (function() {\n    function MutationObserver() {\n      if (typeof console !== \"undefined\" && console !== null) {\n        console.warn('MutationObserver is not supported by your browser.');\n      }\n      if (typeof console !== \"undefined\" && console !== null) {\n        console.warn('WOW.js cannot detect dom mutations, please call .sync() after loading new content.');\n      }\n    }\n\n    MutationObserver.notSupported = true;\n\n    MutationObserver.prototype.observe = function() {};\n\n    return MutationObserver;\n\n  })());\n\n  getComputedStyle = this.getComputedStyle || function(el, pseudo) {\n    this.getPropertyValue = function(prop) {\n      var ref;\n      if (prop === 'float') {\n        prop = 'styleFloat';\n      }\n      if (getComputedStyleRX.test(prop)) {\n        prop.replace(getComputedStyleRX, function(_, _char) {\n          return _char.toUpperCase();\n        });\n      }\n      return ((ref = el.currentStyle) != null ? ref[prop] : void 0) || null;\n    };\n    return this;\n  };\n\n  getComputedStyleRX = /(\\-([a-z]){1})/g;\n\n  this.WOW = (function() {\n    WOW.prototype.defaults = {\n      boxClass: 'wow',\n      animateClass: 'animated',\n      offset: 0,\n      mobile: true,\n      live: true,\n      callback: null,\n      scrollContainer: null\n    };\n\n    function WOW(options) {\n      if (options == null) {\n        options = {};\n      }\n      this.scrollCallback = bind(this.scrollCallback, this);\n      this.scrollHandler = bind(this.scrollHandler, this);\n      this.resetAnimation = bind(this.resetAnimation, this);\n      this.start = bind(this.start, this);\n      this.scrolled = true;\n      this.config = this.util().extend(options, this.defaults);\n      if (options.scrollContainer != null) {\n        this.config.scrollContainer = document.querySelector(options.scrollContainer);\n      }\n      this.animationNameCache = new WeakMap();\n      this.wowEvent = this.util().createEvent(this.config.boxClass);\n    }\n\n    WOW.prototype.init = function() {\n      var ref;\n      this.element = window.document.documentElement;\n      if ((ref = document.readyState) === \"interactive\" || ref === \"complete\") {\n        this.start();\n      } else {\n        this.util().addEvent(document, 'DOMContentLoaded', this.start);\n      }\n      return this.finished = [];\n    };\n\n    WOW.prototype.start = function() {\n      var box, j, len, ref;\n      this.stopped = false;\n      this.boxes = (function() {\n        var j, len, ref, results;\n        ref = this.element.querySelectorAll(\".\" + this.config.boxClass);\n        results = [];\n        for (j = 0, len = ref.length; j < len; j++) {\n          box = ref[j];\n          results.push(box);\n        }\n        return results;\n      }).call(this);\n      this.all = (function() {\n        var j, len, ref, results;\n        ref = this.boxes;\n        results = [];\n        for (j = 0, len = ref.length; j < len; j++) {\n          box = ref[j];\n          results.push(box);\n        }\n        return results;\n      }).call(this);\n      if (this.boxes.length) {\n        if (this.disabled()) {\n          this.resetStyle();\n        } else {\n          ref = this.boxes;\n          for (j = 0, len = ref.length; j < len; j++) {\n            box = ref[j];\n            this.applyStyle(box, true);\n          }\n        }\n      }\n      if (!this.disabled()) {\n        this.util().addEvent(this.config.scrollContainer || window, 'scroll', this.scrollHandler);\n        this.util().addEvent(window, 'resize', this.scrollHandler);\n        this.interval = setInterval(this.scrollCallback, 50);\n      }\n      if (this.config.live) {\n        return new MutationObserver((function(_this) {\n          return function(records) {\n            var k, len1, node, record, results;\n            results = [];\n            for (k = 0, len1 = records.length; k < len1; k++) {\n              record = records[k];\n              results.push((function() {\n                var l, len2, ref1, results1;\n                ref1 = record.addedNodes || [];\n                results1 = [];\n                for (l = 0, len2 = ref1.length; l < len2; l++) {\n                  node = ref1[l];\n                  results1.push(this.doSync(node));\n                }\n                return results1;\n              }).call(_this));\n            }\n            return results;\n          };\n        })(this)).observe(document.body, {\n          childList: true,\n          subtree: true\n        });\n      }\n    };\n\n    WOW.prototype.stop = function() {\n      this.stopped = true;\n      this.util().removeEvent(this.config.scrollContainer || window, 'scroll', this.scrollHandler);\n      this.util().removeEvent(window, 'resize', this.scrollHandler);\n      if (this.interval != null) {\n        return clearInterval(this.interval);\n      }\n    };\n\n    WOW.prototype.sync = function(element) {\n      if (MutationObserver.notSupported) {\n        return this.doSync(this.element);\n      }\n    };\n\n    WOW.prototype.doSync = function(element) {\n      var box, j, len, ref, results;\n      if (element == null) {\n        element = this.element;\n      }\n      if (element.nodeType !== 1) {\n        return;\n      }\n      element = element.parentNode || element;\n      ref = element.querySelectorAll(\".\" + this.config.boxClass);\n      results = [];\n      for (j = 0, len = ref.length; j < len; j++) {\n        box = ref[j];\n        if (indexOf.call(this.all, box) < 0) {\n          this.boxes.push(box);\n          this.all.push(box);\n          if (this.stopped || this.disabled()) {\n            this.resetStyle();\n          } else {\n            this.applyStyle(box, true);\n          }\n          results.push(this.scrolled = true);\n        } else {\n          results.push(void 0);\n        }\n      }\n      return results;\n    };\n\n    WOW.prototype.show = function(box) {\n      this.applyStyle(box);\n      box.className = box.className + \" \" + this.config.animateClass;\n      if (this.config.callback != null) {\n        this.config.callback(box);\n      }\n      this.util().emitEvent(box, this.wowEvent);\n      this.util().addEvent(box, 'animationend', this.resetAnimation);\n      this.util().addEvent(box, 'oanimationend', this.resetAnimation);\n      this.util().addEvent(box, 'webkitAnimationEnd', this.resetAnimation);\n      this.util().addEvent(box, 'MSAnimationEnd', this.resetAnimation);\n      return box;\n    };\n\n    WOW.prototype.applyStyle = function(box, hidden) {\n      var delay, duration, iteration;\n      duration = box.getAttribute('data-wow-duration');\n      delay = box.getAttribute('data-wow-delay');\n      iteration = box.getAttribute('data-wow-iteration');\n      return this.animate((function(_this) {\n        return function() {\n          return _this.customStyle(box, hidden, duration, delay, iteration);\n        };\n      })(this));\n    };\n\n    WOW.prototype.animate = (function() {\n      if ('requestAnimationFrame' in window) {\n        return function(callback) {\n          return window.requestAnimationFrame(callback);\n        };\n      } else {\n        return function(callback) {\n          return callback();\n        };\n      }\n    })();\n\n    WOW.prototype.resetStyle = function() {\n      var box, j, len, ref, results;\n      ref = this.boxes;\n      results = [];\n      for (j = 0, len = ref.length; j < len; j++) {\n        box = ref[j];\n        results.push(box.style.visibility = 'visible');\n      }\n      return results;\n    };\n\n    WOW.prototype.resetAnimation = function(event) {\n      var target;\n      if (event.type.toLowerCase().indexOf('animationend') >= 0) {\n        target = event.target || event.srcElement;\n        return target.className = target.className.replace(this.config.animateClass, '').trim();\n      }\n    };\n\n    WOW.prototype.customStyle = function(box, hidden, duration, delay, iteration) {\n      if (hidden) {\n        this.cacheAnimationName(box);\n      }\n      box.style.visibility = hidden ? 'hidden' : 'visible';\n      if (duration) {\n        this.vendorSet(box.style, {\n          animationDuration: duration\n        });\n      }\n      if (delay) {\n        this.vendorSet(box.style, {\n          animationDelay: delay\n        });\n      }\n      if (iteration) {\n        this.vendorSet(box.style, {\n          animationIterationCount: iteration\n        });\n      }\n      this.vendorSet(box.style, {\n        animationName: hidden ? 'none' : this.cachedAnimationName(box)\n      });\n      return box;\n    };\n\n    WOW.prototype.vendors = [\"moz\", \"webkit\"];\n\n    WOW.prototype.vendorSet = function(elem, properties) {\n      var name, results, value, vendor;\n      results = [];\n      for (name in properties) {\n        value = properties[name];\n        elem[\"\" + name] = value;\n        results.push((function() {\n          var j, len, ref, results1;\n          ref = this.vendors;\n          results1 = [];\n          for (j = 0, len = ref.length; j < len; j++) {\n            vendor = ref[j];\n            results1.push(elem[\"\" + vendor + (name.charAt(0).toUpperCase()) + (name.substr(1))] = value);\n          }\n          return results1;\n        }).call(this));\n      }\n      return results;\n    };\n\n    WOW.prototype.vendorCSS = function(elem, property) {\n      var j, len, ref, result, style, vendor;\n      style = getComputedStyle(elem);\n      result = style.getPropertyCSSValue(property);\n      ref = this.vendors;\n      for (j = 0, len = ref.length; j < len; j++) {\n        vendor = ref[j];\n        result = result || style.getPropertyCSSValue(\"-\" + vendor + \"-\" + property);\n      }\n      return result;\n    };\n\n    WOW.prototype.animationName = function(box) {\n      var animationName;\n      try {\n        animationName = this.vendorCSS(box, 'animation-name').cssText;\n      } catch (_error) {\n        animationName = getComputedStyle(box).getPropertyValue('animation-name');\n      }\n      if (animationName === 'none') {\n        return '';\n      } else {\n        return animationName;\n      }\n    };\n\n    WOW.prototype.cacheAnimationName = function(box) {\n      return this.animationNameCache.set(box, this.animationName(box));\n    };\n\n    WOW.prototype.cachedAnimationName = function(box) {\n      return this.animationNameCache.get(box);\n    };\n\n    WOW.prototype.scrollHandler = function() {\n      return this.scrolled = true;\n    };\n\n    WOW.prototype.scrollCallback = function() {\n      var box;\n      if (this.scrolled) {\n        this.scrolled = false;\n        this.boxes = (function() {\n          var j, len, ref, results;\n          ref = this.boxes;\n          results = [];\n          for (j = 0, len = ref.length; j < len; j++) {\n            box = ref[j];\n            if (!(box)) {\n              continue;\n            }\n            if (this.isVisible(box)) {\n              this.show(box);\n              continue;\n            }\n            results.push(box);\n          }\n          return results;\n        }).call(this);\n        if (!(this.boxes.length || this.config.live)) {\n          return this.stop();\n        }\n      }\n    };\n\n    WOW.prototype.offsetTop = function(element) {\n      var top;\n      while (element.offsetTop === void 0) {\n        element = element.parentNode;\n      }\n      top = element.offsetTop;\n      while (element = element.offsetParent) {\n        top += element.offsetTop;\n      }\n      return top;\n    };\n\n    WOW.prototype.isVisible = function(box) {\n      var bottom, offset, top, viewBottom, viewTop;\n      offset = box.getAttribute('data-wow-offset') || this.config.offset;\n      viewTop = (this.config.scrollContainer && this.config.scrollContainer.scrollTop) || window.pageYOffset;\n      viewBottom = viewTop + Math.min(this.element.clientHeight, this.util().innerHeight()) - offset;\n      top = this.offsetTop(box);\n      bottom = top + box.clientHeight;\n      return top <= viewBottom && bottom >= viewTop;\n    };\n\n    WOW.prototype.util = function() {\n      return this._util != null ? this._util : this._util = new Util();\n    };\n\n    WOW.prototype.disabled = function() {\n      return !this.config.mobile && this.util().isMobile(navigator.userAgent);\n    };\n\n    return WOW;\n\n  })();\n\n}).call(this);\n","/*global define, console, document, window*/\n/*jslint continue:true*/\n(function (root, factory) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(\"AffixColumn\", [\"jquery\", \"Behaviors\"], factory);\n    } else {\n        root.AffixColumn = factory(root.jQuery, root.Behaviors);\n    }\n}(this, function ($, Behaviors) {\n    \"use strict\";\n\n    var module = {};\n    \n    function $do(that, target) {\n        return function () {\n            target.apply(that, arguments);\n        };\n    }\n    \n    /* An Affix root is an element which is used to determine the edges of the\n     * region that columns stick to. It also provides the core event handlers\n     * to drive the AffixColumn and AffixRow behaviors.\n     */\n    function Affix(elem, scrollElem) {\n        Behaviors.init(Affix, this, arguments);\n\n        this.height = this.$elem.height();\n        this.offsetTop = this.$elem.offset().top;\n        \n        this.columns = [];\n        this.$scrollElem = $(scrollElem || document);\n        this.$scrollHeightElem = this.$scrollElem;\n        \n        //weird DOM quirk\n        if (this.$scrollElem[0] === document) {\n            this.$scrollHeightElem = $(window);\n        }\n        \n        this.$alwaysTopElem = $(this.$elem.data(\"affixcolumn-alwaystop\"));\n        this.$alwaysBottomElem = $(this.$elem.data(\"affixcolumn-alwaysbottom\"));\n        \n        this.bind_event_handlers();\n        this.find_columns_and_rows();\n        \n        this.resized();\n        this.scroll_changed();\n    }\n    \n    Behaviors.inherit(Affix, Behaviors.Behavior);\n    \n    Affix.QUERY = \"[data-affixcolumn='root']\";\n    \n    Affix.prototype.deinitialize = function () {\n        this.unbind_event_handlers();\n    };\n    \n    /* Check our alwaystop/alwaysbottom elements and see if they are floating.\n     * If so, add their height to the top and bottom adjustments given to the\n     * individual columns.\n     */\n    Affix.prototype.determine_global_floating_adjustment = function () {\n        this.globalTopAdjust = 0;\n        \n        this.$alwaysTopElem.each(function (index, atelem) {\n            var $atelem = $(atelem);\n            this.globalTopAdjust += $atelem.height();\n        }.bind(this));\n        \n        this.globalBottomAdjust = 0;\n        \n        this.$alwaysBottomElem.each(function (index, atelem) {\n            var $atelem = $(atelem);\n            this.globalBottomAdjust += $atelem.height();\n        }.bind(this));\n    };\n\n    Affix.prototype.resized = function () {\n        var i, maxColHeight = 0, maxColId, heightSum, disp = 0, topAdjust = 0, bottomAdjust = 0;\n        \n        this.determine_global_floating_adjustment();\n        this.height = this.$elem.height();\n        \n        if (this.columns.length > 0) {\n            //Scan top rows to fix their displacement heights and determine top\n            //adjustments.\n            for (i = 0; i < this.columns.length; i += 1) {\n                //Also, kill floating adjustments plz\n                this.columns[i].clear_floating_adjustments();\n                \n                if (!this.columns[i].has_option(\"top\")) {\n                    continue;\n                }\n                \n                //Top rows never get a bottom adjustment.\n                this.columns[i].set_floating_adjustments(this.globalTopAdjust, topAdjust, 0, 0);\n                \n                disp = this.columns[i].displacement_height();\n                \n                this.columns[i].$height_bearing_element().css(\"min-height\", disp + \"px\");\n                topAdjust += disp;\n            }\n            \n            //Scan bottom rows to fix their displacement heights and determine top\n            //adjustments. This is done in reverse order so that the bottommost\n            //bottom row gets the lowest bottom float adjustment.\n            for (i = this.columns.length - 1; i >= 0; i -= 1) {\n                if (!this.columns[i].has_option(\"bottom\")) {\n                    continue;\n                }\n                \n                //Bottom rows never get a top adjustment.\n                this.columns[i].set_floating_adjustments(0, 0, this.globalBottomAdjust, bottomAdjust);\n                \n                disp = this.columns[i].displacement_height();\n                \n                this.columns[i].$height_bearing_element().css(\"min-height\", disp + \"px\");\n                bottomAdjust += disp;\n            }\n            \n            //Scan columns to select the height-bearing column.\n            for (i = 0; i < this.columns.length; i += 1) {\n                if (!this.columns[i].has_option(\"column\")) {\n                    continue;\n                }\n                \n                //Columns get both the top and bottom adjustment.\n                this.columns[i].set_floating_adjustments(this.globalTopAdjust, topAdjust, this.globalBottomAdjust, bottomAdjust);\n                \n                //Determine which column is height bearing for this Affix.\n                if (maxColHeight < this.columns[i].displacement_height() &&\n                        !this.columns[i].has_option(\"noheightbearing\")) {\n                    maxColHeight = this.columns[i].displacement_height();\n                    maxColId = i;\n                }\n                \n                this.columns[i].remove_state(\"tallest\");\n            }\n            \n            if (maxColId !== undefined) {\n                this.columns[maxColId].add_state(\"tallest\");\n            }\n        }\n    };\n    \n    Affix.prototype.scroll_changed = function () {\n        var i, maxColHeight = 0, maxColId;\n        \n        this.height = this.$elem.height();\n        this.windowHeight = this.$scrollHeightElem.height();\n        this.offsetTop = this.$elem.offset().top;\n        this.scrollTop = this.$scrollElem.scrollTop();\n        this.offsetBottom = this.offsetTop + this.height;\n        this.scrollBottom = this.scrollTop + this.windowHeight;\n        \n        if (this.columns.length > 0) {\n            for (i = 0; i < this.columns.length; i += 1) {\n                this.columns[i].viewport_changed(this.height, this.offsetTop, this.offsetBottom, this.scrollTop, this.scrollBottom);\n            }\n        }\n    };\n    \n    Affix.prototype.unbind_event_handlers = function () {\n        if (this.scroll_handler !== undefined) {\n            this.$scrollElem.off(\"scroll\", this.scroll_handler);\n        }\n        \n        if (this.resize_handler !== undefined) {\n            $(window).off(\"resize\", this.resize_handler);\n        }\n    };\n    \n    Affix.prototype.bind_event_handlers = function () {\n        this.unbind_event_handlers();\n        \n        this.scroll_handler = $do(this, this.scroll_changed);\n        this.resize_handler = $do(this, this.resized);\n        \n        this.$scrollElem.on(\"scroll\", this.scroll_handler);\n        $(window).on(\"resize\", this.resize_handler);\n        $(document).on(\"load\", this.resize_handler);\n        $(\"img\").on(\"load\", this.resize_handler);\n    };\n    \n    Affix.prototype.find_columns_and_rows = function () {\n        var $likely_columns = this.$elem.find(AffixColumn.QUERY),\n            $likely_roots = this.$elem.find(Affix.QUERY);\n\n        this.columns = [];\n        this.roots = [];\n\n        $likely_columns.each(function (index, lcelem) {\n            var $lcelem = $(lcelem),\n                $parent_root = $lcelem.parents().filter(Affix.QUERY).first();\n\n            if ($parent_root[0] === this.$elem) {\n                this.columns.push(AffixColumn.locate($lcelem));\n            }\n        }.bind(this));\n\n        $likely_roots.each(function (index, lrelem) {\n            var $lrelem = $(lrelem),\n                $parent_root = $lrelem.parents().filter(Affix.QUERY).first();\n\n            if ($parent_root[0] === this.$elem) {\n                this.roots.push(Affix.locate($lrelem));\n            }\n        }.bind(this));\n    };\n    \n    /* An AffixColumn is a normally fixed element which sticks to the top or\n     * bottom edges of a scrolling viewport (typically the document).\n     * \n     * AffixColumn itself contains no event handlers. The parent Affix is\n     * responsible for propagating viewport scrolling to it's child Columns.\n     * \n     * Options may be provided which cause the Column to behave differently.\n     * Examples of this include the \"noheightbearing\" option, which prevents\n     * your AffixColumn from being marked as tallest for the purposes of parent\n     * element height preservation. See the parse_option_list function for more\n     * information on the option list format, and has_option for what options\n     * are available.\n     * \n     * The name \"AffixColumn\" is a misnomer. \"Columns\" may be configured as rows\n     * or columns in CSS. Orientation of the Column is configured with the\n     * column/top/bottom options. If neither is active, \"column\" is assumed.\n     */\n    function AffixColumn(elem) {\n        this.$elem = $(elem);\n        this.options = this.parse_option_list(this.$elem.data(\"affixcolumn-options\"));\n        \n        this.top_adjust = 0;\n        this.bottom_adjust = 0;\n    }\n    \n    Behaviors.inherit(AffixColumn, Behaviors.Behavior);\n    \n    AffixColumn.QUERY = \"[data-affixcolumn='column']\";\n    \n    /* Calculate the height taken up by the AffixColumn if placed in normal\n     * document flow.\n     * \n     * The floating adjustments currently applied to the column may cause\n     * invalid displacement height results to occur. For best results, call\n     * clear_floating_adjustments to remove them, and then trigger a viewport\n     * update from the Affix root once the height has been measured.\n     */\n    AffixColumn.prototype.displacement_height = function () {\n        return this.$elem.height();\n    };\n    \n    /* Change the top/bottom values that this column floats at.\n     * \n     * Floating adjustments determine the safe area of space that this element\n     * may float at without being overlapped or overlapping top or bottom rows.\n     * \n     * These will override any top/bottom values set via CSS.\n     */\n    AffixColumn.prototype.set_floating_adjustments = function (globalTop, top, globalBottom, bottom) {\n        this.top_adjust = top;\n        this.bottom_adjust = bottom;\n        \n        this.global_top_adjust = globalTop;\n        this.global_bottom_adjust = globalBottom;\n    };\n    \n    /* Remove inline CSS applied to make floating adjustments visually present.\n     * \n     * You must call this method before querying displacement_height, or you\n     * will get invalid results. After calling this method, you must trigger a\n     * viewport update by calling scroll_changed on the containing Affix root.\n     */\n    AffixColumn.prototype.clear_floating_adjustments = function () {\n        this.$elem.css(\"top\", \"\");\n        this.$elem.css(\"bottom\", \"\");\n    };\n    \n    /* Return the element responsible for propagating our displacement height in\n     * normal document flow.\n     * \n     * By default, the height bearing element is our parent element. We do not\n     * have a facility to override this currently.\n     */\n    AffixColumn.prototype.$height_bearing_element = function () {\n        return this.$elem.parent();\n    };\n    \n    AffixColumn.prototype.add_state = function (state) {\n        this.$elem.addClass(\"is-AffixColumn--\" + state);\n    };\n    \n    AffixColumn.prototype.remove_state = function (state) {\n        this.$elem.removeClass(\"is-AffixColumn--\" + state);\n    };\n    \n    /* Determine if an AffixColumn option applies given the current viewport.\n     * \n     * Valid options include:\n     * \n     *  - column: AffixColumn to be oriented vertically aside other columns.\n     *    The tallest column is marked as \"tallest\" and considered the height\n     *    bearing column, whereby it is expected to be positioned in normal\n     *    document flow such that the Affix element can grab it's CSS height.\n     * \n     *  - top: AffixColumn to be oriented above other columns. Top rows are\n     *    given a CSS min-height equal to the sum of their childrens' heights\n     *    and their children are assumed to float. This minimum height will be\n     *    applied as the top value to any following tops or columns.\n     *\n     *  - bottom: AffixColumn to be oriented below other columns. Bottom rows\n     *    are given a CSS min-height in the same fashion as top rows. This\n     *    minimum height will be applied as the bottom value to any preceding\n     *    bottoms or columns.\n     * \n     *  - noheightbearing: Column-oriented AffixColumn to be disqualified from\n     *    being marked as a height-bearing column.\n     */\n    AffixColumn.prototype.has_option = function (option_string) {\n        var i;\n        \n        for (i = 0; i < this.options.length; i += 1) {\n            if (this.options[i].media === null || window.matchMedia(this.options[i].media).matches) {\n                //Column enabled by default\n                if (option_string === \"column\" &&\n                        this.options[i].options.indexOf(\"top\") === -1 &&\n                        this.options[i].options.indexOf(\"bottom\") === -1) {\n                    return true;\n                }\n                \n                return this.options[i].options.indexOf(option_string) > -1;\n            }\n        }\n        \n        if (option_string === \"column\") {\n            return true;\n        } else {\n            return false;\n        }\n    };\n    \n    AffixColumn.MATCH_MEDIA_QUERY_REGEX = /\\(([\\s\\S]*)\\)/g;\n    \n    /* Parse an option list.\n     * \n     * The option list determines what options are active on a column. It is\n     * comma separated. Each comma indicates a new option list for a particular\n     * media query. The first media query to match determines the total option\n     * set. The final option set may or may not have a media query; if it does\n     * not, then it serves as the default option set.\n     * \n     * This is very analagous to the sizes attribute of <img> tags in modern\n     * browsers. Example format:\n     * \n     *    (min-width: 450px) column noheightbearing, top\n     */\n    AffixColumn.prototype.parse_option_list = function (option_list_string) {\n        var cases, i, j, rval = [], case_obj = {}, match;\n        \n        if (option_list_string === undefined) {\n            option_list_string = \"\";\n        }\n        \n        cases = option_list_string.split(\",\");\n        \n        for (i = 0; i < cases.length; i += 1) {\n            case_obj = {};\n            match = this.constructor.MATCH_MEDIA_QUERY_REGEX.exec(cases[i]);\n            \n            //Reset the string. Sharing regex objects is dirty...\n            this.constructor.MATCH_MEDIA_QUERY_REGEX.lastIndex = 0;\n            \n            if (match === null || match.length === 0) {\n                case_obj.options = cases[i].split(\" \");\n                case_obj.media = null;\n            } else {\n                case_obj.options = cases[i].slice(match[0]).split(\" \");\n                case_obj.media = match[0];\n            }\n            \n            //Filter empty options\n            for (j = 0; j < case_obj.options.length; j += 0) {\n                if (case_obj.options[j] === \"\") {\n                    case_obj.options.splice(j, 1);\n                } else {\n                    j += 1;\n                }\n            }\n            \n            rval.push(case_obj);\n        }\n        \n        return rval;\n    };\n    \n    /* Internal method used by Affix to communicate to it's children the new\n     * parameters of the scroll viewport.\n     */\n    AffixColumn.prototype.viewport_changed = function (rootHeight, offsetTop, offsetBottom, scrollTop, scrollBottom) {\n        var isTopAnchored = this.has_option(\"column\") || this.has_option(\"top\"),\n            isBottomAnchored = this.has_option(\"anchorbottom\") || this.has_option(\"bottom\"),\n            bottomStateAdjust = true,\n            topStateAdjust = true,\n            adjustWithoutGlobal = true;\n        \n        //Remove existing floating adjustments.\n        //Otherwise, our displacement height is incorrect.\n        this.clear_floating_adjustments();\n        \n        //Apply affix states.\n        if (isTopAnchored && scrollTop + this.global_top_adjust < offsetTop ||\n                isBottomAnchored && scrollBottom - this.displacement_height() < offsetTop) {\n            this.add_state(\"top\");\n            this.remove_state(\"bottom\");\n            bottomStateAdjust = false;\n        } else if (isTopAnchored && scrollTop + this.top_adjust + this.global_top_adjust + this.displacement_height() + this.bottom_adjust >= offsetBottom ||\n                isBottomAnchored && scrollBottom >= offsetBottom) {\n            this.remove_state(\"top\");\n            this.add_state(\"bottom\");\n            topStateAdjust = false;\n        } else {\n            this.remove_state(\"top\");\n            this.remove_state(\"bottom\");\n            adjustWithoutGlobal = false;\n        }\n        \n        //Apply floating adjustments.\n        if ((this.has_option(\"column\") || this.has_option(\"top\")) && topStateAdjust) {\n            if (adjustWithoutGlobal) {\n                this.$elem.css(\"top\", this.top_adjust + \"px\");\n            } else {\n                this.$elem.css(\"top\", this.top_adjust + this.global_top_adjust + \"px\");\n            }\n        }\n        \n        if ((this.has_option(\"column\") || this.has_option(\"bottom\")) && bottomStateAdjust) {\n            if (adjustWithoutGlobal) {\n                this.$elem.css(\"bottom\", this.bottom_adjust + \"px\");\n            } else {\n                this.$elem.css(\"bottom\", this.bottom_adjust + this.global_bottom_adjust + \"px\");\n            }\n        }\n    };\n    \n    Behaviors.register_behavior(Affix);\n\n    module.Affix = Affix;\n    module.AffixColumn = AffixColumn;\n\n    return module;\n}));\n","/*global define, console, window, HTMLImageElement, Promise*/\n\n(function (root, factory) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(\"AtlasPlayer\", [\"jquery\", \"Behaviors\"], factory);\n    } else {\n        root.AtlasPlayer = factory(root.jQuery, root.Behaviors);\n    }\n}(this, function ($, Behaviors) {\n    \"use strict\";\n    var module = {};\n\n    /* A Behavior that plays an image atlas on a canvas.\n     *\n     * Atlas description format is that which is generated by the following\n     * Photoshop script: https://github.com/tonioloewald/Layer-Group-Atlas\n     */\n    function AtlasPlayer() {\n        Behaviors.init(AtlasPlayer, this, arguments);\n\n        this.deinitialize_stop = false;\n\n        this.$canvas = this.$elem;\n        if (!this.$canvas.is(\"canvas\")) {\n            this.$canvas = this.$elem.find(\"canvas\");\n        }\n\n        this.context = this.$canvas[0].getContext(\"2d\");\n\n        this.image = undefined;\n        this.atlas_data = undefined;\n\n        //TODO: Make configurable\n        this.anim_player_running = false;\n\n        this.ready().then(function () {\n            $(window).on(\"resize\", this.size_canvas_to_fit.bind(this));\n            \n            this.anim_length = this.find_anim_length();\n            \n            if (this.atlas_data.autoplay === true) {\n                this.play();\n            }\n        }.bind(this));\n    }\n\n    Behaviors.inherit(AtlasPlayer, Behaviors.Behavior);\n\n    AtlasPlayer.QUERY = \"[data-atlasplayer]\";\n\n    /* Cause AtlasPlayer to ensure it's image and atlas are ready.\n     *\n     * Returns a promise which resolves when the atlas is ready for playback.\n     * Promise will reject if the image is an image tag which has failed to\n     * load.\n     */\n    AtlasPlayer.prototype.ready = function () {\n        if (this.ready_promise === undefined) {\n            this.ready_promise = new Promise(function (resolve, reject) {\n                this.ready_resolve = resolve;\n                this.ready_reject = reject;\n            }.bind(this));\n\n            this.find_image();\n            this.find_atlas();\n            this.is_ready();\n        }\n\n        return this.ready_promise;\n    };\n\n    /* Determine if the atlas is ready for playback.\n     *\n     * Calling this function also has the side effect of resolving the ready\n     * promise if it has not already been done. If this function returns true\n     * for the first time, then the promise has been resolved. If it returns\n     * false, it may have been rejected (say, if the image fails to load).\n     */\n    AtlasPlayer.prototype.is_ready = function () {\n        var image_ready, atlas_ready, total_ready;\n\n        if (this.image === undefined) {\n            image_ready = false;\n        } else if (this.image.constructor === HTMLImageElement) {\n            if (this.image.complete) {\n                if (this.image.naturalHeight === 0) {\n                    //Something has gone horribly wrong\n                    this.ready_reject();\n                    image_ready = false;\n                } else {\n                    image_ready = true;\n                }\n            } else {\n                image_ready = false;\n            }\n        } else {\n            //Other drawables are presumed already loaded\n            image_ready = true;\n        }\n\n        if (this.atlas_data !== undefined && this.atlas_data.then !== undefined) {\n            //Not ready, since a promise was provided\n            atlas_ready = false;\n        } else {\n            atlas_ready = this.atlas_data !== undefined;\n        }\n\n        total_ready = image_ready && atlas_ready;\n\n        if (total_ready) {\n            this.ready_resolve();\n        }\n\n        return total_ready;\n    };\n\n    /* Called to find the image we're drawing our animation from, if present.\n     */\n    AtlasPlayer.prototype.find_image = function () {\n        var image_id = this.$elem.data(\"atlasplayer-image\");\n\n        if (this.image !== undefined) {\n            return;\n        }\n\n        if (image_id !== undefined) {\n            this.image = $(image_id)[0];\n\n            if (this.image.constructor === HTMLImageElement) {\n                $(this.image).on(\"load\", this.is_ready.bind(this));\n            }\n        }\n    };\n\n    /* Called to find and load our atlas data.\n     */\n    AtlasPlayer.prototype.find_atlas = function () {\n        var atlas_data = this.$elem.data(\"atlasplayer-data\");\n\n        if (this.atlas_data !== undefined) {\n            return;\n        }\n\n        if (typeof atlas_data === \"string\") {\n            //Atlas data is a URL.\n            this.atlas_data = this.load_atlas_data(atlas_data)\n                .then(function (data) {\n                    this.atlas_data = data;\n                    this.is_ready();\n                }.bind(this))\n                .catch(this.ready_reject);\n        } else {\n            //Atlas data is immediately provided.\n            this.atlas_data = atlas_data;\n        }\n    };\n    \n    AtlasPlayer.prototype.find_anim_length = function () {\n        var anim_length = this.$elem.data(\"atlasplayer-animlength\");\n        \n        if (anim_length === undefined) {\n            anim_length = this.atlas_data.time;\n        }\n        \n        if (anim_length === undefined) {\n            anim_length = \"5s\";\n        }\n        \n        anim_length = parseFloat(anim_length, 10);\n        \n        if (isNaN(anim_length) || anim_length === 0) {\n            anim_length = 5000;\n        } else {\n            anim_length *= 1000;\n        }\n        \n        return anim_length;\n    };\n\n    /* Load the atlas data.\n     *\n     * Returns a promise which resolves when the atlas data has loaded.\n     */\n    AtlasPlayer.prototype.load_atlas_data = function (url) {\n        var promiseResolve, promiseReject,\n            myPromise = new Promise(function (resolve, reject) {\n                promiseResolve = resolve;\n                promiseReject = reject;\n            });\n\n        $.ajax({\n            \"url\": url,\n            \"dataType\": \"json\"\n        }).done(function (data) {\n            promiseResolve(data);\n        }).fail(function (jqXHR, textStatus, errorThrown) {\n            promiseReject([textStatus, errorThrown]);\n        });\n\n        return myPromise;\n    };\n\n    /* Cause the canvas to draw a particular atlas frame.\n     */\n    AtlasPlayer.prototype.draw_frame = function (frame_id) {\n        var layerData = this.atlas_data.layers[this.atlas_data.layers.length - frame_id - 1];\n        \n        if (layerData.width <= 0) {\n            return;\n        }\n        \n        if (layerData.height <= 0) {\n            return;\n        }\n\n        this.context.drawImage(this.image,\n                               //Location of the atlas slice\n                               layerData.packedOrigin.x * this.image_x_space,\n                               layerData.packedOrigin.y * this.image_y_space,\n                               layerData.width * this.image_x_space,\n                               layerData.height * this.image_y_space,\n                               //Where we want it\n                               layerData.left,\n                               layerData.top,\n                               layerData.width,\n                               layerData.height\n                              );\n    };\n    \n    /* Size the canvas to fit our data.\n     */\n    AtlasPlayer.prototype.size_canvas_to_fit = function () {\n        //Determine the device-specific pixel size of this AtlasPlayer.\n        this.canvas_scale_factor = window.devicePixelRatio;\n        this.$canvas[0].width = this.$canvas.width() * this.canvas_scale_factor;\n        this.$canvas[0].height = this.$canvas.height() * this.canvas_scale_factor;\n        \n        //Reset the current canvas transform, if any.\n        this.context.setTransform(1, 0, 0, 1, 0, 0);\n        \n        //Scale down our coordinate space\n        this.context.scale(this.canvas_scale_factor, this.canvas_scale_factor);\n        \n        //Determine if cropping is needed.\n        this.css_aspect_ratio = this.$canvas.width() / this.$canvas.height();\n        this.atlas_aspect_ratio = this.atlas_data.width / this.atlas_data.height;\n        if (this.css_aspect_ratio > this.atlas_aspect_ratio) {\n            this.context.translate(0, (this.$canvas.width() / this.atlas_aspect_ratio - this.$canvas.height()) / -2);\n            \n            this.canvas_transform_scale_factor = this.$canvas.width() / this.atlas_aspect_ratio / this.atlas_data.height;\n            this.context.scale(this.canvas_transform_scale_factor, this.canvas_transform_scale_factor);\n        } else if (this.css_aspect_ratio < this.atlas_aspect_ratio) {\n            this.context.translate((this.$canvas.height() * this.atlas_aspect_ratio - this.$canvas.width()) / -2, 0);\n            \n            this.canvas_transform_scale_factor = this.$canvas.height() * this.atlas_aspect_ratio / this.atlas_data.width;\n            this.context.scale(this.canvas_transform_scale_factor, this.canvas_transform_scale_factor);\n        }\n        \n        //We also need to determine if our atlas image is scaled down and adjust\n        //our source coordinate space to match.\n        this.image_x_space = this.image.width / this.atlas_data.atlas.width;\n        this.image_y_space = this.image.height / this.atlas_data.atlas.height;\n        \n        //Since we just clared the canvas, if we aren't animated, then we need\n        //to manually repopulate ourselves:\n        if (this.last_frame_drawn !== undefined) {\n            this.draw_frame(this.last_frame_drawn);\n        }\n    };\n\n    AtlasPlayer.prototype.animation_krnl = function (time) {\n        var step, frame, total_frames;\n\n        if (this.deinitialize_stop) {\n            return;\n        }\n        \n        if (this.playing === false) {\n            this.anim_player_running = false;\n            \n            if (this.on_animation_complete) {\n                this.on_animation_complete();\n                this.on_animation_complete = undefined;\n            }\n            return;\n        }\n\n        if (this.anim_first_time === undefined) {\n            this.anim_first_time = time;\n            window.requestAnimationFrame(this.animation_krnl.bind(this));\n            return;\n        }\n        \n        if (this.anim_length === undefined) {\n            //Don't animate if we haven't loaded yet\n            window.requestAnimationFrame(this.animation_krnl.bind(this));\n            return;\n        }\n\n        total_frames = this.atlas_data.layers.length;\n        step = this.anim_length / total_frames;\n        time = time - this.anim_first_time;\n        frame = Math.max(Math.min(Math.round(time / step), total_frames - 1), 0);\n\n        if (this.reverse) {\n            frame = (total_frames - 1) - frame;\n        }\n\n        this.context.clearRect(0,0,this.atlas_data.width, this.atlas_data.height);\n        this.draw_frame(frame);\n        \n        this.last_frame_drawn = frame;\n        \n        if (time > this.anim_length) {\n            if (this.should_loop()) {\n                this.anim_first_time = undefined;\n            } else {\n                this.anim_player_running = false;\n                \n                if (this.on_animation_complete) {\n                    this.on_animation_complete();\n                    this.on_animation_complete = undefined;\n                }\n                return;\n            }\n        }\n        \n        window.requestAnimationFrame(this.animation_krnl.bind(this));\n    };\n\n    AtlasPlayer.prototype.update_animation_state = function () {\n        if (this.playing && this.anim_player_running === false) {\n            if (this.on_animation_complete) {\n                this.on_animation_complete();\n            }\n            \n            this.animation_promise = new Promise(function (resolve, reject) {\n                this.on_animation_complete = resolve;\n            }.bind(this));\n            \n            this.size_canvas_to_fit();\n            this.anim_player_running = true;\n            window.requestAnimationFrame(this.animation_krnl.bind(this));\n        }\n        \n        return this.animation_promise;\n    };\n    \n    AtlasPlayer.prototype.play = function () {\n        this.playing = true;\n        this.reverse = false;\n        this.anim_first_time = undefined;\n        return this.update_animation_state();\n    };\n\n    AtlasPlayer.prototype.play_reverse = function () {\n        this.playing = true;\n        this.reverse = true;\n        this.anim_first_time = undefined;\n        return this.update_animation_state();\n    };\n    \n    /* Request the animation to stop playing on the next frame.\n     * \n     * This function also resets the animation to play again.\n     */\n    AtlasPlayer.prototype.stop = function () {\n        //A bit of subtlety: We don't clear anim_player_running since we don't\n        //cancel the animation frame when you stop the animation. We instead\n        //wait for the animation to stop itself.\n        this.playing = false;\n        this.reverse = false;\n        this.anim_first_time = undefined;\n        return this.update_animation_state();\n    };\n    \n    AtlasPlayer.prototype.seek = function (frame) {\n        if (frame < 0) {\n            frame = this.atlas_data.layers.length - frame - 2;\n        }\n\n        this.context.clearRect(0,0,this.atlas_data.width, this.atlas_data.height);\n        this.draw_frame(frame);\n\n        this.last_frame_drawn = frame;\n    };\n    \n    /* Determine if this AtlasPlayer should loop or not.\n     */\n    AtlasPlayer.prototype.should_loop = function () {\n        var loop_force = this.$elem.data(\"atlasplayer-loop\"),\n            loop_deny = this.$elem.data(\"atlasplayer-once\");\n        \n        if (loop_force !== undefined) {\n            return true;\n        } else if (loop_deny !== undefined) {\n            return false;\n        } else {\n            return this.atlas_data.loop === true;\n        }\n    };\n\n    Behaviors.register_behavior(AtlasPlayer);\n\n    module.AtlasPlayer = AtlasPlayer;\n\n    return module;\n}));\n","/*global define, console, document, window*/\n(function (root, factory) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(\"Animations\", [\"jquery\", \"Behaviors\"], factory);\n    } else {\n        root.Animations = factory(root.jQuery, root.Behaviors);\n    }\n}(this, function ($, Behaviors) {\n    \"use strict\";\n    \n    var module = {};\n\n    /* Watches for the start and end of an animation.\n     *\n     * The .promise attribute stores a promise which resolves whenever the\n     * animation has completed or no animation events were detected over a\n     * timeout period of 5 second.\n     *\n     * An important caveat: Animations with delay longer than 5 seconds will\n     * fail to fire events and the animation watcher will trigger the timeout\n     * behavior instead. You can avoid this behavior by triggering another\n     * animation of any kind during the timeout period and keeping it alive\n     * until the delayed animation begins.\n     */\n    function AnimationWatcher($elem) {\n        var Class = this.constructor,\n            eventSelector = Class.get_unique_id(),\n            that = this,\n            evtStartNames = \"animationstart.\" + eventSelector +\n                      \" webkitAnimationStart.\" + eventSelector +\n                      \" oanimationstart.\" + eventSelector +\n                      \" MSAnimationStart.\" + eventSelector,\n            evtEndNames = \"animationend.\" + eventSelector +\n                      \" webkitAnimationEnd.\" + eventSelector +\n                      \" oanimationend.\" + eventSelector +\n                      \" MSAnimationEnd.\" + eventSelector,\n            animation_start = this.animation_start.bind(this),\n            animation_end = this.animation_end.bind(this),\n            animation_timeout_delay = 5000;\n\n        this.eventSelector = eventSelector;\n\n        this.$elem = $elem;\n        this.$elem.on(evtStartNames, animation_start);\n        this.$elem.on(evtEndNames, animation_end);\n\n        if (window.Modernizr && window.Modernizr.cssanimations === false) {\n            animation_timeout_delay = 0;\n        }\n\n        this.timeout = window.setTimeout(this.abort_animation.bind(this), animation_timeout_delay);\n        this.remaining_animations = [];\n\n        //We remove event handlers after one of the handlers resolves the\n        //animation promise.\n        this.promise = new Promise(function (resolve, reject) {\n            that.resolve = resolve;\n            that.reject = reject;\n        }).then(function () {\n            that.$elem.off(evtStartNames, animation_start);\n            that.$elem.off(evtEndNames, animation_end);\n        });\n\n        console.log(\"ANIMATIONWATCHER\" + this.eventSelector + \": Created\");\n    }\n\n    AnimationWatcher.count = 0;\n\n    AnimationWatcher.get_unique_id = function () {\n        var Class = this,\n            sel = \".\" + Class.name + \"_\" + Class.count;\n\n        Class.count += 1;\n        return sel;\n    };\n\n    AnimationWatcher.prototype.animation_start = function (evt) {\n        console.log(\"ANIMATIONWATCHER\" + this.eventSelector + \": Begun (\" + evt.originalEvent.animationName + \")\");\n        if (this.timeout !== null) {\n            window.clearTimeout(this.timeout);\n            this.timeout = null;\n        }\n\n        this.remaining_animations.push(evt.originalEvent.animationName);\n    };\n\n    AnimationWatcher.prototype.animation_end = function (evt) {\n        var loc = this.remaining_animations.indexOf(evt.originalEvent.animationName);\n\n        console.log(\"ANIMATIONWATCHER\" + this.eventSelector + \": Ended (\" + evt.originalEvent.animationName + \")\");\n\n        if (loc !== -1) {\n            this.remaining_animations.splice(loc, 1);\n        }\n\n        if (this.remaining_animations.length === 0) {\n            this.resolve();\n        }\n    };\n\n    AnimationWatcher.prototype.abort_animation = function (evt) {\n        console.log(\"ANIMATIONWATCHER\" + this.eventSelector + \": Abort timeout triggered\");\n\n        if (this.remaining_animations.length === 0) {\n            this.resolve();\n        }\n    };\n\n    module.AnimationWatcher = AnimationWatcher;\n\n    return module;\n}));\n","/*global define, console, document, window*/\n(function (root, factory) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(\"CollapseContent\", [\"jquery\", \"Behaviors\"], factory);\n    } else {\n        root.CollapseContent = factory(root.jQuery, root.Behaviors);\n    }\n}(this, function ($, Behaviors) {\n    \"use strict\";\n\n    var module = {};\n\n    function $do(that, target) {\n        return function () {\n            target.apply(that, arguments);\n        };\n    }\n\n    function CollapseContentRegion(elem) {\n        Behaviors.init(CollapseContentRegion, this, arguments);\n\n        this.$elem = $(elem);\n        this.visible = this.$elem.data(\"collapsecontent-region-visible\") !== undefined;\n\n        this.update_classes();\n    }\n\n    Behaviors.inherit(CollapseContentRegion, Behaviors.Behavior);\n\n    CollapseContentRegion.QUERY = \"[data-collapsecontent-region]\";\n\n    CollapseContentRegion.prototype.update_classes = function () {\n        this.$elem.find(\"[data-collapsecontent-body]\").each(function (index, body_elem) {\n            if (this.visible) {\n                $(body_elem).addClass(\"is-CollapseContent--visible\");\n                $(body_elem).removeClass(\"is-CollapseContent--hidden\");\n            } else {\n                $(body_elem).removeClass(\"is-CollapseContent--visible\");\n                $(body_elem).addClass(\"is-CollapseContent--hidden\");\n            }\n        }.bind(this));\n\n        this.$elem.find(\"[data-collapsecontent-trigger]\").each(function (index, trigger_elem) {\n            if (this.visible) {\n                $(trigger_elem).addClass(\"is-CollapseContent--visible\");\n                $(trigger_elem).removeClass(\"is-CollapseContent--hidden\");\n            } else {\n                $(trigger_elem).removeClass(\"is-CollapseContent--visible\");\n                $(trigger_elem).addClass(\"is-CollapseContent--hidden\");\n            }\n        }.bind(this));\n    };\n\n    CollapseContentRegion.prototype.make_visible = function () {\n        this.visible = true;\n        this.update_classes();\n    };\n\n    CollapseContentRegion.prototype.make_hidden = function () {\n        this.visible = false;\n        this.update_classes();\n    };\n\n    CollapseContentRegion.prototype.toggle = function () {\n        this.visible = !this.visible;\n        this.update_classes();\n\n        // Fire custom event when toggles are activated\n        newEvent = new $.Event({\n            \"type\": \"collapsecontent-toggle\",\n            \"visible\": this.visible,\n            \"target\": this.$elem,\n        });\n\n        this.$elem.trigger(newEvent);\n    };\n\n    function CollapseContentTrigger(elem) {\n        Behaviors.init(CollapseContentTrigger, this, arguments);\n\n        this.$elem = $(elem);\n\n        if (this.$elem.data(\"collapsecontent-trigger\") !== undefined) {\n            //Mode 1: Trigger explicitly specifies region to toggle.\n            this.region = this.set_region($(this.$elem.data(\"collapsecontent-trigger\"))[0]);\n        } else if (this.$elem.attr(\"href\") !== undefined) {\n            //Mode 1: Trigger explicitly specifies region to toggle, as an href..\n            this.region = this.set_region($(this.$elem.data(\"collapsecontent-trigger\"))[0]);\n        }\n\n        if (this.region === undefined) {\n            //Mode 2: Find parent element that qualifies as a region.\n            this.region = this.set_region(this.$elem.parents().filter(CollapseContentRegion.QUERY)[0]);\n        }\n\n        if (this.region === undefined) {\n            console.error(\"There is a CollapseContent trigger that neither points to a valid region nor is a child of a valid region..\");\n        }\n\n        this.$elem.on(\"click\", this.toggle_intent.bind(this));\n    }\n\n    Behaviors.inherit(CollapseContentTrigger, Behaviors.Behavior);\n\n    CollapseContentTrigger.QUERY = \"[data-collapsecontent-trigger]\";\n\n    CollapseContentTrigger.prototype.set_region = function (elem) {\n        if (elem === undefined) {\n            return;\n        }\n\n        return CollapseContentRegion.locate(elem);\n    };\n\n    CollapseContentTrigger.prototype.toggle_intent = function (evt) {\n        if (evt) {\n            evt.preventDefault();\n        }\n        \n        this.region.toggle();\n    };\n\n    Behaviors.register_behavior(CollapseContentRegion);\n    Behaviors.register_behavior(CollapseContentTrigger);\n\n    module.CollapseContentRegion = CollapseContentRegion;\n    module.CollapseContentTrigger = CollapseContentTrigger;\n\n    return module;\n}));\n","(function (root, factory) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(\"ContentSlider\", [\"jquery\", \"Behaviors\"], factory);\n    } else {\n        root.ContentSlider = factory(root.jQuery, root.Behaviors);\n    }\n}(window, function ($, Behaviors) {\n    //TODO: Move this file out of `frontend.prebuilt.js` and into the global script pack\n    \"use strict\";\n    var module = {};\n    \n    function ContentSlider() {\n        Behaviors.init(ContentSlider, this, arguments);\n        this.element = this.$elem[0];\n        this.left_arrow = this.$elem.data(\"contentslider-leftarrow\");\n        this.right_arrow = this.$elem.data(\"contentslider-rightarrow\");\n        this.dots = this.$elem.data(\"contentslider-dots\");\n        this.dots_icon = this.$elem.data(\"contentslider-dotsicon\");\n        this.autoplay_timeout = this.$elem.data(\"contentslider-autoplay\");\n\n        this.item_margin = this.$elem.data(\"contentslider-itemmargin\");\n\n        this.number_of_items = this.$elem.data(\"contentslider-itemsperview\");\n        this.center = this.$elem.data(\"contentslider-center\");\n        this.number_of_items_medium = this.$elem.data(\"contentslider-itemsperviewmedium\");\n        this.center_medium = this.$elem.data(\"contentslider-centermedium\");\n        this.number_of_items_responsive = this.$elem.data(\"contentslider-itemsperviewresponsive\");\n        this.center_responsive = this.$elem.data(\"contentslider-centerresponsive\");\n\n        this.slide_stage_padding = this.$elem.data(\"contentslider-stagepadding\");\n        this.slide_stage_padding_medium = this.$elem.data(\"contentslider-stagepaddingmedium\");\n        this.slide_stage_padding_responsive = this.$elem.data(\"contentslider-stagepaddingresponsive\");\n        \n        this.has_loop = this.$elem.data(\"contentslider-loop\") !== undefined;\n        this.has_autoplay = this.autoplay_timeout !== undefined;\n        this.has_hoverpause = this.$elem.data(\"contentslider-hoverpause\") !== undefined;\n        this.has_dots = this.dots !== \"none\";\n        this.has_nav = false;\n        if (this.left_arrow) {\n            this.has_nav = true;\n        }\n        \n        if (this.right_arrow) {\n            this.has_nav = true;\n        }\n        this.initOwlCarousel();\n    };\n    \n    Behaviors.inherit(ContentSlider, Behaviors.Behavior);\n    \n    ContentSlider.QUERY = \"[data-contentslider]\";\n    \n    ContentSlider.ELEMENTS = {\n        heightContainer: \".scrollContainerHeight\",\n        widthContainer: \".scrollContainerWidth\",\n        sliderContents: \".horizontalContents\",\n        section: \".section\",\n        progressBar: \".progressBarFill\",\n        progressBall: \".progressBall\",\n        carousel: \".owl-carousel\"\n    };\n    \n    ContentSlider.prototype.dots_class = function () {\n        return \"owl-dots ContentSlider-dots ContentSlider-dots--style_\" + this.dots;\n    };\n    \n    ContentSlider.prototype.dot_class = function () {\n        if (this.dots_icon) {\n            return \"ContentSlider-dot ContentSlider-dot--style_\" + this.dots + \" \" + this.dots_icon;\n        } else {\n            return \"ContentSlider-dot ContentSlider-dot--style_\" + this.dots;\n        }\n    };\n    \n    ContentSlider.prototype.initOwlCarousel = function() {\n        this.carousel = this.$elem.find(ContentSlider.ELEMENTS.carousel).owlCarousel({\n            loop: this.has_loop,\n            dots: this.has_dots,\n            dotsClass: this.dots_class(),\n            dotClass: this.dot_class(),\n            margin: this.item_margin,\n            nav: this.has_nav,\n            navClass: [\"owl-prev \" + this.left_arrow, \"owl-next \" + this.right_arrow],\n            //onDragged: self.updatePagination.bind(self),\n            autoplay: this.has_autoplay,\n            autoplayTimeout: this.autoplay_timeout,\n            autoplayHoverPause: this.has_hoverpause,\n            responsive : {\n                0 : {\n                    items: this.number_of_items_responsive,\n                    slideBy: this.number_of_items_responsive,\n                    center: this.center_responsive,\n                    stagePadding: this.slide_stage_padding_responsive,\n                },\n                768 : {\n                    items: this.number_of_items_medium,\n                    slideBy: this.number_of_items_medium, \n                    center: this.center_medium,\n                    stagePadding: this.slide_stage_padding_medium,\n                },\n                1024 : {\n                    items: this.number_of_items,\n                    slideBy: this.number_of_items, \n                    center: this.center,\n                    stagePadding: this.slide_stage_padding,\n                },\n            },\n        });\n        //self.updateNav(0);\n    };\n\n    \n    \n    ContentSlider.prototype.init = function () {\n        this.fixed = false;\n        //this.setHeight();\n        //this.handleScroll();\n        //this.handleResize();\n        this.initMobileSlider();\n        //this.handleDrag();\n        //this.element.querySelector(\".currentSlide\").innerHTML = \"01\";\n        //this.element.querySelector(\".maxSlide\").innerHTML = \"0\".concat(this.sectionNumber);\n        //this.setTitlePos();\n    };\n    \n    ContentSlider.prototype.setHeight = function () {\n        this.elementHeight = this.element.querySelector(ContentSlider.ELEMENTS.section).offsetHeight;\n        this.sectionNumber = this.element.querySelectorAll(ContentSlider.ELEMENTS.section).length;\n        var width = this.element.querySelector(ContentSlider.ELEMENTS.section).offsetWidth;\n        this.height = (this.sectionNumber - 1) * (width * 3) + this.elementHeight;\n        this.element.querySelector(ContentSlider.ELEMENTS.heightContainer).style.height = \"\".concat(this.height, \"px\");\n    };\n    \n    ContentSlider.prototype.handleScroll = function () {\n        var self = this;\n        wContainer = self.element.querySelector(ContentSlider.ELEMENTS.widthContainer), sContents = self.element.querySelector(ContentSlider.ELEMENTS.sliderContents), pBar = self.element.querySelector(ContentSlider.ELEMENTS.progressBar);\n        pBall = self.element.querySelector(ContentSlider.ELEMENTS.progressBall);\n        window.addEventListener(\"scroll\", function () {\n            self.scrollHandler.call(self, wContainer, sContents, pBar, pBall);\n        });\n    };\n    \n    ContentSlider.prototype.scrollHandler = function(wContainer, sContents, pBar, pBall) {\n        var self = this;\n        var s = self.getOffsetTop(self.element) - window.scrollY;\n        self.currentScroll = window.scrollY;\n        var pFill = s * -1 / (self.height - self.elementHeight) * 100;\n\n        if (s <= 0 && s >= (self.height - self.elementHeight) * -1 && self.fixed === false) {\n            document.body.style.overscrollBehaviorX = 'none';\n            wContainer.style.position = \"fixed\";\n            self.fixed = true;\n        } else if (s > 0) {\n            wContainer.style.position = \"absolute\";\n            wContainer.classList.add('top');\n            wContainer.classList.remove('bottom');\n            sContents.style.transform = \"translate3d(0px, 0px, 0px)\";\n            pBar.style.width = \"0%\";\n            pBall.style.left = \"0%\";\n            self.fixed = false;\n        } else if (s <= (self.height - self.elementHeight) * -1) {\n            var height = (self.height - self.elementHeight) * -1 / 3;\n            wContainer.style.position = \"absolute\";\n            wContainer.classList.add('bottom');\n            wContainer.classList.remove('top');\n            sContents.style.transform = \"translate3d(\".concat(height, \"px, 0px, 0px)\");\n            pBar.style.width = \"100%\";\n            pBall.style.left = \"100%\";\n            document.body.style.overscrollBehaviorX = 'auto';\n            self.fixed = false;\n        }\n\n        if (self.fixed) {\n            var ns = s / 3;\n            self.ns = ns;\n            var wScroll = s * -1;\n\n            var _height = (self.height - self.elementHeight) * -1 / 3;\n\n            if (ns) sContents.style.transform = \"translate3d(\".concat(ns, \"px, 0px, 0px)\");\n            pBar.style.width = \"\".concat(pFill, \"%\");\n            pBall.style.left = \"\".concat(pFill, \"%\");\n            var newIndex = Math.floor(self.sectionNumber * (pFill / 100)) + 1;\n\n            if (newIndex < 10) {\n                newIndex = \"0\".concat(newIndex);\n            }\n\n            var maxIndex = self.sectionNumber;\n\n            if (maxIndex < 10) {\n                maxIndex = \"0\".concat(maxIndex);\n            }\n\n            self.element.querySelector(\".currentSlide\").innerHTML = newIndex;\n            self.element.querySelector(\".maxSlide\").innerHTML = maxIndex; // if(pFill >= 90 && !self.circleOpen){\n            //         self.toggleProgressCircle('open');\n            // }else if(pFill < 90 && self.circleOpen){\n            //         self.toggleProgressCircle('close');\n            // }\n            // if(newIndex > self.sectionNum - 1){\n            //         return;\n            // }else if(newIndex !== self.currentIndex){\n            //         self.currentIndex = newIndex;\n            // }\n            // self.changeImageOpacity();\n        }\n\n        self.scrollPos = s;\n    };\n    \n    ContentSlider.prototype.handleDrag = function() {\n        var self = this;\n        var wee = self.element.querySelector(ContentSlider.ELEMENTS.sliderContents);\n        wee.addEventListener('mousedown', function (e) {\n            self.mousedown = true;\n            self.x = e.clientX;\n        });\n        wee.addEventListener('mouseup', function (e) {\n            self.mousedown = false;\n        });\n        wee.addEventListener('mousemove', function (e) {\n            if (self.mousedown === true && self.scrollPos < +30 && self.scrollPos > (self.height - self.elementHeight) * -1 - 30) {\n                var ws = window.scrollY,\n                        change = (self.x - e.clientX) * 3,\n                        newPos = ws += change;\n                window.scrollTo(0, newPos);\n                self.x = e.clientX;\n            }\n        });\n    };\n    \n    ContentSlider.prototype.getOffsetTop = function(ele) {\n        var offsetTop = 0;\n\n        while (ele) {\n            offsetTop += ele.offsetTop;\n            ele = ele.offsetParent;\n        }\n\n        return offsetTop;\n    };\n    \n    ContentSlider.prototype.setTitlePos = function() {\n        var width = this.element.querySelector(\".fl-row-content\").offsetWidth,\n                title = this.element.querySelector(\".sliderLabel\"),\n                prog = this.element.querySelector(\".progressBarContainer\");\n        var leftPos = (window.innerWidth - width) / 2;\n        title.style.left = \"\".concat(leftPos, \"px\");\n        prog.style.left = \"\".concat(leftPos, \"px\");\n    };\n    \n    ContentSlider.prototype.handleResize = function() {\n        var self = this,\n                wContainer = self.element.querySelector(ContentSlider.ELEMENTS.widthContainer),\n                sContents = self.element.querySelector(ContentSlider.ELEMENTS.sliderContents),\n                pBar = self.element.querySelector(ContentSlider.ELEMENTS.progressBar),\n                pBall = self.element.querySelector(ContentSlider.ELEMENTS.progressBall);\n        window.addEventListener(\"resize\", function () {\n            self.setHeight();\n            self.setTitlePos();\n            self.scrollHandler.call(self, wContainer, sContents, pBar, pBall);\n            this.setTimeout(function () {\n                self.setMobileOffset();\n            }, 500);\n        });\n    };\n    \n    ContentSlider.prototype.setMobileOffset = function() {\n        var offset = $(\".owl-stage\").offset().left;\n        $(\".sliderLabel\").css(\"margin-left\", \"\".concat(offset, \"px\"));\n        $(\".progressBarContainerMobile\").css(\"margin-left\", \"\".concat(offset, \"px\"));\n    };\n    \n    ContentSlider.prototype.updatePagination = function(event) {\n        var index = event.item.index;\n        this.updateNav(index);\n    };\n    \n    ContentSlider.prototype.updateNav = function(index) {\n        var current = this.element.querySelector(\".currentSlideMobile\");\n        var slideMax = this.element.querySelector(\".maxSlideMobile\");\n        var max = this.element.querySelectorAll(\".mobile-slider-item\").length;\n        index++;\n\n        if (index < 10) {\n            index = \"0\".concat(index);\n        }\n\n        if (max < 10) {\n            max = \"0\".concat(max);\n        }\n\n        current.innerHTML = index;\n        slideMax.innerHTML = max;\n        var percent = index / max * 100;\n        var ball = this.element.querySelector(\".progressBallMobile\");\n        var fill = this.element.querySelector(\".progressBarFillMobile\");\n        ball.style.left = \"\".concat(percent, \"%\");\n        fill.style.width = \"\".concat(percent, \"%\");\n    };\n    \n    Behaviors.register_behavior(ContentSlider);\n    \n    module.ContentSlider = ContentSlider;\n    \n    return module;\n}));","/* Paginate.js\n * A progressively-enhancing infinite scroll library\n * Â©2014 HUEMOR Designs All Rights Reserved\n */\n\n/*global jQuery, define, console, window, document*/\n(function (root, factory) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define('depaginate', ['jquery', \"Behaviors\"], factory);\n    } else if (root.jQuery) {\n        root.PaginateJS = factory(root.jQuery, root.Behaviors);\n    } else {\n        console.error(\"No jQuery found. Load jQuery before this module or use an AMD-compliant loader.\");\n    }\n}(this, function ($, Behaviors) {\n    \"use strict\";\n    \n    var module = {};\n    \n    function Pager(elem, page_select_handler) {\n        Behaviors.init(Pager, this, arguments);\n        \n        this.links = {};\n        this.current = null;\n        this.$pager = $(elem);\n        this.min_page_count = Infinity;\n        this.max_page_count = 0;\n        \n        this.$pager.addClass(\"is-Paginate--managed\");\n\n        this.page_select_handler = page_select_handler;\n\n        this.features = this.$pager.data(\"paginate-features\");\n\n        if (this.features === undefined) {\n            this.features = \"replaceState\";\n        }\n\n        console.log(\"Pager Features:\" + this.features);\n        this.features = this.features.split(\" \");\n    }\n    \n    Behaviors.inherit(Pager, Behaviors.Behavior);\n    \n    Pager.QUERY = \"[data-paginate='pager']\";\n    \n    Pager.DEFAULT_LINK = {\n        \"loaded\": false,\n        \"requested\": false,\n        \"pending\": false,\n        \"current\": false\n    };\n    \n    Pager.prototype.is_page_loaded = function (pagenumber) {\n        return this.links[pagenumber].loaded;\n    };\n    \n    Pager.prototype.set_current_page = function (pagenumber) {\n        var i = 0, pageid;\n        \n        if (this.current === pagenumber) {\n            return;\n        }\n        \n        this.current = pagenumber;\n        this.links[pagenumber] = this.links[pagenumber] || $.extend({}, Pager.DEFAULT_LINK);\n        \n        for (pageid in this.links) {\n            if (this.links.hasOwnProperty(pageid)) {\n                this.links[pageid].current = pageid === pagenumber;\n            }\n        }\n        \n        if (this.links[pagenumber].$pagerContents !== undefined) {\n            this.$pager.children().detach();\n            this.$pager.append(this.links[pagenumber].$pagerContents);\n        }\n        \n        if (this.links[pagenumber].href !== undefined) {\n            if (this.features.indexOf(\"replaceState\") > -1 && window.history.replaceState) {\n                window.history.replaceState({transition: true, url: this.links[pagenumber].href}, \"\", this.links[pagenumber].href);\n            }\n        }\n    };\n    \n    Pager.prototype.read_pager = function (pagerElem) {\n        var $newPager = $(pagerElem),\n            pagerThis = this;\n        \n        $newPager.find(\"[data-paginate='page']\").each(function (index, pageElem) {\n            var $newPage = $(pageElem),\n                page = $newPage.data(\"paginate-page\"),\n                isCurrent = $newPage.data(\"paginate-current\") !== undefined,\n                href = $newPage.attr(\"href\");\n            \n            pagerThis.links[page] = pagerThis.links[page] || $.extend({}, Pager.DEFAULT_LINK);\n            \n            pagerThis.links[page].href = href || pagerThis.links[page].href;\n            pagerThis.links[page].current = isCurrent;\n            \n            if (isCurrent) {\n                pagerThis.current = page;\n            }\n            \n            if (pagerThis.links[page].pending) {\n                pagerThis.load_page(page);\n            }\n            \n            if (page > pagerThis.max_page_count) {\n                pagerThis.max_page_count = page;\n            }\n            \n            if (page < pagerThis.min_page_count) {\n                pagerThis.min_page_count = page;\n            }\n\n            $newPage.on(\"click\", function (evt) {\n                evt.preventDefault();\n\n                if (pagerThis.page_select_handler) {\n                    pagerThis.page_select_handler(pagerThis, page);\n                }\n            });\n        });\n        \n        this.links[this.current] = this.links[this.current] || $.extend({}, Pager.DEFAULT_LINK);\n        this.links[this.current].$pagerContents = $newPager.children();\n        \n        if (this.links[this.current].$pagerContents !== undefined) {\n            this.$pager.children().detach();\n            this.$pager.append(this.links[this.current].$pagerContents);\n        }\n    };\n    \n    Pager.prototype.load_page = function (pagenumber, on_success, on_failure) {\n        var paginateThis = this;\n        \n        if (this.links[pagenumber] === undefined || this.links[pagenumber].href === undefined) {\n            this.links[pagenumber] = $.extend({}, this.links[pagenumber], Pager.DEFAULT_LINK);\n            this.links[pagenumber].pending = true;\n            this.links[pagenumber].on_success = on_success || this.links[pagenumber].on_success;\n            this.links[pagenumber].on_failure = on_failure || this.links[pagenumber].on_failure;\n            \n            return;\n        }\n        \n        if (this.links[pagenumber].requested || this.links[pagenumber].loaded) {\n            return;\n        }\n        \n        this.links[pagenumber].pending = false;\n        this.links[pagenumber].requested = true;\n        \n        $.ajax({\n            \"url\": this.links[pagenumber].href,\n            \"dataType\": \"html\"\n        }).done(function (data, textStatus, jqXHR) {\n            if (paginateThis.links[pagenumber].on_success !== undefined) {\n                paginateThis.links[pagenumber].on_success(data, textStatus, jqXHR);\n            }\n            \n            if (on_success !== undefined) {\n                on_success(data, textStatus, jqXHR);\n            }\n            \n            paginateThis.links[pagenumber].loaded = true;\n        }).fail(function (jqXHR, textStatus, errorThrown) {\n            if (paginateThis.links[pagenumber].on_failure !== undefined) {\n                paginateThis.links[pagenumber].on_failure(jqXHR, textStatus, errorThrown);\n            }\n            \n            if (on_failure !== undefined) {\n                on_failure(jqXHR, textStatus, errorThrown);\n            }\n        });\n    };\n    \n    Pager.prototype.is_first_page = function (test_page) {\n        return (test_page !== null && test_page === this.min_page_count);\n    };\n    \n    Pager.prototype.is_last_page = function (test_page) {\n        return (test_page !== null && test_page === this.max_page_count);\n    };\n    \n    module.Pager = Pager;\n    \n    function Region(elem, on_region_scrolled) {\n        var $extantRegion = $(elem);\n        Behaviors.init(Region, this, arguments);\n        \n        this.name = $extantRegion.data(\"paginate-region\");\n\n        this.load_methods = $extantRegion.data(\"paginate-methods\");\n\n        if (this.load_methods === undefined) {\n            this.load_methods = \"scroll\";\n        }\n\n        console.log(\"LoadMethods:\" + this.load_methods);\n        this.load_methods = this.load_methods.split(\" \");\n\n        this.features = $extantRegion.data(\"paginate-features\");\n\n        if (this.features === undefined) {\n            this.features = \"scrollOnLoad\";\n        }\n\n        console.log(\"Region Features:\" + this.features);\n        this.features = this.features.split(\" \");\n        \n        this.pages = {};\n        this.pagenumbers = [];\n        \n        this.min_page_loaded = Infinity;\n        this.max_page_loaded = 0;\n        \n        this.$region = $extantRegion;\n        \n        this.$parentScroller = null;\n        this.lastScrollTop = 0;\n        \n        this.on_region_scrolled = on_region_scrolled;\n        \n        this.$region.addClass(\"is-Paginate--managed\");\n    }\n    \n    Behaviors.inherit(Region, Behaviors.Behavior);\n    \n    Region.QUERY = \"[data-paginate='region']\";\n    \n    /* Called to append a new page to the region.\n     * \n     * Region contents will be extracted from the given region element and\n     * appended to the existing region, such that any existing content belonging\n     * to pages marked with a lower page number will appear before your page\n     * content, and any existing content belonging to pages marked with a higher\n     * page number will appear after your page content.\n     * \n     * Already inserted pages will not be reinserted into the region.\n     * \n     * As this function inserts content into the page, it will be presented to\n     * Behaviors to ensure any Behaviors on the new page content can locate\n     * correctly.\n     * \n     * An event will be fired from the region's element called depaginate_load\n     * which serves to indicate when a new page has loaded. Do not use this\n     * event to check if new content has been added to the page, use Behaviors'\n     * register_behavior or register_content_listener functions instead. This\n     * event will be called before behaviors have been located on their\n     * elements.\n     */\n    Region.prototype.read_page_region = function (pageNumber, regionElem) {\n        var $newRegion = $(regionElem),\n            itemSelector = $newRegion.data(\"paginate-selector\") || \"> *\",\n            prevPageNumberId = 0,\n            nextPageNumberId = this.pagenumbers.length,\n            nextPageNumber,\n            prevPageNumber,\n            pageAlreadyExists = false,\n            i = 0,\n            $newItems = $newRegion.find(itemSelector),\n            $firstItem = $newItems.first(),\n            $lastItem = $newItems.last(),\n            oldPageTop = 0,\n            newPageTop = 0,\n            evt;\n        \n        if (this.firstVisiblePage !== undefined) {\n            oldPageTop = this.page_top_position(this.firstVisiblePage);\n        }\n\n        for (i = 0; i < this.pagenumbers.length; i += 1) {\n            if (this.pagenumbers[i] < pageNumber) {\n                prevPageNumberId = i;\n                prevPageNumber = this.pagenumbers[i];\n            } else if (this.pagenumbers[i] === pageNumber) {\n                pageAlreadyExists = true;\n            } else {\n                nextPageNumber = this.pagenumbers[i];\n                nextPageNumberId = i;\n                break;\n            }\n        }\n        \n        if (!pageAlreadyExists) {\n            this.pagenumbers.splice(nextPageNumberId, 0, pageNumber);\n            \n            if (this.pages[prevPageNumber] !== undefined) {\n                $newItems = $newItems.insertAfter(this.pages[prevPageNumber].$lastItem);\n            } else if (this.pages[nextPageNumber] !== undefined) {\n                $newItems = $newItems.insertBefore(this.pages[nextPageNumber].$firstItem);\n            } //else do nothing since this obviously must be the original region\n            \n            $firstItem = $newItems.first();\n            $lastItem = $newItems.last();\n            \n            this.pages[pageNumber] = this.pages[pageNumber] || {};\n            this.pages[pageNumber].$newItems = $newItems;\n            this.pages[pageNumber].$firstItem = $firstItem;\n            this.pages[pageNumber].$lastItem = $lastItem;\n\n            evt = jQuery.Event(\"depaginate_load\");\n            evt.region = this;\n            evt.target = this.$region[0];\n            evt.$newItems = $newItems;\n\n            this.$region.trigger(evt);\n            \n            Behaviors.content_ready($newItems);\n        }\n        \n        if (pageNumber < this.min_page_loaded) {\n            this.min_page_loaded = pageNumber;\n        }\n        \n        if (pageNumber > this.max_page_loaded) {\n            this.max_page_loaded = pageNumber;\n        }\n\n        if (this.firstVisiblePage !== undefined) {\n            newPageTop = this.page_top_position(this.firstVisiblePage);\n\n            if (this.features.indexOf(\"scrollOnLoad\") > -1) {\n                window.setTimeout(\n                    this.scroll_by_delta.bind(this, newPageTop - oldPageTop),\n                    50\n                );\n            }\n        }\n    };\n    \n    Region.prototype.register_scroll_handler = function () {\n        var cssOverflowX,\n            regionThis = this;\n        \n        if (this.$parentScroller !== null) {\n            this.$parentScroller.off(\"scroll.paginate\");\n        }\n\n        this.$parentScroller = this.$region;\n\n        while (this.$parentScroller.length !== 0 && this.$parentScroller.get(0) !== document) {\n            cssOverflowX = this.$parentScroller.css(\"overflow-x\");\n\n            if (cssOverflowX === \"visible\" || cssOverflowX === \"hidden\") {\n                this.$parentScroller = this.$parentScroller.parent();\n            } else {\n                break;\n            }\n        }\n        \n        regionThis.on_scroll({\"target\": this.$parentScroller[0]});\n        this.$parentScroller.on(\"scroll.paginate\", function (evt) {\n            regionThis.on_scroll(evt);\n        });\n\n        this.lastScrollTop = this.$parentScroller.scrollTop();\n    };\n    \n    Region.prototype.on_scroll = function (evt) {\n        var $target = $(evt.target),\n            scrollTop = $target.scrollTop(),\n            scrollBottom = scrollTop + (evt.target !== document ? $target.height() : $(window).height()),\n            targetTop = evt.target !== document ? $target.position().top : 0,\n            targetAdjust = evt.target !== document ? scrollTop : 0,\n            i = 0,\n            firstVisibleTop = null,\n            firstVisiblePage = null,\n            lastVisiblePage = null,\n            lastVisibleBottom = null,\n            scrollDelta = scrollTop - this.lastScrollTop,\n            stopOuterLoopSentinel = false,\n            regionThis = this;\n        \n        this.lastScrollTop = scrollDelta;\n        \n        function pageEach(index, itemElem) {\n            var $itemElem = $(itemElem),\n                itemTop = targetAdjust + $itemElem.position().top - targetTop,\n                itemBottom = itemTop + $itemElem.height(),\n                isVisible = (scrollTop <= itemTop && itemTop <= scrollBottom) ||\n                            (scrollTop <= itemBottom && itemBottom <= scrollBottom) ||\n                            (itemTop <= scrollTop && scrollBottom <= itemBottom);\n            \n            if (!isVisible) {\n                if (lastVisiblePage !== null) {\n                    stopOuterLoopSentinel = true;\n                }\n\n                return true;\n            }\n\n            if (firstVisiblePage === null) {\n                firstVisiblePage = regionThis.pagenumbers[i];\n                firstVisibleTop = itemTop;\n            }\n            \n            lastVisiblePage = regionThis.pagenumbers[i];\n            lastVisibleBottom = itemTop + $itemElem.height();\n\n            return false;\n        }\n        \n        //Determine what pages are visible now\n        if (this.pagenumbers.length === 0) {\n            console.log(\"There are no page numbers.\");\n        }\n        \n        for (i = 0; i < this.pagenumbers.length; i += 1) {\n            if (this.pages[this.pagenumbers[i]].$newItems === 0) {\n                console.log(\"There are no pages within page \" + this.pagenumbers[i]);\n            }\n            \n            this.pages[this.pagenumbers[i]].$newItems.each(pageEach);\n            \n            if (stopOuterLoopSentinel) {\n                stopOuterLoopSentinel = false;\n                break;\n            }\n        }\n        \n        if (firstVisiblePage === null) {\n            console.log(\"First visible page did NOT get set. Dropping the scroll event.\");\n            return;\n        }\n        \n        this.firstVisiblePage = firstVisiblePage;\n        this.lastVisiblePage = lastVisiblePage;\n        this.firstVisibleTop = firstVisibleTop;\n        this.lastVisibleBottom = lastVisibleBottom;\n\n        if (this.load_methods.indexOf(\"scroll\") > -1) {\n            this.on_region_scrolled(this, scrollTop, scrollBottom, scrollDelta, firstVisiblePage, lastVisiblePage, firstVisibleTop, lastVisibleBottom);\n        }\n    };\n    \n    Region.prototype.first_loaded_page = function () {\n        return this.min_page_loaded;\n    };\n    \n    Region.prototype.last_loaded_page = function () {\n        return this.max_page_loaded;\n    };\n    \n    Region.prototype.set_additional_content_indicators = function (has_next_page, has_prev_page) {\n        if (has_next_page) {\n            this.$region.addClass(\"is-Paginate--has_next_page\");\n            this.$region.removeClass(\"is-Paginate--no_next_page\");\n        } else {\n            this.$region.removeClass(\"is-Paginate--has_next_page\");\n            this.$region.addClass(\"is-Paginate--no_next_page\");\n        }\n        \n        if (has_prev_page) {\n            this.$region.addClass(\"is-Paginate--has_prev_page\");\n            this.$region.removeClass(\"is-Paginate--no_prev_page\");\n        } else {\n            this.$region.removeClass(\"is-Paginate--has_prev_page\");\n            this.$region.addClass(\"is-Paginate--no_prev_page\");\n        }\n    };\n    \n    /* Returns the position of the top of a particular page.\n     */\n    Region.prototype.page_top_position = function (pagenumber) {\n        var page = this.pages[pagenumber],\n            $firstItem,\n            measuredOffset,\n            $parentScroller = this.$parentScroller,\n            scrollerOffset = 0,\n            encounteredScroller = false;\n        \n        if (page === undefined) {\n            console.log(\"Missing page: \" + pagenumber);\n            console.log(this.pages);\n            \n            if (pagenumber < this.min_page_loaded || pagenumber === null) {\n                pagenumber = this.min_page_loaded;\n            }\n            \n            if (pagenumber > this.max_page_loaded) {\n                pagenumber = this.max_page_loaded;\n            }\n            \n            page = this.pages[pagenumber];\n        }\n        \n        $firstItem = page.$firstItem;\n        measuredOffset = $firstItem.offset().top;\n        if ($parentScroller[0] !== document) {\n            scrollerOffset = $parentScroller.offset().top;\n        }\n        \n        return measuredOffset - scrollerOffset;\n    };\n    \n    /* Scroll the region by a particular delta. */\n    Region.prototype.scroll_by_delta = function (scrollDelta) {\n        var $parentScroller = this.$parentScroller;\n        \n        $parentScroller.scrollTop($parentScroller.scrollTop() + scrollDelta);\n    };\n    \n    Region.prototype.scroll_absolutely = function (scrollAbs) {\n        var $parentScroller = this.$parentScroller;\n        \n        $parentScroller.scrollTop(scrollAbs);\n    };\n    \n    module.Region = Region;\n    \n    function Paginate(elem) {\n        var $extantPager = $(elem).find(Pager.QUERY),\n            $extantRegions = $(elem).find(Region.QUERY),\n            currentPage = $(elem).data(\"paginate-page\"),\n            paginateThis = this;\n        \n        Behaviors.init(Paginate, this, arguments);\n        \n        if ($extantPager.length === 0) {\n            console.error(\"No pager was found in this paginage instance.\");\n            return;\n        }\n        \n        if (this.$elem.attr('id') === undefined) {\n            console.error(\"This paginate needs an id before it can be used.\");\n            return;\n        }\n        \n        console.log(\"page: \" + currentPage);\n        \n        this.$context = $(elem);\n        this.id = this.$context.attr(\"id\");\n        \n        function pshClosure() {\n            paginateThis.page_select_handler.apply(paginateThis, arguments);\n        }\n\n        this.pager = Pager.locate($extantPager.get(0), pshClosure);\n        \n        if ($extantPager.data(\"paginate-count\") === 1) {\n            console.log(\"Not activating depaginate on a region with only one page.\");\n            return;\n        }\n        \n        this.pager.set_current_page(currentPage);\n        this.pager.read_pager($extantPager.get(0));\n        \n        this.regions = {};\n        this.regionNames = [];\n        \n        this.currentPage = currentPage;\n        \n        function orsClosure() {\n            paginateThis.on_region_scrolled.apply(paginateThis, arguments);\n        }\n        \n        this.features = $extantPager.data(\"paginate-features\");\n\n        if (this.features === undefined) {\n            this.features = \"backScroll\";\n        }\n\n        console.log(\"Paginate Features:\" + this.features);\n        this.features = this.features.split(\" \");\n\n        $extantRegions.each(function (index, elem) {\n            var $extantRegion = $(elem),\n                regionName = $extantRegion.data(\"paginate-region\"),\n                region,\n                currentPage = paginateThis.currentPage;\n            \n            console.log(\"page: \" + currentPage);\n            \n            function scrollBack() {\n                console.log(\"Scrolling back the user to \" + region.page_top_position(currentPage) + \" (page: \" + currentPage + \")\");\n                region.scroll_absolutely(region.page_top_position(currentPage));\n            }\n            \n            paginateThis.regionNames.push(regionName);\n            \n            region = paginateThis.regions[regionName] || Region.locate(elem, orsClosure);\n            paginateThis.regions[regionName] = region;\n            \n            region.read_page_region(currentPage, elem);\n            region.register_scroll_handler();\n            \n            paginateThis.update_region_indicators(region);\n            \n            if (!paginateThis.pager.is_first_page(currentPage) && paginateThis.features.indexOf(\"backScroll\") > -1) {\n                //User pressed back button, scroll the region into view\n                \n                $(document).ready(scrollBack);\n                $(window).on(\"load\", function () {\n                    window.setTimeout(scrollBack, 1500);\n                });\n            }\n        });\n    }\n    \n    Behaviors.inherit(Paginate, Behaviors.Behavior);\n    \n    Paginate.QUERY = \"[data-paginate='paginate']\";\n    \n    Paginate.prototype.page_load_success = function (data, textStatus, jqXHR) {\n        var $data = $(data),\n            i = 0,\n            $dataPaginate,\n            $dataRegion,\n            $dataPager,\n            region = null,\n            paginateThis = this,\n            next_page = 0;\n\n        $dataPaginate = $data.find(\"#\" + this.id);\n        \n        if ($dataPaginate.length === 0) {\n            $dataPaginate = $data.filter(\"#\" + this.id);\n        }\n        \n        if ($dataPaginate.length === 0) {\n            console.error(\"DEPAGINATE: The paginate context with ID \" + this.id + \" could not be found in the loaded page. Errors may result.\");\n        }\n        \n        next_page = $dataPaginate.data(\"paginate-page\");\n\n        for (i = 0; i < this.regionNames.length; i += 1) {\n            $dataRegion = $dataPaginate.find(\"[data-paginate-region='\" + this.regionNames[i] + \"']\");\n\n            if ($dataRegion.length > 0) {\n                region = this.regions[this.regionNames[i]];\n                region.read_page_region(next_page, $dataRegion[0]);\n            }\n        }\n\n        $dataPager = $dataPaginate.find(Pager.QUERY);\n        $dataPager.each(function (index, pagerElem) {\n            paginateThis.pager.read_pager(pagerElem);\n        });\n\n        this.pager.set_current_page(next_page);\n        this.update_region_indicators(region);\n    };\n\n    Paginate.prototype.page_select_handler = function (pager, pagenumber) {\n        var paginateThis = this;\n        if (this.pager.is_page_loaded(pagenumber)) {\n            return;\n        }\n\n        function on_success() {\n            paginateThis.page_load_success.apply(paginateThis, arguments);\n        }\n\n        this.pager.load_page(pagenumber, on_success);\n    };\n\n    Paginate.prototype.on_region_scrolled = function (region, scrollTop, scrollBottom, scrollDelta, firstVisiblePage, lastVisiblePage, firstVisibleTop, lastVisibleBottom) {\n        var visible_range = lastVisibleBottom - firstVisibleTop,\n            visible_pagerange = lastVisiblePage - firstVisiblePage,\n            average_page_size = visible_range / visible_pagerange,\n            scroll_direction_down = scrollDelta > 0,\n            should_load_page,\n            next_page,\n            paginateThis = this;\n        \n        function on_success() {\n            paginateThis.page_load_success.apply(paginateThis, arguments);\n        }\n        \n        if (scroll_direction_down) {\n            should_load_page = scrollBottom + scrollDelta >= lastVisibleBottom;\n            next_page = lastVisiblePage + 1;\n            \n            this.pager.set_current_page(lastVisiblePage);\n        } else {\n            should_load_page = scrollTop + scrollDelta < firstVisibleTop;\n            next_page = firstVisiblePage - 1;\n            \n            this.pager.set_current_page(firstVisiblePage);\n        }\n        \n        if (next_page < 0) {\n            return;\n        }\n        \n        if (should_load_page) {\n            this.pager.load_page(next_page, on_success);\n        }\n    };\n    \n    Paginate.prototype.update_region_indicators = function (region) {\n        region.set_additional_content_indicators(\n            !this.pager.is_last_page(region.last_loaded_page()),\n            !this.pager.is_first_page(region.first_loaded_page())\n        );\n    };\n    \n    module.Paginate = Paginate;\n    \n    Behaviors.register_behavior(Paginate);\n    \n    return module;\n}));","","/*global define,google,Promise*/\n(function (root, factory) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(\"GoogleMap\", [\"jquery\", \"Behaviors\"], factory);\n    } else {\n        root.GoogleMap = factory(root.jQuery, root.Behaviors);\n    }\n}(this, function ($, Behaviors) {\n    \"use strict\";\n    \n    var module = {};\n    \n    function GoogleMap() {\n        Behaviors.init(GoogleMap, this, arguments);\n        \n        this.load_gmaps().then(this.render_map.bind(this));\n    }\n    \n    Behaviors.inherit(GoogleMap, Behaviors.Behavior);\n    \n    GoogleMap.QUERY = \"[data-googlemap]\";\n    \n    GoogleMap.prototype.center_specified_by_markup = function () {\n        return this.$elem.data(\"googlemap-lat\") !== undefined && this.$elem.data(\"googlemap-lng\") !== undefined;\n    };\n    \n    GoogleMap.prototype.determine_default_args = function () {\n        var args = {\n            center: {lat: 0, lng: 0},\n            mapTypeId: google.maps.MapTypeId.ROADMAP,\n            disableDefaultUI: true,\n            draggable: false,\n            scrollwheel: false,\n            zoom: 15\n        };\n        \n        if (this.$elem.data(\"googlemap-draggable\") !== undefined) {\n            args.draggable = true;\n        }\n        \n        if (this.$elem.data(\"googlemap-scrollzoom\") !== undefined) {\n            args.scrollwheel = true;\n        }\n        \n        if (this.center_specified_by_markup()) {\n            args.center = {lat: this.$elem.data(\"googlemap-lat\"),\n                           lng: this.$elem.data(\"googlemap-lng\")};\n        }\n        \n        if (this.$elem.data(\"googlemap-zoom\") !== undefined) {\n            args.zoom = this.$elem.data(\"googlemap-zoom\");\n        }\n        \n        return args;\n    };\n    \n    GoogleMap.prototype.load_gmaps = function () {\n        return Promise.resolve().then(function () {\n            if (window.google) {\n                return;\n            } else {\n                //TODO: Autoload Gmaps API\n                throw new Error(\"Google Maps API not loaded at time of initialization.\");\n            }\n        });\n    };\n    \n    GoogleMap.prototype.render_map = function () {\n        var $markers = this.$elem.find('[data-googlemap-marker]'), i;\n        \n        // create map\n        this.map = new google.maps.Map(this.$elem[0], this.determine_default_args());\n        \n        this.map.markers = [];\n        for (i = 0; i < $markers.length; i += 1) {\n            this.add_marker($($markers[i]), this.map);\n        }\n        \n        // center map\n        this.center_map();\n    };\n    \n    GoogleMap.prototype.add_marker = function ($marker) {\n        var latlng = new google.maps.LatLng($marker.data('googlemap-lat'), $marker.data('googlemap-lng')),\n            marker = new google.maps.Marker({\n                position: latlng,\n                map: this.map\n            }),\n            infowindow;\n        \n        this.map.markers.push(marker);\n        \n        // if marker contains HTML, add it to an infoWindow\n        if ($marker.html()) {\n            infowindow = new google.maps.InfoWindow({\n                content\t\t: $marker.html()\n            });\n            \n            google.maps.event.addListener(marker, 'click', this.marker_click_intent.bind(this, marker, infowindow));\n        }\n    };\n    \n    GoogleMap.prototype.marker_click_intent = function (marker, infowindow) {\n        infowindow.open(this.map, marker);\n    };\n    \n    GoogleMap.prototype.center_map = function () {\n        var i, marker, latlng, bounds = new google.maps.LatLngBounds();\n        \n        // loop through all markers and create bounds\n        for (i = 0; i < this.map.markers.length; i += 1) {\n            marker = this.map.markers[i];\n            latlng = new google.maps.LatLng(marker.position.lat(), marker.position.lng());\n            bounds.extend(latlng);\n        }\n        \n        if (!this.center_specified_by_markup()) {\n            if (this.map.markers.length === 1) {\n                this.map.setCenter(bounds.getCenter());\n            } else {\n                this.map.fitBounds(bounds);\n            }\n        }\n    };\n    \n    Behaviors.register_behavior(GoogleMap);\n    \n    module.GoogleMap = GoogleMap;\n    \n    return module;\n}));","/*global define, console*/\n/*jslint bitwise: true */\n/* updated 9/14/2016 */\n\nif (!Array.prototype.indexOf) {\n    Array.prototype.indexOf = function (elt) { /*, from*/\n        \"use strict\";\n        var len = this.length >>> 0, from = Number(arguments[1]) || 0, derparam;\n        from = (from < 0) ? Math.ceil(from) : Math.floor(from);\n        if (from < 0) {\n            from += len;\n        }\n\n        for (derparam; from < len; from += 1) {\n            if (from in this && this[from] === elt) {\n                return from;\n            }\n        }\n        return -1;\n    };\n}\n\n(function (root, factory) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(\"betteroffcanvas\", [\"jquery\"], factory);\n    } else {\n        // Browser globals\n        root.betteroffcanvas = factory(root.jQuery);\n    }\n}(this, function ($) {\n    //BetterOffcanvas\n    //Works like this:\n    /*\n    *  <button type=\"button\" data-toggle=\"offcanvas\" data-target=\"#any-selector\">\n    */\n\n    \"use strict\";\n\n    var $openTarget = null, currentLevel = 0, module = {}, isInDebounce = false,\n        target_has_touch = false,\n        focus_click_inquiry = false, click_keydown_inquiry = false,\n        eligibleTouches = {},\n        logger;\n    \n    /* Logger that throws away all data (default)\n     */\n    function null_logging() {\n        return;\n    }\n    \n    /* Logger that sends all logged data to the JS console.\n     */\n    function console_logging(log_data) {\n        return console.log(log_data);\n    }\n    \n    function switchLoggingMode(mode) {\n        switch (mode) {\n        case \"console\":\n            logger = console_logging;\n            break;\n        default:\n            logger = null_logging;\n            break;\n        }\n    }\n    \n    //Inform the user they can enable console logging\n    console.log(\"Offcanvas: You can enable detailed event logging by typing betteroffcanvas.switchLoggingMode('console').\");\n    switchLoggingMode(\"null\");\n\n    function initOffcanvasToggle($theToggle) {\n        var $theTarget = $($theToggle.data(\"target\")), toggleOptions = $theToggle.data(\"toggle-options\"),\n            state;\n\n        if ($theTarget.data(\"offcanvas-state\") === undefined) {\n            $theTarget.data(\"offcanvas-state\", {\"open\": false, \"parents\": null, \"$openChild\": null, \"openChildLvl\": 0, \"toggleOptions\": []});\n        }\n\n        state = $theTarget.data(\"offcanvas-state\");\n\n        if (state.toggleOptions === undefined) {\n            state.toggleOptions = [];\n        }\n\n        if (toggleOptions !== undefined) {\n            state.toggleOptions.push.apply(state.toggleOptions, toggleOptions.split(\" \"));\n        }\n\n        $theTarget.data(\"offcanvas-state\", state);\n\n        return $theTarget;\n    }\n\n    function findParentLevels($theTarget) {\n        var parents = [], tgtState = $theTarget.data(\"offcanvas-state\");\n\n        if (tgtState.parents === null) {\n            $theTarget.parents().each(function (index, pelem) {\n                var $pelem = $(pelem),\n                    parState = $pelem.data(\"offcanvas-state\"),\n                    $parTgl;\n\n                if (parState === undefined) {\n                    if ($pelem.attr(\"id\") !== undefined) {\n                        $parTgl = $(\"[data-toggle='offcanvas'][data-target='#\" + $pelem.attr(\"id\") + \"']\");\n                        if ($parTgl.length > 0) {\n                            initOffcanvasToggle($parTgl);\n                            parents.push(pelem);\n                        }\n                    }\n                } else {\n                    parents.push(pelem);\n                }\n            });\n\n            tgtState.parents = parents;\n            $theTarget.data(\"offcanvas-state\", tgtState);\n\n            $(tgtState.parents).each(function (index, pelem) {\n                findParentLevels($(pelem));\n            });\n        }\n    }\n\n    function initOffcanvas($theTarget, toggleOptions) {\n        if (toggleOptions === undefined) {\n            toggleOptions = [];\n        }\n        \n        if ($theTarget.data(\"offcanvas-state\") === undefined) {\n            $theTarget.data(\"offcanvas-state\", {\"open\": false, \"parents\": null, \"$openChild\": null, \"openChildLvl\": 0, \"toggleOptions\": toggleOptions});\n        }\n\n        findParentLevels($theTarget);\n    }\n\n    function isOffcanvas($theTargetList) {\n        var truth = true;\n\n        $theTargetList.each(function (index, elem) {\n            var $theTarget = $(elem), $toggles;\n\n            if ($theTarget.data(\"offcanvas-state\") !== undefined) {\n                truth = truth & true;\n                return;\n            }\n\n            $toggles = $(\"[data-toggle='offcanvas'][data-target='#\" + $theTarget.attr(\"id\") + \"']\");\n\n            if ($toggles.length > 0) {\n                initOffcanvas($theTarget);\n\n                $toggles.each(function (index, elem) {\n                    initOffcanvasToggle($(elem));\n                });\n\n                truth &= true;\n                return;\n            }\n\n            truth &= false;\n        });\n\n        return truth;\n    }\n\n    function isChildOffcanvas($theTarget, $potentialParent) {\n        if (!isOffcanvas($theTarget) || !isOffcanvas($potentialParent)) {\n            return false;\n        }\n\n        if ($theTarget.data(\"offcanvas-state\").parents.indexOf($potentialParent[0]) === -1) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function isTopLevelOffcanvas($theTarget) {\n        return isOffcanvas($theTarget) && $theTarget.data(\"offcanvas-state\").parents.length === 0;\n    }\n\n    function updateBackdrop(newLevel, openTargetList) {\n        var $backdropDivs = $(\"[data-offcanvas-backdrop]\");\n\n        $backdropDivs.each(function (index, bdElem) {\n            var $bdElem = $(bdElem),\n                bdLevel = $bdElem.data(\"offcanvas-backdrop\"),\n                bdFor = $bdElem.data(\"offcanvas-backdrop-for\");\n\n            if (bdFor !== undefined && openTargetList.indexOf(bdFor) === -1) {\n                $bdElem.removeClass(\"is-Offcanvas--backdrop_active\");\n                $bdElem.addClass(\"is-Offcanvas--backdrop_inactive\");\n            } else if (newLevel >= bdLevel) {\n                $bdElem.addClass(\"is-Offcanvas--backdrop_active\");\n                $bdElem.removeClass(\"is-Offcanvas--backdrop_inactive\");\n            } else {\n                $bdElem.removeClass(\"is-Offcanvas--backdrop_active\");\n                $bdElem.addClass(\"is-Offcanvas--backdrop_inactive\");\n            }\n        });\n\n        currentLevel = newLevel;\n    }\n\n    function scanChildrenWithinLevel($theTarget, cbk) {\n        $theTarget.each(function (index, elem) {\n            var $elem = $(elem);\n\n            if (isOffcanvas($elem)) {\n                return;\n            }\n\n            cbk($elem);\n            scanChildrenWithinLevel($elem.children(), cbk);\n        });\n    }\n\n    function setFocusableWithinLevel($theTarget, isFocusable) {\n        if (isFocusable === undefined) {\n            isFocusable = true;\n        }\n\n        logger(\"changing focus state to \" + isFocusable);\n\n        scanChildrenWithinLevel($theTarget.children(), function ($elem) {\n            if ($elem.data(\"offcanvas-tabindex\") === undefined) {\n                //Determine if this element should be focusable or not...\n                if ($elem.attr(\"tabindex\") !== undefined) {\n                    $elem.data(\"offcanvas-tabindex\", $elem.attr(\"offcanvas-tabindex\"));\n                } else {\n                    $elem.data(\"offcanvas-tabindex\", null);\n                }\n            }\n\n            if (isFocusable) {\n                if ($elem.data(\"offcanvas-tabindex\") === null) {\n                    $elem.removeAttr(\"tabindex\");\n                } else {\n                    $elem.attr(\"tabindex\", $elem.data(\"offcanvas-tabindex\"));\n                }\n            } else {\n                $elem.attr(\"tabindex\", -1);\n            }\n        });\n    }\n\n    function openOffcanvas($theTarget, $theToggle, eventType, isRecursive, recursiveCount) {\n        var tgtState, $pelem, parState, newLevel = 1, i, targetIDs = [], $topElem, topState, newEvent;\n        if ($theTarget !== null && $theTarget !== undefined) {\n            logger(\"Open Offcanvas \" + $theTarget.attr(\"id\"));\n        } else {\n            logger(\"Open Offcanvas (no target)\");\n        }\n\n        if ($theTarget === null) {\n            return;\n        }\n        tgtState = $theTarget.data(\"offcanvas-state\");\n\n        if (recursiveCount === undefined) {\n            recursiveCount = 1;\n        }\n\n        $theTarget.addClass(\"is-Offcanvas--open\");\n        $theTarget.removeClass(\"is-Offcanvas--closed\");\n        tgtState.open = true;\n        tgtState.open_event = eventType;\n        $theTarget.data(\"offcanvas-state\", tgtState);\n\n        $(\"[data-toggle='offcanvas'][data-target='#\" + $theTarget.attr(\"id\") + \"']\").addClass(\"is-Offcanvas--target_open\");\n\n        setFocusableWithinLevel($theTarget, true);\n\n        if (tgtState.parents.length > 0) {\n            $pelem = $(tgtState.parents[0]);\n\n            parState = $pelem.data(\"offcanvas-state\");\n            parState.$openChild = $theTarget;\n            parState.openChildLvl = recursiveCount;\n            $pelem.data(\"offcanvas-state\", parState);\n\n            $pelem.addClass(\"is-Offcanvas--open_sublvl_\" + recursiveCount);\n\n            openOffcanvas($pelem, $theToggle, eventType, true, recursiveCount + 1);\n\n            newLevel = newLevel + tgtState.parents.length;\n\n            $topElem = $(tgtState.parents[tgtState.parents.length - 1]);\n            if ($topElem.length > 0) {\n                topState = $topElem.data(\"offcanvas-state\");\n\n                if (topState !== undefined) {\n                    if (topState.childDepthLvl !== undefined) {\n                        $topElem.removeClass(\"is-Offcanvas--depth_\" + topState.childDepthLvl);\n                    }\n\n                    topState.childDepthLvl = tgtState.parents.length;\n                    $topElem.addClass(\"is-Offcanvas--depth_\" + topState.childDepthLvl);\n                }\n            }\n        }\n\n        if (isRecursive !== true) {\n            targetIDs.push($theTarget.attr(\"id\"));\n\n            for (i = 0; i < tgtState.parents.length; i += 1) {\n                targetIDs.push(tgtState.parents[i].getAttribute(\"id\"));\n            }\n\n            updateBackdrop(newLevel, targetIDs);\n        }\n\n        $openTarget = $theTarget;\n\n        newEvent = new $.Event({\n            \"type\": \"offcanvas-open\",\n            \"target\": $theTarget,\n            \"toggle\": $theToggle,\n            \"from_child\": isRecursive,\n            \"children_count\": recursiveCount\n        });\n        $theTarget.trigger(newEvent);\n    }\n    \n    /* Determine if a user-triggered event is allowed to dismiss an offcanvas\n     * or not.\n     * \n     * This function is consistenly called before dismissOffcanvas in order to\n     * gate event-driven dismissals consistently. Programmatic dismissals (e.g.\n     * by third-party code or for clearing the way for the next offcanvas) are\n     * NOT gated in the same way.\n     * \n     * To gate dismissals in the same fashion, call this function with the\n     * following four parameters:\n     * \n     *  - $_openTarget: The currently open offcanvas at the start of event\n     *                 processing. Specify false to automatically select the\n     *                 current open target. Specify undefined for no open\n     *                 target.\n     * \n     *  - $newTarget:  The new offcanvas that you plan to open at the end of\n     *                 event processing.\n     * \n     *  - evt:         The event that triggered your current event processing.\n     *                 Your code is expected to filter mobile emulation events\n     *                 such as emulated click-after-touchend through some means\n     *                 so that this function can differentiate between the two.\n     * \n     *  - $evtToggle:  The element which triggered the event. May be a\n     *                 data-toggle or data-dismiss element. This is not,\n     *                 strictly speaking, evt.target: client code is allowed and\n     *                 expected to traverse the parents of the target to find,\n     *                 say, the button containing the actual event target.\n     * \n     * In the event of recieving false from this function, event handlers should\n     * cease any event processing which would cause the open target to be\n     * dismissed, including opening other offcanvas hierarchies as that will\n     * implicitly dismiss the current one.\n     */\n    function eventCanDismissOffcanvas($_openTarget, $newTarget, evt, $evtToggle) {\n        var openTargetState = {\"toggleOptions\": []}, openTargetIsNoHover = false,\n            openTargetWasHovered = false,\n            targetsAreIdentical = false,\n            evtFromToggle = false, evtFromDismiss = false,\n            evtWithinOpenTarget = false,\n            evtToggleOptions, evtToggleIsNoHover = false,\n            evtToggleTargetsOpenTarget = false,\n            hasNewTarget,\n            hasOpenTarget,\n            hasEventToggle;\n        \n        if ($_openTarget === false) {\n            $_openTarget = $openTarget;\n        }\n        \n        hasNewTarget = $newTarget !== undefined && $newTarget !== null && $newTarget.length >= 1;\n        hasOpenTarget = $_openTarget !== undefined && $_openTarget !== null && $_openTarget.length >= 1;\n        hasEventToggle = $evtToggle !== undefined && $evtToggle !== null && $evtToggle.length >= 1;\n        \n        if (hasOpenTarget) {\n            openTargetState = $_openTarget.data(\"offcanvas-state\");\n            openTargetIsNoHover = openTargetState.toggleOptions.indexOf(\"nohover\") > -1;\n            openTargetWasHovered = openTargetState.open_event === \"mouseover\";\n            \n            if (evt.target) {\n                evtWithinOpenTarget = $_openTarget[0] === evt.target || $.contains($_openTarget[0], evt.target);\n            }\n        } else {\n            logger(\"Dismissals are always allowed if no offcanvas is open\");\n            return true;\n        }\n        \n        if (hasNewTarget) {\n            targetsAreIdentical = $_openTarget[0] === $newTarget[0];\n        }\n        \n        if (hasEventToggle) {\n            evtFromToggle = $evtToggle.filter(\"[data-toggle='offcanvas']\").length > 0 ||\n                            $evtToggle.parents().filter(\"[data-toggle='offcanvas']\").length > 0;\n            evtFromDismiss = $evtToggle.filter(\"[data-dismiss='offcanvas']\").length > 0 ||\n                             $evtToggle.parents().filter(\"[data-dismiss='offcanvas']\").length > 0;\n            \n            evtToggleOptions = $evtToggle.data(\"toggle-options\");\n            if (evtToggleOptions !== undefined) {\n                evtToggleOptions = evtToggleOptions.split(\" \");\n            } else {\n                evtToggleOptions = [];\n            }\n            \n            evtToggleIsNoHover = evtToggleOptions.indexOf(\"nohover\") > -1;\n            evtToggleTargetsOpenTarget = $evtToggle.data(\"target\") === \"#\" + $_openTarget.attr(\"id\");\n        }\n        \n        //Dismissals by toggling the same target\n        if (evt.type === \"click\" && openTargetWasHovered) {\n            if (targetsAreIdentical) {\n                logger(\"Not going to allow dismiss from click on already hovered nav.\");\n                return false;\n            }\n        }\n        \n        if (evt.type === \"focusin\") {\n            if (targetsAreIdentical) { //TODO: should this be evtWithinOpenTarget?\n                logger(\"Not going to allow dismiss from focusin within same target\");\n                return false;\n            }\n            \n            if (!hasNewTarget && (evtFromToggle || evtFromDismiss)) {\n                logger(\"Ignoring focus-dismiss due to the fact that event target is an offcanvas toggle.\");\n                logger(\"Currently focused off-canvas element: \" + $_openTarget.attr(\"id\"));\n                return false;\n            }\n        }\n        \n        if (evt.type === \"mouseover\" && !evtWithinOpenTarget) {\n            if (evtFromDismiss) {\n                logger(\"Not going to allow dismiss until user actually clicks hovered dismiss button.\");\n                return false;\n            } else if (evtToggleIsNoHover || openTargetIsNoHover) {\n                logger(\"Not going to allow dismiss as toggle is nohover.\");\n                return false;\n            } else if (evtFromToggle && targetsAreIdentical) {\n                logger(\"Not going to allow dismiss as toggle is for current offcanvas.\");\n                return false;\n            }\n        }\n        \n        return true;\n    }\n\n    function dismissOffcanvas($theTarget, numLvls) {\n        var tgtState = $theTarget.data(\"offcanvas-state\"), newLvl = -1, i, targetIDs = [], $topElem, topState, newEvent;\n\n        if ($theTarget !== null && $theTarget !== undefined) {\n            logger(\"Dismiss Offcanvas \" + $theTarget.attr(\"id\"));\n        } else {\n            logger(\"Dismiss Offcanvas (no target)\");\n        }\n\n        if (numLvls === undefined) {\n            /* NumLvls is the number of recursion levels (children being auto-dismissed) */\n            numLvls = 1;\n\n            $topElem = $(tgtState.parents[tgtState.parents.length - 1]);\n            if ($topElem.length > 0) {\n                topState = $topElem.data(\"offcanvas-state\");\n\n                if (topState !== undefined) {\n                    if (topState.childDepthLvl !== undefined) {\n                        $topElem.removeClass(\"is-Offcanvas--depth_\" + topState.childDepthLvl);\n                    }\n\n                    topState.childDepthLvl = tgtState.parents.length - 1;\n                    $topElem.addClass(\"is-Offcanvas--depth_\" + topState.childDepthLvl);\n                }\n            }\n        }\n\n        $theTarget.removeClass(\"is-Offcanvas--open\");\n        $theTarget.addClass(\"is-Offcanvas--closed\");\n        tgtState.open = false;\n        tgtState.open_event = undefined;\n        $theTarget.data(\"offcanvas-state\", tgtState);\n\n        $(\"[data-toggle='offcanvas'][data-target='#\" + $theTarget.attr(\"id\") + \"']\").removeClass(\"is-Offcanvas--target_open\");\n\n        newEvent = new $.Event({\n            \"type\": \"offcanvas-dismiss\",\n            \"target\": $theTarget\n        });\n        $theTarget.trigger(newEvent);\n\n        //TODO: How do we actually tell if the offcanvas is visible when closed?\n        //(e.g. desktop nav)\n        if (!isTopLevelOffcanvas($theTarget)) {\n            if ($theTarget !== null) {\n                logger(\"Marking non-top-level offcanvas nav \" + $theTarget.attr(\"id\") + \" as untabbable\");\n            }\n            setFocusableWithinLevel($theTarget, false);\n        }\n\n        if (tgtState.$openChild !== null) {\n            dismissOffcanvas(tgtState.$openChild, numLvls + 1);\n        } else {\n            if (tgtState.parents.length > 0) {\n                $openTarget = $(tgtState.parents[numLvls - 1]);\n                if ($openTarget.length === 0) {\n                    $openTarget = null;\n                }\n\n                $(tgtState.parents).each(function (index, pelem) {\n                    var $pelem = $(pelem), parState = $pelem.data(\"offcanvas-state\"), childlvl, newChildLvl = parState.openChildLvl - numLvls;\n\n                    $pelem.removeClass(\"is-Offcanvas--open_sublvl_\" + parState.openChildLvl);\n                    if (newChildLvl > 0) {\n                        $pelem.addClass(\"is-Offcanvas--open_sublvl_\" + newChildLvl);\n                    } else {\n                        parState.$openChild = null;\n                    }\n\n                    parState.openChildLvl = newChildLvl;\n                    $pelem.data(\"offcanvas-state\", parState);\n\n                    if (newChildLvl > newLvl) {\n                        newLvl = newChildLvl;\n                    }\n                });\n            } else {\n                $openTarget = null;\n                newLvl = -1;\n            }\n\n            for (i = 0; i < tgtState.parents.length; i += 1) {\n                targetIDs.push(tgtState.parents[i].getAttribute(\"id\"));\n            }\n\n            updateBackdrop(newLvl + 1, targetIDs);\n        }\n    }\n\n    function dismissOpenOffcanvas() {\n        if ($openTarget !== null) {\n            dismissOffcanvas($openTarget);\n        }\n    }\n\n    function enableDebounce() {\n        if (!isInDebounce) {\n            logger(\"Debounce timeout enabled\");\n            isInDebounce = true;\n            window.setTimeout(function () {\n                logger(\"Debounce timeout expired - event processing will resume\");\n                isInDebounce = false;\n            }, 100);\n        }\n    }\n\n    $(document).on(\"keydown\", function (evt) {\n        if (evt.keyCode === 27) {\n            dismissOpenOffcanvas();\n        } else if (evt.keyCode === 13) {\n            logger(\"Keydown event - ENTER. Disabling link clickthrough for the next click event.\");\n            click_keydown_inquiry = true; //mark that the following click event is\n                                        //from a keyboard\n        }\n    });\n\n    $(document).on(\"ready\", function (evt) {\n        var openIDs = [], openState, i;\n\n        if ($openTarget !== null) {\n            openState = $openTarget.data(\"offcanvas-state\");\n\n            for (i = 0; i < openState.parents.length; i += 1) {\n                openIDs.push(openState.parents[i].getAttribute(\"id\"));\n            }\n\n            updateBackdrop(currentLevel, openIDs);\n        }\n    });\n\n    function on_focusin(evt) {\n        var $tgt = $(evt.target), $tgtOffcanvas = null,\n            $tgtParents = $tgt.parents(), $toggleTarget,\n            dismissAllowed;\n\n        $tgtParents.each(function (index, elem) {\n            if ($tgtOffcanvas === null) {\n                if (isOffcanvas($(elem))) {\n                    $tgtOffcanvas = $(elem);\n                }\n            }\n        });\n\n        if (isInDebounce) {\n            logger(\"Processed event (debounced, type: focusin)\");\n            return;\n        }\n        \n        if ($tgt.data(\"toggle\") === \"offcanvas\") {\n            $toggleTarget = $($tgt.data(\"target\"));\n            if (!isTopLevelOffcanvas($toggleTarget)) {\n                if ($toggleTarget !== null) {\n                    logger(\"Marking non-top-level offcanvas nav \" + $toggleTarget.attr(\"id\") + \" as untabbable\");\n                }\n                setFocusableWithinLevel($toggleTarget, false);\n            }\n        }\n        \n        if (!eventCanDismissOffcanvas($openTarget, $tgtOffcanvas, evt, $tgt)) {\n            return;\n        }\n\n        if ($tgtOffcanvas === null && $openTarget !== null) {\n            logger(\"Focused on something outside of off-canvas nav \" + $openTarget.attr(\"id\"));\n            logger($tgt);\n\n            enableDebounce(); //prevent subsequent click event handlers from tripping\n\n            while ($openTarget !== null) {\n                dismissOpenOffcanvas();\n            }\n        } else {\n            if ($tgtOffcanvas !== null) {\n                logger(\"Focused inside off-canvas nav \" + $tgtOffcanvas.attr(\"id\"));\n            }\n\n            if ($openTarget !== null) {\n                enableDebounce(); //prevent subsequent click event handlers from tripping\n\n                while ($openTarget !== null && !isChildOffcanvas($tgtOffcanvas, $openTarget)) {\n                    logger(\"Dismissing off-canvas menu \" + $openTarget.attr(\"id\"));\n                    dismissOffcanvas($openTarget);\n                }\n            }\n            openOffcanvas($tgtOffcanvas, $tgt, evt.type);\n        }\n    }\n    \n    //Track a specific set of focus events to ensure they don't result in a\n    //click.\n    $(document).on(\"focusin\", function (evt) {\n        logger(evt.type);\n\n        focus_click_inquiry = true;\n\n        window.setTimeout(function () {\n            if (focus_click_inquiry) { //e.g. if a click event hasn't happened\n                on_focusin(evt);\n            }\n        }, 300);\n    });\n    \n    //Activate touch-specific behaviors if we have ever recieved a touch event.\n    $(document).on(\"touchstart touchend touchmove touchcancel\", function (evt) {\n        target_has_touch = true;\n    });\n    \n    /* Track the starting position of every touch we get. */\n    $(document).on(\"touchstart\", function (evt) {\n        var i, touch;\n        \n        for (i = 0; i < evt.originalEvent.changedTouches.length; i += 1) {\n            touch = evt.originalEvent.changedTouches.item(i);\n            eligibleTouches[touch.identifier] = {\n                \"x\": touch.screenX,\n                \"y\": touch.screenY\n            };\n        }\n    });\n    \n    /* Track and remove touches which have become drags.\n     * Assumes a minimum drag distance of 15px.\n     * Returns true if any of the given touches are still eligible.\n     */\n    function testAndPruneTouchList(changedTouches) {\n        var i, touch, stTouch, dist, MAX_DIST = 15, num_valid_touches = 0;\n        \n        for (i = 0; i < changedTouches.length; i += 1) {\n            touch = changedTouches.item(i);\n            \n            if (eligibleTouches.hasOwnProperty(touch.identifier)) {\n                stTouch = eligibleTouches[touch.identifier];\n                dist = Math.sqrt(Math.pow((touch.screenX - stTouch.x), 2.0)\n                               + Math.pow((touch.screenY - stTouch.y), 2.0));\n                \n                if (dist > MAX_DIST) {\n                    delete eligibleTouches[touch.identifier];\n                } else {\n                    num_valid_touches += 1;\n                }\n            }\n        }\n        \n        return num_valid_touches > 0;\n    }\n    \n    /* Remove touches that have become drags.\n     * This function assumes a minimum drag distance of 15px.\n     */\n    $(document).on(\"touchmove\", function (evt) {\n        testAndPruneTouchList(evt.originalEvent.changedTouches);\n    });\n    \n    /* Remove touches that have cancelled for hardware or OS specific reasons.\n     */\n    $(document).on(\"touchcancel\", function (evt) {\n        var i, touch;\n        \n        for (i = 0; i < evt.originalEvent.changedTouches.length; i += 1) {\n            touch = evt.originalEvent.changedTouches.item(i);\n            delete eligibleTouches[touch.identifier];\n        }\n    });\n    \n    /* Our main, extremely complicated event handler.\n     * We have to track a whole bunch of corner cases, since users expect the\n     * following out of their navigation structures:\n     * \n     *  1. Hovering over a toggle should open it\n     *  2. Touching a toggle with a finger should open it\n     *  3. Clicking on a toggle should navigate to it's link target, as it has\n     *     already opened from a hover\n     *  4. Tab-focusing content should cause offcanvas's open/close state to\n     *     follow through it\n     *  5. Touches should only be honored if they were not the end of a drag\n     */\n    $(document).on(\"click touchend mouseover\", function (evt) {\n        var i, sentinel = false,\n            $theToggle = $(evt.target),\n            $theTarget,\n            tgtStatus,\n            tgtState,\n            $btnParent = $theToggle.parents().filter(\"[data-toggle='offcanvas']\"),\n            skipToggle = false,\n            hoverMin = $(\"body\").data(\"offcanvas-hover-min\"),\n            toggleOptions,\n            hasEligibleTouches;\n\n        logger(evt.type);\n\n        focus_click_inquiry = false;\n\n        if (hoverMin === undefined) {\n            hoverMin = 0;\n        }\n\n        if (evt.type === \"mouseover\") {\n            if ($(window).width() < hoverMin) {\n                return;\n            }\n        }\n\n        if ($theToggle.data(\"toggle\") !== \"offcanvas\" && $btnParent.length > 0) { //Fixup hits on child text, graphical bits, etc\n            $theToggle = $btnParent;\n        }\n\n        if (($openTarget === null || $openTarget === undefined || $openTarget.length === 0) && $theToggle.data(\"toggle\") !== \"offcanvas\") {\n            return;\n        }\n\n        if (evt.type !== \"mouseover\" && isInDebounce) {\n            logger(\"Processed event (debounced)\");\n            evt.preventDefault();\n            return;\n        }\n        \n        //Check if any of our touches were actually drags so we can ignore em\n        if (evt.type === \"touchend\") {\n            hasEligibleTouches = testAndPruneTouchList(evt.originalEvent.changedTouches);\n            \n            if (!hasEligibleTouches) {\n                logger(\"Ignoring touch event as it is the result of a drag\");\n                return;\n            }\n        }\n\n        toggleOptions = $theToggle.data(\"toggle-options\");\n        if (toggleOptions !== undefined) {\n            toggleOptions = toggleOptions.split(\" \");\n        } else {\n            toggleOptions = [];\n        }\n\n        if (evt.type === \"mouseover\" && toggleOptions.indexOf(\"nohover\") > -1) {\n            logger(\"Not opening a no-hover toggle\");\n            return;\n        }\n        \n        //Used to allow using the <a>nchor portion of a dropdown toggle\n        //but only after it was opened using a mouse\n        if ($(window).width() >= hoverMin &&\n                $theToggle[0].tagName === \"A\" &&\n                evt.type === \"click\" &&\n                !target_has_touch &&\n                !click_keydown_inquiry && //and event is not generated by a keyboard\n                toggleOptions.indexOf(\"nohover\") === -1 &&\n                toggleOptions.indexOf(\"nohref\") === -1) {\n\n            logger(\"Allowing link to resolve instead of opening toggle\");\n            return;\n        }\n\n        click_keydown_inquiry = false; //clear the \"click event was generated by\n                                     //a keyboard event\" flag so the user can\n                                     //switch back to mouse input\n        \n        if ($openTarget !== null && $openTarget !== undefined && $openTarget.length > 0) {\n            //Determine if it's okay to do anything that might dismiss an offcanvas\n            //based on this event\n            tgtState = $openTarget.data(\"offcanvas-state\");\n            if (tgtState === undefined) {\n                //This step is needed if the offcanvas elements were deleted and\n                //recreated behind our back (e.g. because PageTransitions). In that\n                //case all we can do is drop the current $openTarget entirely.\n                $openTarget = undefined;\n            }\n        }\n        \n        if ($theToggle.data(\"toggle\") === \"offcanvas\") {\n            $theTarget = initOffcanvasToggle($theToggle);\n            findParentLevels($theTarget);\n        }\n\n        if (!eventCanDismissOffcanvas($openTarget, $theTarget, evt, $theToggle)) {\n            return;\n        }\n        \n        logger(\"Processed event\");\n        \n        if ($openTarget !== null &&\n                $openTarget !== undefined &&\n                $openTarget.length > 0 &&\n                !$.contains($openTarget[0], evt.target) &&\n                $openTarget[0] !== evt.target) {\n            \n            //Dismiss offcanvas by clicking outside it's area\n            if (\"#\" + $openTarget.attr(\"id\") === $theToggle.data(\"target\")) {\n                skipToggle = true;\n            }\n            \n            if ($theToggle.filter(\"[data-dismiss='offcanvas']\").length > 0) {\n                logger(\"Not overridding a click on an existing dismiss button just because the click handler happened to win a race condition\");\n            } else {\n                logger(tgtState.toggleOptions);\n                logger(toggleOptions);\n\n                enableDebounce();\n\n                if ($($theToggle.data(\"target\"))[0] === $openTarget[0]) {\n                    //If we have clicked on a toggle for the currently open offcanvas, eat the event\n                    evt.preventDefault();\n                    evt.stopPropagation();\n                    evt.stopImmediatePropagation();\n                }\n\n                dismissOffcanvas($openTarget);\n            }\n        }\n\n        if ($theTarget !== undefined && !skipToggle) { //Open offcanvas via a toggle link\n            enableDebounce();\n\n            tgtState = $theTarget.data(\"offcanvas-state\");\n\n            //Determine if a different offcanvas tree is active, and, if so, dismiss it first.\n            while ($openTarget !== null && $openTarget !== undefined) {\n                sentinel = $openTarget[0] === $theTarget[0];\n\n                for (i = 0; i < tgtState.parents.length; i += 1) {\n                    if ($openTarget[0] === tgtState.parents[i]) {\n                        sentinel = true;\n                        break;\n                    }\n                }\n\n                if (sentinel) {\n                    break;\n                }\n\n                dismissOffcanvas($openTarget);\n            }\n\n            if (tgtState.open) {\n                dismissOffcanvas($theTarget);\n            } else {\n                openOffcanvas($theTarget, $theToggle, evt.type);\n            }\n\n            if ($theToggle[0].tagName.toLowerCase() === \"a\" || $theToggle[0].tagName.toLowerCase() === \"button\") {\n                evt.preventDefault();\n            }\n        }\n    });\n    \n    /* Another, slightly less complex event handler for dismissing open content\n     */\n    $(document).on(\"click touchend\", function (evt) {\n        var $theToggle = $(evt.target), $theTarget, tgtStatus, tgtState, $btnParent = $theToggle.parents().filter(\"[data-dismiss='offcanvas']\"), skipToggle = false, i, sentinel = false, $toDismiss = $openTarget;\n\n        if ($theToggle.data(\"dismiss\") !== \"offcanvas\" && $btnParent.length > 0) { //Fixup hits on child text, graphical bits, etc\n            $theToggle = $btnParent;\n        }\n\n        if ($theToggle.data(\"dismiss\") !== \"offcanvas\") {\n            return;\n        }\n\n        if (isInDebounce) {\n            logger(\"Processed event (debounced)\");\n            evt.preventDefault();\n            return;\n        }\n\n        enableDebounce();\n\n        if ($theToggle.data(\"target\") !== undefined) {\n            $toDismiss = $($theToggle.data(\"target\"));\n        }\n\n        if ($toDismiss.length > 0) {\n            dismissOffcanvas($toDismiss);\n        }\n        \n        evt.preventDefault();\n    });\n\n    module.isOffcanvas = isOffcanvas;\n    module.isChildOffcanvas = isChildOffcanvas;\n    module.isTopLevelOffcanvas = isTopLevelOffcanvas;\n    module.initOffcanvas = initOffcanvas;\n    module.initOffcanvasToggle = initOffcanvasToggle;\n    module.dismissOpenOffcanvas = dismissOpenOffcanvas;\n    module.openOffcanvas = openOffcanvas;\n    module.dismissOffcanvas = dismissOffcanvas;\n    module.enableDebounce = enableDebounce;\n    module.switchLoggingMode = switchLoggingMode;\n\n    return module;\n}));\n","/*jQuery(document).ready(function ($) {\n    $(\".OpenPositionDetails-form\").on('click', '#submitForm', function (e) {\n        e.preventDefault();\n        var url = new URL(window.location.href);\n        var job_id = url.searchParams.get('id');\n        var urlHost = \"https://boards-api.greenhouse.io/v1/boards/1010data/jobs/\" + job_id;\n        var recaptcha = $(\"#g-recaptcha-response\").val();\n        var jsonObj = {};\n        //var recaptcha = $(\"#g-recaptcha-response\").val();\n        var valid = true;\n        $(\".OpenPositionDetails-form :input[required]:visible\").each(function () {\n            var input = $(this);\n            var err = input.next(\".form-error\");\n            if (input.attr('type') == 'text') {\n                if (input.val() == '') {\n                    valid = false;\n                    err.css('display', 'block');\n                    input.css('border-bottom', '1px solid #cc4b37');\n                } else {\n                    err.hide();\n                    input.css('border-bottom', '1px solid #ccc');\n                }\n                if (input.attr('name') == 'email' && input.val() != '') {\n                    if (!isEmail(input.val())) {\n                        valid = false;\n                        err.text(\"Please enter a valid email address.\");\n                        err.css('display', 'block');\n                        input.css('border-bottom', '1px solid #cc4b37');\n                    } else {\n                        err.hide();\n                        input.css('border-bottom', '1px solid #ccc');\n                    }\n                }\n            }\n            if (input.attr('type') == 'file') {\n                if (input.val() == '') {\n                    valid = false;\n                    err.css('display', 'block');\n                    input.css('border-bottom', '1px solid #cc4b37');\n                } else if (!(/\\.(pdf|doc|docx|txt|rtf)$/i).test(input.val())) {\n                    valid = false;\n                    err.text(\"Accepted files are pdf, doc, docx, txt and rtf.\")\n                    err.css('display', 'block');\n                    input.css('border-bottom', '1px solid #cc4b37');\n                } else {\n                    err.hide();\n                    input.css('border-bottom', '1px solid #ccc');\n                }\n            }\n            if (input.attr('type') == 'radio') {\n                if ($('input[name=' + input.attr(\"name\") + ']:checked').length <= 0) {\n                    valid = false;\n                    err.css('display', 'block');\n                } else {\n                    err.hide();\n                }\n            }\n            //  console.log(input.attr('name'));\n            // console.log(input.attr('type'));\n            // console.log(input.val());\n        });\n        var phone = $(\".OpenPositionDetails-form :input[name=phone]\");\n        var phoneErr = $(\".OpenPositionDetails-form :input[name=phone]\").next(\".form-error\");\n        if (phone.val() != '' && !phone_validate(phone.val())) {\n            phoneErr.text('Please enter a valid phone number.');\n            valid = false;\n            phoneErr.css('display', 'block');\n            phone.css('border-bottom', '1px solid #cc4b37');\n        } else {\n            phoneErr.hide();\n            phone.css('border-bottom', '1px solid #ccc');\n        }\n        var coverLetter = $(\".OpenPositionDetails-form :input[name=cover_letter]\");\n        var coverLetterErr = $(\".OpenPositionDetails-form :input[name=cover_letter]\").next(\".form-error\");\n        if (coverLetter.val() != '' && !(/\\.(pdf|doc|docx|txt|rtf)$/i).test(coverLetter.val())) {\n            coverLetterErr.text('Accepted files are pdf, doc, docx, txt and rtf.');\n            valid = false;\n            coverLetterErr.css('display', 'block');\n            coverLetter.css('border-bottom', '1px solid #cc4b37');\n        } else {\n            coverLetterErr.hide();\n            coverLetter.css('border-bottom', '1px solid #ccc');\n        }\n        if (recaptcha === \"\") {\n            valid = false;\n            $(\".recaptcha-error\").show();\n            $(\".rc-anchor-normal\").css('border', '2px solid #cc4b37');\n            return;\n        } else {\n            $(\".recaptcha-error\").hide();\n        }\n        // var form = $(this).not(\"#g-recaptcha-response, #captcha\").serialize(),\n        // \t\taction = $(this).attr('action');\n        if (valid == true) {\n            $('#g-recaptcha-response').attr('disabled', 'disabled');\n            $('#captcha').attr('disabled', 'disabled');\n            $(\".recaptcha-error\").hide();\n            $(\"#submitForm\").attr(\"disabled\", \"disabled\");\n            $(\"#submitForm\").attr(\"style\", \"background-color:#ccc !important\");\n            $(\".OpenPositionDetails-form :input\").each(function () {\n                var input = $(this);\n                if (input.attr('name') == 'first_name' || input.attr('name') == 'last_name' || input.attr('name') == 'email') {\n                    jsonObj[input.attr('name')] = input.val();\n                }\n                /* if(input.attr('type') == 'radio'){\n                     jsonObj[input.attr('name')] = $('input[name='+input.attr(\"name\")+']:checked').val();\n                 }else{\n                     jsonObj[input.attr('name')] = input.val();\n                 }*/\n      /*      });\n            console.log(urlHost);\n            console.log(jsonObj);\n\n            //jsonObj['action'] = 'open_positions_ajax_call';\n            $.ajax({\n                type: \"POST\",\n                url: my_ajax_object.ajaxurl,\n                data: {action: \"open_positions_ajax_call\"},\n                success: function(data) {\n                    console.log(data);\n                    var message = $(\".OpenPositionDetails-form .message\");\n                    message.css('display', 'block');\n                },\n                error: function(error) {\n                    console.log(error);\n                    var message = $(\".OpenPositionDetails-form .message\");\n                    message.text('There was an error with you submission');\n                    message.css('display', 'block');\n                }\n            });\n            /*      $.post(my_ajax_object.ajaxurl, JSON.stringify(jsonObj), function(response) {\n                      var message = $(\".OpenPositionDetails-form .message\");\n                      $(\".OpenPositionDetails-form .message\").text(response);\n                      message.css('display', 'block');\n                  });\n                  //return false;\n\n                  /*\n                  $.ajax({\n                      method: \"POST\",\n                      url: urlHost,\n                      crossDomain: true,\n                      data: JSON.stringify(jsonObj),\n                      contentType: \"application/json\",\n                      dataType: \"json\",\n                      headers: {\"Authorization\": \"Basic 62a32faac59b9475d0124ffe62935f7c-1\"},\n                      success: function(data) {\n                          console.log(data);\n                          var message = $(\".OpenPositionDetails-form .message\");\n                          message.css('display', 'block');\n                      },\n                      error: function() {\n                          var message = $(\".OpenPositionDetails-form .message\");\n                          message.text('There was an error with you submission');\n                          message.css('display', 'block');\n                      }\n                  });*/\n /*       } else {\n            return;\n        }\n    });\n\n    function phone_validate(phno) {\n        var regexPattern = new RegExp(/^\\d{7,}$/);    // regular expression pattern\n        return regexPattern.test(phno);\n    }\n\n    function isEmail(email) {\n        var regex = /^([a-zA-Z0-9_.+-])+\\@(([a-zA-Z0-9-])+\\.)+([a-zA-Z0-9]{2,4})+$/;\n        return regex.test(email);\n    }\n});","/*global define, console, document, window, Promise*/\n(function (root, factory) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(\"PageTransition\", [\"jquery\", \"Behaviors\", \"Animations\"], factory);\n    } else {\n        root.PageTransition = factory(root.jQuery, root.Behaviors, root.Animations);\n    }\n}(this, function ($, Behaviors, Animations) {\n    \"use strict\";\n\n    var module = {};\n\n    function $do(that, target) {\n        return function () {\n            target.apply(that, arguments);\n        };\n    }\n\n    /* A page transition region is an element on the page with a unique ID that\n     * is the same from page load to page load. It is a good idea for there to\n     * be only one page transition region covering as much is it can on the\n     * page.\n     *\n     * An ID is mandatory for page transition regions.\n     */\n    function PageTransitionRegion(elem) {\n        Behaviors.init(PageTransitionRegion, this, arguments);\n\n        this.id = this.$elem.attr(\"id\");\n\n        this.$elem.on(\"click\", this.navigation_intent.bind(this));\n\n        this.claim_current_state();\n        $(window).on(\"popstate\", this.pop_state_intent.bind(this));\n    }\n\n    Behaviors.inherit(PageTransitionRegion, Behaviors.Behavior);\n\n    PageTransitionRegion.QUERY = \"[data-pagetransition-region]\";\n    \n    /* Determine if we can transition to a new page or not.\n     * \n     * This does not actually replace the content. Thus, you can make the check\n     * without committing to the new page.\n     */\n    PageTransitionRegion.prototype.can_replace = function ($new_document) {\n        var $other_region = $new_document.find(\"#\" + this.id);\n        if ($other_region.length === 0) {\n            $other_region = $new_document.filter(\"#\" + this.id);\n        }\n        \n        if ($other_region.length === 0) {\n            return false;\n        }\n        \n        return true;\n    };\n    \n    /* Prepare to replace the old content with the new one.\n     */\n    PageTransitionRegion.prototype.prepare_to_replace = function ($old_document) {\n        Behaviors.content_removal($old_document.children().filter(\":not([data-pagetransition-backdrop])\"));\n    };\n\n    /* Replace current content with content pulled from a new page we're trying\n     * to transition into.\n     *\n     * Returns false if we could not extract content from the new document.\n     * In this case, calling method should perform a traditional navigation to\n     * the new document.\n     */\n    PageTransitionRegion.prototype.replace = function ($new_document) {\n        var $other_region = $new_document.find(\"#\" + this.id), $children;\n        if ($other_region.length === 0) {\n            $other_region = $new_document.filter(\"#\" + this.id);\n        }\n\n        if ($other_region.length === 0) {\n            return false;\n        }\n        \n        $children = $other_region.children().filter(\":not([data-pagetransition-backdrop])\");\n\n        this.$elem.children().filter(\":not([data-pagetransition-backdrop])\").remove();\n        this.$elem.append($children);\n        $(window).scrollTop(0);\n        \n        Behaviors.content_ready($children.parent());\n\n        return true;\n    };\n\n    /* Replace the backdrop element.\n     *\n     * This is replaced separately so that each page can specify it's own outro\n     * backdrop without interrupting the incoming animation.\n     *\n     * This should only be called after the promise returned by transition_in\n     * resolves.\n     *\n     * Returns false if we could not extract content from the new document.\n     * In this case, calling method should perform a traditional navigation to\n     * the new document.\n     */\n    PageTransitionRegion.prototype.replace_backdrop = function ($new_document) {\n        var $other_region = $new_document.find(\"#\" + this.id);\n        if ($other_region.length === 0) {\n            $other_region = $new_document.filter(\"#\" + this.id);\n        }\n\n        if ($other_region.length === 0) {\n            return false;\n        }\n\n        this.$elem.attr(\"class\", $other_region.attr(\"class\"));\n        this.$elem.children().filter(\"[data-pagetransition-backdrop]\").remove();\n        this.$elem.append($other_region.children().filter(\"[data-pagetransition-backdrop]\"));\n\n        return true;\n    };\n\n    /* Change the browser URL to point to the new URL, and also fix relative\n     * links such that they resolve correctly.\n     *\n     * The transition property in the pushState data indicates that this entry\n     * was placed here by the PageTransitionRegion class. This lets us avoid\n     * applying transitions to things that shouldn't get them.\n     */\n    PageTransitionRegion.prototype.replace_state = function (url) {\n        window.history.pushState({transition: true, url: url}, \"\", url);\n        this.claim_current_state();\n    };\n    \n    /* Changes the document head to match what is present in the new document.\n     * \n     * Currently, only title replacement is supported, but this function may\n     * also be extended to \n     */\n    PageTransitionRegion.prototype.replace_head = function ($new_document) {\n        var $new_title = $new_document.filter(\"title\"),\n            $title = $(\"title\");\n        \n        if ($new_title.length === 0) {\n            $new_title = $new_document.find(\"title\");\n        }\n        \n        $title.text($new_title.text());\n    };\n    \n    /* Retrigger analytics scripts if so marked.\n     */\n    PageTransitionRegion.prototype.replace_analytics = function () {\n        var $reloadable_tags;\n        \n        //Step 1: Find tags marked for reloading.\n        $reloadable_tags = $(this.constructor.RELOADABLE_SCRIPT_QUERY);\n        \n        //Step 2: Reinsert them, hopefully causing them to be included again.\n        //We need to try this two separate ways based on if it's an inline\n        //script or external.\n        $reloadable_tags.detach();\n        \n        $reloadable_tags.each(function (index, elem) {\n            var $elem = $(elem), src = $elem.attr(\"src\");\n            \n            if (src !== undefined) {\n                //External script, recreate the tag\n                $elem.remove();\n                $elem = $(\"<script></script>\");\n                $elem.attr(\"src\", src);\n            }\n            \n            $(\"body\").append($elem);\n        });\n    };\n    \n    /* Indicates an analytics tag that can be retriggered for the new page load\n     * by just reloading it's tag.\n     */\n    PageTransitionRegion.RELOADABLE_SCRIPT_QUERY = \"[data-pagetransition-analytics='reloadable']\";\n\n    /* Claim the current history state for ourselves.\n     *\n     * By default, this is only called at the start of the page load.\n     */\n    PageTransitionRegion.prototype.claim_current_state = function () {\n        var url = window.location.href;\n        window.history.replaceState({transition: true, url: url}, \"\", url);\n    };\n\n    /* Determine if link is internal or external.\n     *\n     * The purpose of distinguishing between internal and external links is to\n     * check if we can transition to them properly or not. We can only\n     * transition into pages with compatible regions; so we assume that all\n     * internal links will use the same compatible theming.\n     *\n     * Also, transitioning to an external page requires specially configured\n     * web servers that allow CORS, which is a pain.\n     *\n     * Returns LINK_INTERNAL, LINK_EXTERNAL, LINK_POPUP, or LINK_HASH.\n     */\n    PageTransitionRegion.prototype.is_internal_link = function (url, $a) {\n        var extRegex = new RegExp(\"(\\/\\/|:)\"),\n            hashRegex = new RegExp(\"^#\"),\n            domainRelativeHashRegex = new RegExp(\"^\" + window.location.pathname + \"/#\"),\n            protRelativeRegex = new RegExp(\"^//\" + window.location.host),\n            protAbsoluteRegex = new RegExp('^' + window.location.protocol + \"//\" + window.location.host),\n            protRelativeHashRegex = new RegExp('^//' + window.location.host + window.location.pathname + \"#\"),\n            absoluteHashRegex = new RegExp('^' + window.location.protocol + \"//\" + window.location.host + window.location.pathname + \"#\");\n\n        if ($a.attr(\"target\") !== undefined && $a.attr(\"target\") !== \"\") {\n            return PageTransitionRegion.LINK_POPUP;\n        }\n        \n        if (hashRegex.test(url) || absoluteHashRegex.test(url) || protRelativeHashRegex.test(url) || domainRelativeHashRegex.test(url)) {\n            return PageTransitionRegion.LINK_HASH;\n        } else if (!extRegex.test(url) || protRelativeRegex.test(url) || protAbsoluteRegex.test(url)) {\n            return PageTransitionRegion.LINK_INTERNAL;\n        } else {\n            return PageTransitionRegion.LINK_EXTERNAL;\n        }\n    };\n\n    /* Transition out the current page.\n     *\n     * Returns a promise which resolves when the transition has completed.\n     *\n     * This default implementation uses a CSS class and waits for transitionEnd\n     * events.\n     */\n    PageTransitionRegion.prototype.transition_out = function () {\n        var aw;\n\n        this.$elem.removeClass(\"is-PageTransition--transition_loading\");\n        this.$elem.addClass(\"is-PageTransition--transition_out\");\n        this.$elem.removeClass(\"is-PageTransition--transition_in\");\n        aw = new Animations.AnimationWatcher(this.$elem.find(\"[data-pagetransition-backdrop]\"));\n\n        return aw.promise;\n    };\n\n    /* Transition to a loading animation.\n     *\n     * Returns a promise which resolves when the transition has completed.\n     *\n     * This default implementation uses a CSS class and waits for transitionEnd\n     * events.\n     */\n    PageTransitionRegion.prototype.transition_loading = function () {\n        var aw;\n\n        this.$elem.addClass(\"is-PageTransition--transition_loading\");\n        this.$elem.removeClass(\"is-PageTransition--transition_out\");\n        this.$elem.removeClass(\"is-PageTransition--transition_in\");\n        aw = new Animations.AnimationWatcher(this.$elem.find(\"[data-pagetransition-backdrop]\"));\n\n        return aw.promise;\n    };\n\n    /* Transition in the current page.\n     *\n     * Returns a promise which resolves when the transition has completed.\n     *\n     * This default implementation uses a CSS class and waits for transitionEnd\n     * events.\n     */\n    PageTransitionRegion.prototype.transition_in = function () {\n        var aw;\n\n        this.$elem.removeClass(\"is-PageTransition--transition_loading\");\n        this.$elem.removeClass(\"is-PageTransition--transition_out\");\n        this.$elem.addClass(\"is-PageTransition--transition_in\");\n        aw = new Animations.AnimationWatcher(this.$elem.find(\"[data-pagetransition-backdrop]\"));\n\n        return aw.promise;\n    };\n\n    /* Transition to the \"done\" state, which should just have the site be\n     * plainly visible.\n     *\n     * Returns a promise which resolves any final transitions have completed.\n     * However, most transition effects should not be starting animations here,\n     * so it may never resolve.\n     *\n     * This default implementation removes all CSS classes and waits for\n     * transitionEnd events.\n     */\n    PageTransitionRegion.prototype.transition_done = function () {\n        var aw;\n\n        this.$elem.removeClass(\"is-PageTransition--transition_loading\");\n        this.$elem.removeClass(\"is-PageTransition--transition_out\");\n        this.$elem.removeClass(\"is-PageTransition--transition_in\");\n        aw = new Animations.AnimationWatcher(this.$elem.find(\"[data-pagetransition-backdrop]\"));\n\n        return aw.promise;\n    };\n\n    /* Given a URL, actually transition the page to a new page.\n     *\n     * The default method of transitioning the page is to:\n     *\n     *   1. AJAX the new page in\n     *   2. Transition out the current page\n     *   3. Call .replace() to get the new page's content in here.\n     *   4. Transition in the new page\n     *\n     * Subclasses of PageTransitionRegion may implement more complicated\n     * behavior based on their own individual requirements. Generally, however,\n     * you will want to call .replace() to get the content in.\n     *\n     * If the replacement fails, we will attempt traditional navigation instead\n     * of silently or catastrophically failing.\n     */\n    PageTransitionRegion.prototype.retrieve_document_by_url = function (url, isPopState) {\n        var ajaxPromise = new Promise(function (resolve, reject) {\n            $.get(url, undefined, resolve, \"html\");\n        }),\n            theData;\n\n        return this.transition_out().then(function () {\n            console.log(\"Out transition finished\");\n            this.transition_loading();\n            return ajaxPromise;\n        }.bind(this)).then(function (data) {\n            this.prepare_to_replace(this.$elem);\n            return new Promise(function (resolve, reject) {\n                window.setTimeout(resolve.bind(this, data), 1);\n            });\n        }.bind(this)).then(function (data) {\n            var couldReplace;\n\n            console.log(\"Load finished\");\n            theData = data;\n\n            couldReplace = this.can_replace($(theData));\n            if (!couldReplace) {\n                window.location.href = url;\n                throw new Error(\"Location \" + url + \" does not have transitionable links!\");\n            } else if (isPopState !== true) {\n                this.replace_state(url);\n            }\n            \n            this.replace($(theData));\n            this.replace_head($(theData));\n            this.replace_analytics($(theData));\n            \n            return this.transition_in();\n        }.bind(this)).then(function () {\n            console.log(\"In transition finished\");\n            this.replace_backdrop($(theData));\n            this.transition_done();\n        }.bind(this));\n    };\n\n    /* Link which resolves to the same origin server. */\n    PageTransitionRegion.LINK_INTERNAL = 0;\n\n    /* Link which resolves to a different origin server. */\n    PageTransitionRegion.LINK_EXTERNAL = 1;\n\n    /* Link which resolves in another window */\n    PageTransitionRegion.LINK_POPUP = 2;\n\n    /* Link which resolves to the same page.\n     * Also covers links which do JavaScripty things and should be buttons, but\n     * aren't because some developers think their pages will always load with\n     * the correct JS and don't consider fallback cases\n     */\n    PageTransitionRegion.LINK_HASH = 3;\n\n    /* Event handler for when a link within the region is clicked.\n     */\n    PageTransitionRegion.prototype.navigation_intent = function (evt) {\n        var $target = $(evt.target), $parent_tgt = $target.parents().filter(\"a\"),\n            href;\n\n        if ($target.filter(\"a\").length === 0) {\n            $target = $parent_tgt;\n        }\n\n        if ($target.filter(\"a\").length === 0) {\n            //Not a link.\n            return;\n        }\n\n        href = $target.attr(\"href\");\n\n        if (this.is_internal_link(href, $target) === PageTransitionRegion.LINK_INTERNAL) {\n            //It's AJAX time!\n            evt.preventDefault();\n            this.retrieve_document_by_url(href);\n        }\n    };\n\n    /* Event handler for when the user presses the back button. */\n    PageTransitionRegion.prototype.pop_state_intent = function (evt) {\n        if (evt.originalEvent.state !== undefined &&\n                evt.originalEvent.state !== null &&\n                evt.originalEvent.state.transition === true) {\n            evt.preventDefault();\n            this.retrieve_document_by_url(evt.originalEvent.state.url, true);\n        }\n    };\n\n    Behaviors.register_behavior(PageTransitionRegion);\n\n    module.PageTransitionRegion = PageTransitionRegion;\n\n    return module;\n}));\n","/*global window, define, Promise*/\n\n(function (root, factory) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(\"ScrollEffects\", [\"jquery\", \"Behaviors\", \"AtlasPlayer\", \"Animations\"], factory);\n    } else {\n        root.ScrollEffects = factory(root.jQuery, root.Behaviors, root.AtlasPlayer, root.Animations);\n    }\n}(this, function ($, Behaviors, AtlasPlayer, Animations) {\n    \"use strict\";\n\n    var module = {};\n\n    function ScrollEffects(elem) {\n        Behaviors.init(ScrollEffects, this, arguments);\n\n        this.$elem = $(elem);\n        this.$scrollCtxt = $(window); //TODO: Allow CSS overflow scrolling\n        \n        this.scrollHandler = this.on_scroll_intent.bind(this);\n\n        this.$scrollCtxt.on(\"scroll\", this.scrollHandler);\n        \n        this.has_load_animation = $(elem).data(\"scrolleffects-loadanimation\") !== undefined;\n    }\n\n    Behaviors.inherit(ScrollEffects, Behaviors.Behavior);\n\n    ScrollEffects.QUERY = \"[data-scrolleffects]\";\n    ScrollEffects.THROTTLE_TIMEOUT = 200;\n    \n    /* Deinitialize our scroll handler if needed.\n     */\n    ScrollEffects.prototype.deinitialize = function () {\n        this.$scrollCtxt.off(\"scroll\", this.scrollHandler);\n    };\n    \n    /* Return a list of all available scroll effect modes on this bit.\n     */\n    ScrollEffects.prototype.activation_modes = function () {\n        return this.$elem.data(\"scrolleffects\").split(\" \");\n    };\n\n    ScrollEffects.prototype.update_css_classes = function () {\n        var activation_modes = this.activation_modes(),\n            active = false;\n\n        if (this.isTopVisible && activation_modes.indexOf(\"top_visible\") !== -1) {\n            active = true;\n        }\n\n        if (this.isBottomVisible && activation_modes.indexOf(\"bottom_visible\") !== -1) {\n            active = true;\n        }\n\n        if (this.isVisible && activation_modes.indexOf(\"visible\") !== -1) {\n            active = true;\n        }\n\n        if (this.onceTopVisible && activation_modes.indexOf(\"top_visible_once\") !== -1) {\n            active = true;\n        }\n\n        if (this.onceBottomVisible && activation_modes.indexOf(\"bottom_visible_once\") !== -1) {\n            active = true;\n        }\n\n        if (this.onceVisible && activation_modes.indexOf(\"visible_once\") !== -1) {\n            active = true;\n        }\n\n        if (active) {\n            this.$elem.addClass(\"is-ScrollEffects--active\");\n            this.$elem.removeClass(\"is-ScrollEffects--inactive\");\n        } else {\n            this.$elem.removeClass(\"is-ScrollEffects--active\");\n            this.$elem.addClass(\"is-ScrollEffects--inactive\");\n        }\n        \n        if (this.loaded) {\n            this.$elem.removeClass(\"is-ScrollEffects--unloaded\");\n            this.$elem.addClass(\"is-ScrollEffects--loaded\");\n        } else {\n            this.$elem.addClass(\"is-ScrollEffects--unloaded\");\n            this.$elem.removeClass(\"is-ScrollEffects--loaded\");\n        }\n    };\n\n    ScrollEffects.prototype.on_scroll_intent = function () {\n        var top = this.$elem.offset().top,\n            height = this.$elem.height(),\n            bottom = top + height,\n            contextOffset = this.$scrollCtxt.offset(),\n            contextScrollTop = contextOffset !== undefined\n                                ? contextOffset.top + this.$scrollCtxt.scrollTop()\n                                : this.$scrollCtxt.scrollTop(),\n            contextHeight = this.$scrollCtxt.height(),\n            contextScrollBottom = contextScrollTop + contextHeight;\n\n        this.isTopVisible = contextScrollTop <= top && top <= contextScrollBottom;\n        this.isBottomVisible = contextScrollTop <= bottom && bottom <= contextScrollBottom;\n        this.isVisible = this.isTopVisible || this.isBottomVisible\n            || (top <= contextScrollTop && contextScrollTop <= bottom)\n            || (top <= contextScrollBottom && contextScrollBottom <= bottom);\n\n        this.onceTopVisible = this.onceTopVisible || this.isTopVisible;\n        this.onceBottomVisible = this.onceBottomVisible || this.isBottomVisible;\n        this.onceVisible = this.onceVisible || this.isVisible;\n\n        this.top = top;\n        this.bottom = bottom;\n        this.contextScrollTop = contextScrollTop;\n        this.contextScrollBottom = contextScrollBottom;\n\n        this.update_css_classes();\n    };\n\n    Behaviors.register_behavior(ScrollEffects);\n\n    function ScrollAlax() {\n        Behaviors.init(ScrollAlax, this, arguments);\n\n        this.$layers = this.$elem.find(\"li\");\n        this.$atlasplayers = this.$elem.find(AtlasPlayer.AtlasPlayer.QUERY);\n        this.atlasplayers = AtlasPlayer.AtlasPlayer.find_markup(this.$atlasplayers);\n        \n        this.depth = this.$elem.height() * -0.5;\n\n        if (this.$elem.data('scrollalax-depthrange') === 'outside') {\n            this.anim_scale = 1;\n        } else {\n            this.anim_scale = -1;\n        }\n\n        this.weights = this.weight_layers(this.$layers);\n\n        this.on_scroll_intent();\n        \n        this.loaded = false;\n        this.minimum_load_time = this.$elem.data(\"scrollalax-loadmin\");\n        this.load().then(this.on_loaded.bind(this));\n        \n        this.load_animation_playing = this.has_load_animation;\n        \n        if (this.has_load_animation) {\n            this.load_animation_watcher = new Animations.AnimationWatcher(this.$elem);\n            this.load_animation_watcher.promise.then(this.on_load_animation_complete.bind(this));\n        } else {\n            this.on_load_animation_complete();\n        }\n    }\n\n    Behaviors.inherit(ScrollAlax, ScrollEffects);\n\n    ScrollAlax.QUERY = \"[data-scrollalax]\";\n\n    /* Determine the weights of each layer on the parallax group. */\n    ScrollAlax.prototype.weight_layers = function ($layers) {\n        var min = Infinity, max = -Infinity, w = [];\n\n        $layers.each(function (index, elem) {\n            var depth = $(elem).data(\"scrollalax-depth\");\n\n            if (min > depth) {\n                min = depth;\n            }\n\n            if (max < depth) {\n                max = depth;\n            }\n        }.bind(this));\n\n        $layers.each(function (index, elem) {\n            var depth = $(elem).data(\"scrollalax-depth\");\n\n            if (this.anim_scale === -1) {\n                w.push(-1 + (depth - min) / (max - min));\n            } else {\n                w.push((depth - min) / (max - min));\n            }\n        }.bind(this));\n\n        return w;\n    };\n\n    /* Calculate X or Y positions of a layer. */\n    ScrollAlax.prototype.apply_transform_css = function (style, index, xPct, yPct) {\n        var pct_Xdrag = this.weights[index] * xPct * this.anim_scale,\n            pct_Ydrag = this.weights[index] * yPct * this.anim_scale,\n            xDisp = this.depth * pct_Xdrag * this.anim_scale,\n            yDisp = this.depth * pct_Ydrag * this.anim_scale;\n\n        //style.left = xDisp + \"px\";\n        //style.top = yDisp + \"px\";\n\n        style.transform = \"translate3D(\" + xDisp + \"px, \" + yDisp + \"px, 0px)\";\n    };\n\n    /* Update the scroll animation. */\n    ScrollAlax.prototype.update_css_classes = function (evt) {\n        var pct_down = Math.max(Math.min((this.contextScrollTop - this.top) / this.$elem.height(), 1.0), 0.0);\n        \n        this.$layers.each(function (index, layer_elem) {\n            var $layer_elem = $(layer_elem);\n\n            this.apply_transform_css(layer_elem.style, index, 0, pct_down);\n        }.bind(this));\n        \n        if (this.loaded && !this.load_animation_playing) {\n            this.$elem.removeClass(\"is-ScrollEffects--unloaded\");\n            this.$elem.addClass(\"is-ScrollEffects--loaded\");\n        } else {\n            this.$elem.addClass(\"is-ScrollEffects--unloaded\");\n            this.$elem.removeClass(\"is-ScrollEffects--loaded\");\n        }\n    };\n    \n    /**\n     * Ensure all layers have their images loaded.\n     * \n     * Returns a promise that resolves when all images in all layers have\n     * loaded.\n     */\n    ScrollAlax.prototype.load = function () {\n        var promises = [];\n        \n        if (this.minimum_load_time > 0) {\n            promises.push(new Promise (function (resolve) {\n                window.setTimeout(resolve, this.minimum_load_time * 1000);\n            }.bind(this)));\n        }\n        \n        this.$layers.each(function (index, layer_elem) {\n            var $backgrounds = $(layer_elem).find(\"[style*='background-image']\"),\n                $images = $(layer_elem).find(\"img[src]\");\n            \n            $backgrounds.each(function (index, bgelem) {\n                var src = $(bgelem).css(\"background-image\").slice(5, -2);\n                \n                promises.push(new Promise(function (resolve) {\n                    $(\"<img/>\").attr(\"src\", src).on('load', function () {\n                        $(this).remove();\n                        resolve();\n                    }).on('error', function () {\n                        //This should be reject, but some browsers will\n                        //spuriously fire error if the image was cached instead\n                        //of firing load. This is a workaround.\n                        $(this).remove();\n                        resolve();\n                    });\n                }.bind(this)));\n            }.bind(this));\n            \n            $images.each(function (index, imgelem) {\n                var src = $(imgelem).attr(\"src\");\n                \n                promises.push(new Promise(function (resolve) {\n                    $(\"<img/>\").attr(\"src\", src).on('load', function () {\n                        $(this).remove();\n                        resolve();\n                    }).on('error', function () {\n                        //This should be reject, but some browsers will\n                        //spuriously fire error if the image was cached instead\n                        //of firing load. This is a workaround.\n                        $(this).remove();\n                        resolve();\n                    });\n                }.bind(this)));\n            }.bind(this));\n        });\n        \n        return Promise.all(promises);\n    };\n    \n    ScrollAlax.prototype.on_loaded = function () {\n        var i = 0;\n\n        for (i = 0; i < this.atlasplayers.length; i += 1) {\n            this.atlasplayers[i].seek(0);\n            this.atlasplayers[i].stop();\n        }\n        \n        this.loaded = true;\n        this.update_css_classes();\n        \n        if (!this.load_animation_playing) {\n            if (this.has_load_animation) {\n                this.unload_animation_watcher = new Animations.AnimationWatcher(this.$elem);\n                this.unload_animation_watcher.promise.then(this.on_unload_animation_complete.bind(this));\n            } else {\n                this.on_unload_animation_complete();\n            }\n        }\n    };\n    \n    ScrollAlax.prototype.on_load_animation_complete = function () {\n        this.load_animation_playing = false;\n        this.update_css_classes();\n        \n        if (this.loaded) {\n            if (this.has_load_animation) {\n                this.unload_animation_watcher = new Animations.AnimationWatcher(this.$elem);\n                this.unload_animation_watcher.promise.then(this.on_unload_animation_complete.bind(this));\n            } else {\n                this.on_unload_animation_complete();\n            }\n        }\n    };\n    \n    ScrollAlax.prototype.on_unload_animation_complete = function () {\n        var i = 0;\n\n        for (i = 0; i < this.atlasplayers.length; i += 1) {\n            this.atlasplayers[i].seek(0);\n            this.atlasplayers[i].play();\n        }\n    };\n\n    Behaviors.register_behavior(ScrollAlax);\n\n    module.ScrollEffects = ScrollEffects;\n    module.ScrollAlax = ScrollAlax;\n\n    return module;\n}));\n","(function (root, factory) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(\"accountslidein\", [\"jquery\", \"betteroffcanvas\"], factory);\n    } else {\n        // Browser globals\n        root.accountslidein = factory(root.jQuery, root.betteroffcanvas);\n    }\n}(this, function ($, betteroffcanvas) {\n    \"use strict\";\n    \"feel good\";\n\n    $('.Account_slide-login--button').click(function(){\n        $(this).hide();\n        $('.Account_slide-form--password').removeClass('Account_slide-form--visible')\n        $('.Account_slide-form--login').addClass('Account_slide-form--visible');\n        return false;\n    });\n\n    $('.Account_slide-password_recovery').click(function(){\n        $('.Account_slide-login--button').show();\n        $('.Account_slide-form--login').removeClass('Account_slide-form--visible');\n        $('.Account_slide-form--password').addClass('Account_slide-form--visible');\n        return false;\n    });\n\n\n    $('.Account_slide-close').click(function(){\n        betteroffcanvas.dismissOffcanvas($('#SiteHeader-accounts'));\n    });\n}));\n","(function (root, factory) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(\"siteheader\", [\"jquery\", \"betteroffcanvas\"], factory);\n    } else {\n        // Browser globals\n        root.siteheader = factory(root.jQuery, root.betteroffcanvas);\n    }\n}(this, function ($, betteroffcanvas, ajaxCart, Handlebars) {\n    \"use strict\";\n    \"feel good\";\n\n    function update_scroll() {\n        var scrollTop = $(window).scrollTop(),\n            $SiteHeader = $(\"[data-siteheader='siteheader']\");\n\n        if (scrollTop === 0) {\n            $SiteHeader.addClass(\"is-SiteHeader--at_top\");\n            $SiteHeader.removeClass(\"is-SiteHeader--scrolled\");\n        } else {\n            $SiteHeader.removeClass(\"is-SiteHeader--at_top\");\n            $SiteHeader.addClass(\"is-SiteHeader--scrolled\");\n        }\n    };\n\n    $(window).on(\"scroll\", update_scroll);\n\n    update_scroll();\n}));\n","(function (root, factory) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(\"StaffGrid\", [\"jquery\", \"Behaviors\"], factory);\n    } else {\n        root.StaffGrid = factory(root.jQuery, root.Behaviors);\n    }\n}(this, function ($, Behaviors) {\n    \"use strict\";\n\n    var module = {};\n    \n    function StaffGridSlider() {\n        Behaviors.init(StaffGridSlider, this, arguments);\n        \n        this.$elem.slick({\n            prevArrow: this.$elem.find('[data-staffgrid-prev]'),\n            nextArrow: this.$elem.find('[data-staffgrid-next]')\n        });\n    }\n    \n    Behaviors.inherit(StaffGridSlider, Behaviors.Behavior);\n    \n    StaffGridSlider.QUERY = \"[data-staffgrid-slider]\";\n    \n    StaffGridSlider.prototype.goto = function (id, animate) {\n        this.$elem.slick('slickGoTo', id, animate);\n    }\n    \n    function StaffGridModal() {\n        Behaviors.init(StaffGridModal, this, arguments);\n        \n        this.slider = StaffGridSlider.locate(this.$elem.find('[data-staffgrid-slider]'));\n        this.$elem.on(\"offcanvas-open\", this.modal_reveal_intent.bind(this));\n    }\n    \n    Behaviors.inherit(StaffGridModal, Behaviors.Behavior);\n    \n    StaffGridModal.QUERY = \"[data-staffgrid-modal]\";\n    \n    StaffGridModal.prototype.modal_reveal_intent = function (evt) {\n        var slideIndex = $(evt.originalEvent.toggle).data('staffgrid-slider-index');\n        \n        this.slider.goto(slideIndex, true);\n    };\n    \n    Behaviors.register_behavior(StaffGridModal);\n    Behaviors.register_behavior(StaffGridSlider);\n    \n    module.StaffGridModal = StaffGridModal;\n    module.StaffGridSlider = StaffGridSlider;\n    \n    return module;\n}));\n","/*global define, console, document, window*/\n(function (root, factory) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(\"TabbedContent\", [\"jquery\", \"Behaviors\"], factory);\n    } else {\n        root.TabbedContent = factory(root.jQuery, root.Behaviors);\n    }\n}(this, function ($, Behaviors) {\n    \"use strict\";\n\n    var module = {};\n\n    function $do(that, target) {\n        return function () {\n            target.apply(that, arguments);\n        };\n    }\n\n    function TabbedContentRegion(elem) {\n        Behaviors.init(TabbedContentRegion, this, arguments);\n\n        this.$elem = $(elem);\n        this.id = this.$elem.attr(\"id\");\n        this.active = this.$elem.data(\"tabbedcontent-region-active\") !== undefined;\n\n        this.links = [];\n\n        this.reflect_status();\n    }\n\n    Behaviors.inherit(TabbedContentRegion, Behaviors.Behavior);\n\n    TabbedContentRegion.QUERY = \"[data-tabbedcontent-region]\";\n\n    TabbedContentRegion.prototype.reflect_status = function (status) {\n        var i;\n\n        if (status === undefined) {\n            status = this.active;\n        }\n\n        if (status) {\n            this.$elem.addClass(\"is-TabbedContent--active\");\n            this.$elem.removeClass(\"is-TabbedContent--inactive\");\n        } else {\n            this.$elem.removeClass(\"is-TabbedContent--active\");\n            this.$elem.addClass(\"is-TabbedContent--inactive\");\n        }\n\n        for (i = 0; i < this.links.length; i += 1) {\n            if (status) {\n                this.links[i].addClass(\"is-TabbedContent--target_active\");\n                this.links[i].removeClass(\"is-TabbedContent--target_inactive\");\n            } else {\n                this.links[i].removeClass(\"is-TabbedContent--target_active\");\n                this.links[i].addClass(\"is-TabbedContent--target_inactive\");\n            }\n        }\n    };\n\n    TabbedContentRegion.prototype.add_incoming_link = function ($li) {\n        this.links.push($li);\n    };\n\n    function TabbedContentSet(elem) {\n        Behaviors.init(TabbedContentSet, this, arguments);\n\n        this.$elem = $(elem);\n\n        this.tabset_name = this.$elem.attr(\"data-tabbedcontent-set\");\n        if (this.tabset_name === undefined) {\n            this.tabset_name = this.$elem.attr(\"id\");\n        }\n\n        this.tab_members = {};\n        this.list = [];\n\n        this.find_links();\n    }\n\n    Behaviors.inherit(TabbedContentSet, Behaviors.Behavior);\n\n    TabbedContentSet.QUERY = \"[data-tabbedcontent-set]\";\n\n    TabbedContentSet.prototype.new_tab = function (id) {\n        var $elem = $(\"#\" + id);\n\n        if ($elem.length === 0) {\n            return false;\n        }\n\n        if (this.tab_members[id] === undefined) {\n            this.tab_members[id] = {\n                \"toggles\": [],\n                \"content\": TabbedContentRegion.locate($elem)\n            };\n        }\n\n        return true;\n    };\n\n    TabbedContentSet.prototype.set_active_tab = function (id) {\n        var k;\n\n        for (k in this.tab_members) {\n            if (this.tab_members.hasOwnProperty(k)) {\n                this.tab_members[k].content.active = k === id;\n                this.tab_members[k].content.reflect_status();\n            }\n        }\n    };\n\n    TabbedContentSet.prototype.navigate_tab_intent = function (id, evt) {\n        this.set_active_tab(id);\n\n        if (evt) {\n            evt.preventDefault();\n        }\n    };\n\n    TabbedContentSet.prototype.import_list_item = function (li) {\n        var $li = $(li),\n            $link = $li.find(\"a\"),\n            href = $link.attr(\"href\"),\n            id;\n\n        if ($link.length === 0) {\n            return;\n        }\n\n        if (href.indexOf(\"#\") !== -1) {\n            id = href.slice(1);\n        }\n\n        if (id === undefined) {\n            return;\n        }\n\n        if (this.tab_members[id] === undefined && !this.new_tab(id)) {\n            return;\n        }\n\n        this.list.push({\n            \"li\": $li,\n            \"id\": id\n        });\n        this.tab_members[id].content.add_incoming_link($li);\n        this.tab_members[id].content.reflect_status();\n        $link.on(\"touchend click\", this.navigate_tab_intent.bind(this, id));\n    };\n\n    TabbedContentSet.prototype.find_links = function () {\n        var that = this;\n\n        this.$elem.find(\"li\").each(function (index, elem) {\n            return that.import_list_item(elem);\n        });\n    };\n\n    Behaviors.register_behavior(TabbedContentSet);\n\n    module.TabbedContentSet = TabbedContentSet;\n\n    return module;\n}));\n","","","/*jslint continue: true*/\n/*global detectZoom, console, jQuery, define, Float32Array, Uint16Array*/\n(function (root, factory) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(\"UTM\", [\"jquery\", \"Behaviors\"], factory);\n    } else {\n        root.UTM = factory(root.jQuery, root.Behaviors);\n    }\n}(this, function ($, Behaviors) {\n    \"use strict\";\n    var module = {},\n        utm_variables = {},\n        wanted_vars = [\"utm_source\", \"utm_medium\", \"utm_campaign\", \"utm_term\", \"utm_content\"];\n    \n    function utm_preserve_enabled() {\n        return $(\"body\").data(\"utmpreserve-preserve\") !== false;\n    }\n    \n    function utm_forminject_enabled() {\n        return $(\"body\").data(\"utmpreserve-forminject\") !== false;\n    }\n\n    function getQueryVariable(variable) {\n        var query = window.location.search.substring(1);\n        var vars = query.split('&');\n        for (var i = 0; i < vars.length; i++) {\n            var pair = vars[i].split('=');\n            if (decodeURIComponent(pair[0]) == variable) {\n                return decodeURIComponent(pair[1]);\n            }\n        }\n    }\n\n    /* Given a query string, return an object whose keys are matched UTM vars.\n     */\n    function look_for_utm_variables() {\n        var new_utm_variables = {}, i;\n\n        for (i = 0; i < wanted_vars.length; i += 1) {\n            new_utm_variables[wanted_vars[i]] = getQueryVariable(wanted_vars[i]);\n        }\n\n        return new_utm_variables;\n    }\n\n    function do_utm_replace($context) {\n        if (!utm_preserve_enabled()) {\n            console.log(\"UTM preserve is disabled.\");\n            return;\n        }\n        \n        utm_variables = look_for_utm_variables();\n\n        $context.find(\"a[href]\").each(function (index, elem) {\n            var k, $elem = $(elem),\n                old_href = $elem.attr(\"href\");\n\n            for (k in utm_variables) {\n                if (utm_variables.hasOwnProperty(k) && utm_variables[k] !== undefined) {\n                    if (old_href.indexOf(\"?\") !== -1) {\n                        old_href = old_href + \"&\" + k + \"=\" + utm_variables[k];\n                    } else {\n                        old_href = old_href + \"?\" + k + \"=\" + utm_variables[k];\n                    }\n                }\n            }\n\n            $elem.attr(\"href\", old_href);\n        })\n    }\n    \n    function do_gform_insertion(evt, form_id, current_page) {\n        var $form = $(\"#gform_\" + form_id), i, k,\n            old_action = $form.attr(\"action\");\n        \n        if (!utm_forminject_enabled()) {\n            console.log(\"UTM form injection is disabled.\");\n            return;\n        }\n        \n        utm_variables = look_for_utm_variables();\n        \n        //Remove any existing query vars.\n        //TODO: should we bother preserving old vars that aren't UTMs?\n        old_action = old_action.split(\"?\")[0];\n        \n        //Add UTM variables as seen by the client.\n        for (k in utm_variables) {\n            if (utm_variables.hasOwnProperty(k) && utm_variables[k] !== undefined) {\n                if (old_action.indexOf(\"?\") !== -1) {\n                    old_action = old_action + \"&\" + k + \"=\" + utm_variables[k];\n                } else {\n                    old_action = old_action + \"?\" + k + \"=\" + utm_variables[k];\n                }\n            }\n        }\n        \n        $form.attr(\"action\", old_action);\n        \n        //We can't auto-insert UTM variables into hidden fields, so instead we\n        //replace by hidden values.\n        $form.find(\"input[type='hidden']\").each(function (index, ielem) {\n            var $ielem = $(ielem), old_value = $ielem.attr(\"value\"), new_key;\n\n            if (old_value.startsWith(\"replace_param[\") && old_value.endsWith(\"]\")) {\n                new_key = old_value.split(\"[\")[1].split(\"]\")[0];\n                $ielem.val(utm_variables[new_key]);\n            }\n        })\n    }\n    \n    $(document).bind(\"gform_post_render\", do_gform_insertion);\n    \n    Behaviors.register_content_listener(do_utm_replace);\n    \n    module.do_utm_replace = do_utm_replace;\n    module.look_for_utm_variables = look_for_utm_variables;\n    module.getQueryVariable = getQueryVariable;\n    \n    return module;\n}));\n","/*global define, window, document, Promise*/\n(function (root, factory) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(\"VideoPlayer\", [\"jquery\", \"Behaviors\"], factory);\n    } else {\n        root.VideoPlayer = factory(root.jQuery, root.Behaviors);\n    }\n}(this, function ($, Behaviors) {\n    \"use strict\";\n\n    var module = {};\n\n    function VideoPlayer(elem) {\n        Behaviors.init(VideoPlayer, this, arguments);\n\n        this.$elem = $(elem);\n        \n        if (this.ready) {\n            this.ready().then(this.locate_children.bind(this));\n        } else {\n            this.locate_children();\n        }\n    }\n\n    Behaviors.inherit(VideoPlayer, Behaviors.Behavior);\n\n    /* Returns a promise which resolves when the player is ready to accept\n     * other API calls.\n     *\n     * Calling those other API calls outside of a then() block from the promise\n     * returned by this function is a good way to have a bad time.\n     *\n     * By default, the video player is always ready.\n     */\n    VideoPlayer.prototype.ready = function () {\n        return new Promise(function (resolve, reject) {\n            resolve();\n        });\n    };\n\n    //No QUERY is defined for the base VideoPlayer class as it is not intended\n    //to be locatable. Derived classes should locate their VideoPlayer subclass\n    //once it's attendant APIs have been loaded.\n    //VideoPlayer.QUERY = \"\";\n\n    VideoPlayer.prototype.locate_children = function () {\n        var $parent_modal, $parent_hover;\n        \n        this.playpause = VideoPlayer_playpause.find_markup(this.$elem, this);\n        this.scrubbers = VideoPlayer_scrubber.find_markup(this.$elem, this);\n        this.mute_btns = VideoPlayer_mute.find_markup(this.$elem, this);\n        \n        //This is an example of how to locate upwards\n        $parent_modal = this.$elem.parents().filter(VideoPlayer_offcanvas.QUERY);\n        \n        if ($parent_modal.length > 0) {\n            this.modal = VideoPlayer_offcanvas.locate($parent_modal[0], this);\n        }\n        \n        $parent_hover = this.$elem.parents().filter(VideoPlayer_hover.QUERY);\n        \n        if ($parent_hover.length > 0) {\n            this.hover = VideoPlayer_hover.locate($parent_hover[0], this);\n        }\n        \n        //Now see if we're supposed to autoplay...\n        if (this.$elem.data(\"videoplayer-autoplay\") !== undefined) {\n            this.play();\n        }\n        \n        if (this.$elem.data(\"videoplayer-loop\") !== undefined) {\n            this.add_statechange_listener(this.loopcheck.bind(this));\n        }\n    };\n    \n    VideoPlayer.prototype.loopcheck = function () {\n        Promise.all([this.is_paused(), this.get_current_time(), this.get_duration()]).then(function (values) {\n            var is_paused = values[0];\n            var current_time = values[1];\n            var duration = values[2];\n            \n            if (current_time === duration) {\n                this.seek(0);\n                this.play();\n            }\n        }.bind(this));\n    };\n\n    /* Determine if the video player is active.\n     *\n     * Most keyboard events only process on the active video's controls, not\n     * other videos. This ensures that you can have multiple VideoPlayers\n     * running without them all being controlled by the same limited set of\n     * keyboard shortcuts.\n     *\n     * A video player is active if any of the following apply:\n     *\n     *  - The video is marked primary with [data-videoplayer-primary].\n     *  - The video is currently playing.\n     *  - The VideoPlayer element or one of it's children has keyboard focus.\n     * \n     * This function returns a promise which resolves to the return value.\n     */\n    VideoPlayer.prototype.is_active = function () {\n        return this.is_paused(function (is_paused) {\n            if (this.$elem.data(\"videoplayer-primary\") !== undefined) {\n                return true;\n            }\n\n            if (!is_paused) {\n                return true;\n            }\n\n            if (this.$elem.find(\":focus\").length > 0) {\n                return true;\n            }\n\n            return false;\n        }.bind(this));\n    };\n\n    /* Serves as a play/pause button for a connected VideoPlayer.\n     */\n    function VideoPlayer_playpause(elem, parent) {\n        var that = this;\n\n        Behaviors.init(VideoPlayer_playpause, that, arguments);\n\n        that.parent = parent;\n\n        that.parent.ready().then(function () {\n            that.parent.add_statechange_listener(that.on_statechange.bind(that));\n            that.$elem.on(\"click touchend\", that.on_play_intent.bind(that));\n\n            that.update_css_classes();\n        });\n    }\n\n    Behaviors.inherit(VideoPlayer_playpause, Behaviors.Behavior);\n\n    VideoPlayer_playpause.QUERY = \"[data-videoplayer-playpause]\";\n\n    VideoPlayer_playpause.prototype.update_css_classes = function () {\n        this.parent.is_paused().then(function (is_paused) {\n            if (is_paused) {\n                this.$elem.addClass(\"is-VideoPlayer--paused\");\n                this.$elem.removeClass(\"is-VideoPlayer--playing\");\n            } else {\n                this.$elem.removeClass(\"is-VideoPlayer--paused\");\n                this.$elem.addClass(\"is-VideoPlayer--playing\");\n            }\n        }.bind(this));\n    };\n\n    VideoPlayer_playpause.prototype.toggle_playback = function () {\n        this.parent.is_paused().then(function (is_paused) {\n            if (is_paused) {\n                this.parent.play();\n            } else {\n                this.parent.pause();\n            }\n        }.bind(this));\n    };\n\n    VideoPlayer_playpause.prototype.on_statechange = function () {\n        this.update_css_classes();\n    };\n\n    VideoPlayer_playpause.prototype.on_play_intent = function () {\n        this.toggle_playback();\n    };\n\n    /* Allows a video modal to be started and stopped as the modal is opened\n     * and closed.\n     * \n     * Place this on the Offcanvas element that gets dismissed and/or opened.\n     */\n    function VideoPlayer_offcanvas(elem, parent) {\n        var that = this;\n\n        Behaviors.init(VideoPlayer_offcanvas, that, arguments);\n\n        that.parent = parent;\n\n        that.$elem.on(\"offcanvas-open\", that.on_open_intent.bind(that));\n        that.$elem.on(\"offcanvas-dismiss\", that.on_dismiss_intent.bind(that));\n    }\n\n    Behaviors.inherit(VideoPlayer_offcanvas, Behaviors.Behavior);\n\n    VideoPlayer_offcanvas.QUERY = \"[data-videoplayer-offcanvas]\";\n\n    VideoPlayer_offcanvas.prototype.on_open_intent = function () {\n        var that = this;\n\n        that.parent.is_paused().then(function (is_paused) {\n            if (is_paused) {\n                that.parent.play();\n            }\n        });\n    };\n\n    VideoPlayer_offcanvas.prototype.on_dismiss_intent = function () {\n        var that = this;\n\n        that.parent.is_paused().then(function (is_paused) {\n            if (!is_paused) {\n                that.parent.pause();\n            }\n        });\n    };\n\n    /* Allows a video modal to be started and stopped based on the hover state\n     * of an element. Won't work on mobile.\n     * \n     * Place this on the element that gets hovered.\n     */\n    function VideoPlayer_hover(elem, parent) {\n        var that = this;\n\n        Behaviors.init(VideoPlayer_hover, that, arguments);\n\n        that.parent = parent;\n\n        that.$elem.on(\"mouseenter\", that.on_hover_intent.bind(that));\n        that.$elem.on(\"mouseleave\", that.on_leave_intent.bind(that));\n    }\n\n    Behaviors.inherit(VideoPlayer_hover, Behaviors.Behavior);\n\n    VideoPlayer_hover.QUERY = \"[data-videoplayer-hover]\";\n\n    VideoPlayer_hover.prototype.on_hover_intent = function () {\n        var that = this;\n\n        that.parent.is_paused().then(function (is_paused) {\n            if (is_paused) {\n                that.parent.play();\n            }\n        });\n    };\n\n    VideoPlayer_hover.prototype.on_leave_intent = function () {\n        var that = this;\n\n        that.parent.is_paused().then(function (is_paused) {\n            if (!is_paused) {\n                that.parent.pause();\n            }\n        });\n    };\n\n    /* Serves as a scrub bar for a connected VideoPlayer.\n     *\n     * A Scrubber contains additional elements inside of it that do not have an\n     * associated behavior:\n     *\n     *  - [data-videoplayer-scrubberfill]: The filled range of the scrubber.\n     *  - [data-videoplayer-scrubberknob]: A knob which indicates the current\n     *     scrubber point.\n     */\n    function VideoPlayer_scrubber(elem, parent) {\n        var err, that = this;\n\n        Behaviors.init(VideoPlayer_scrubber, that, arguments);\n\n        that.parent = parent;\n\n        //EVENT STATE VARIABLES\n        that.is_dragging = false;\n        that.in_debounce = false;\n\n        //OPTIONAL COMPONENTS\n        that.$scrubfill = that.$elem.find(\"[data-videoplayer-scrubberfill]\");\n        that.$scrubknob = that.$elem.find(\"[data-videoplayer-scrubberknob]\");\n\n        that.parent.ready().then(function () {\n            //EVENT HANDLERS\n            that.$elem.on(\"mousedown touchstart\", that.on_dragstart_intent.bind(that));\n            that.$elem.on(\"mousemove touchmove\", that.on_drag_intent.bind(that));\n            $(document).on(\"mouseup touchend touchcancel\", that.on_dragend_intent.bind(that));\n            $(document).on(\"keydown\", that.on_keyboard_nav.bind(that));\n\n            err = that.parent.add_timeupdate_listener(that.on_timeupdate.bind(that));\n            if (err === false) {\n                window.setInterval(that.on_timeupdate.bind(that), 1000);\n            }\n        });\n\n        that.update_scrubber();\n    }\n\n    Behaviors.inherit(VideoPlayer_scrubber, Behaviors.Behavior);\n\n    VideoPlayer_scrubber.QUERY = \"[data-videoplayer-scrubber]\";\n\n    VideoPlayer_scrubber.prototype.css_percent = function (value) {\n        return (value * 100) + \"%\";\n    };\n\n    /* This defines the dynamic CSS properties that are applied to scrubber\n     * elements.\n     *\n     * Specifically, fills get a width equal to the current play percentage;\n     * knobs get a left position equal to the current play percentage.\n     *\n     * This assumes knobs and fills get positioned relative to the scrubber.\n     */\n    VideoPlayer_scrubber.prototype.update_scrubber = function () {\n        var that = this, currentTime, ratio;\n        \n        that.parent.ready().then(function () {\n            return that.parent.get_current_time();\n        }.bind(this)).then(function (newCurrentTime) {\n            currentTime = newCurrentTime;\n            return that.parent.get_duration();\n        }.bind(this)).then(function (duration) {\n            ratio = 0;\n\n            if (!isFinite(duration)) {\n                //Livestreams always show as complete.\n                ratio = 1;\n            } else if (!isNaN(duration)) {\n                ratio = currentTime / duration;\n            }\n\n            that.$scrubfill.css(\"width\", that.css_percent(ratio));\n            that.$scrubknob.css(\"left\", that.css_percent(ratio));\n        });\n    };\n\n    /* Given an X coordinate, calculate the corresponding video seek time and\n     * return it.\n     *\n     * Input is in page co-ordinates. Input is scaled to output based on the\n     * CSS width and position of the scrubber. Output is bounded within the\n     * closed range [0, 1].\n     * \n     * Returns a promise with the correct seek time.\n     */\n    VideoPlayer_scrubber.prototype.mouse_to_ctime = function (page_x) {\n        return this.parent.get_duration().then(function (duration) {\n            return (page_x - this.$elem.offset().left) / this.$elem.width() * duration;\n        }.bind(this));\n    };\n\n    /* Seek the parent player, but only if the proposed new time is valid.\n     */\n    VideoPlayer_scrubber.prototype.seek_if_valid = function (newTime, isFinal) {\n        if (isNaN(newTime) || !isFinite(newTime)) {\n            return;\n        }\n\n        this.parent.seek(newTime, isFinal);\n    };\n\n    // Drag event filtering\n\n    /* Start a drag operation; configuring the event filtering machinery to\n     * only recognize the click or touch that started the event chain.\n     */\n    VideoPlayer_scrubber.prototype.start_drag = function (evt) {\n        this.is_dragging = true;\n\n        if (evt.changedTouches !== undefined && evt.changedTouches.length > 0) {\n            this.drag_touch_id = evt.changedTouches[0].identifier;\n            return evt.changedTouches[0].pageX;\n        } else {\n            this.drag_touch_id = undefined;\n            return evt.pageX;\n        }\n    };\n\n    /* Retrieves the Page X coordinate from an event, ensuring that the correct\n     * finger is tracked across the entire event chain.\n     *\n     * Events will be ignored, and FALSE returned, if the event type that\n     * started the drag does not match the given event; or, if it's a touch\n     * event type, it will be ignored if there is no touch matching the current\n     * one.\n     */\n    VideoPlayer_scrubber.prototype.validate_drag = function (evt) {\n        var i;\n\n        if (this.is_dragging) {\n            if (this.drag_touch_id !== undefined) {\n                if (evt.changedTouches !== undefined) {\n                    for (i = 0; i < evt.changedTouches.length; i += 1) {\n                        if (evt.changedTouches[i].identifier === this.drag_touch_id) {\n                            return evt.changedTouches[i].pageX;\n                        }\n                    }\n                }\n            } else {\n                if (evt.changedTouches === undefined) {\n                    return evt.pageX;\n                }\n            }\n        }\n\n        return false;\n    };\n\n    /* Retrieves the Page X coordinate from an event and turns off further drag\n     * processing.\n     *\n     * For the same reasons as validate_drag, non-matching events will not\n     * cancel drag processing. This function returns FALSE if this event was\n     * ignored.\n     */\n    VideoPlayer_scrubber.prototype.end_drag = function (evt) {\n        var px = this.validate_drag(evt);\n        if (px === false) {\n            return px;\n        }\n\n        this.is_dragging = false;\n        this.drag_touch_id = undefined;\n\n        return px;\n    };\n\n    /* Process a drag event given the incoming Page X.\n     *\n     * If FALSE is given, indicating an event filtered by validate_drag, this\n     * does nothing.\n     */\n    VideoPlayer_scrubber.prototype.handle_drag = function (pageX, final) {\n        var newtime;\n\n        if (pageX === false) {\n            return;\n        }\n\n        return this.mouse_to_ctime(pageX).then(function (newtime) {\n            this.seek_if_valid(newtime, final);\n            this.update_scrubber();\n        }.bind(this));\n    };\n\n    // Event handlers\n\n    VideoPlayer_scrubber.prototype.on_timeupdate = function () {\n        this.update_scrubber();\n    };\n\n    VideoPlayer_scrubber.prototype.on_dragstart_intent = function (evt) {\n        this.handle_drag(this.start_drag(evt), false);\n    };\n\n    VideoPlayer_scrubber.prototype.on_drag_intent = function (evt) {\n        this.handle_drag(this.validate_drag(evt), false);\n    };\n\n    VideoPlayer_scrubber.prototype.on_dragend_intent = function (evt) {\n        this.handle_drag(this.end_drag(evt), true);\n    };\n\n    VideoPlayer_scrubber.prototype.on_keyboard_nav = function (evt) {\n        var currentTime;\n        \n        this.parent.ready().then(function () {\n            return this.parent.get_current_time();\n        }.bind(this)).then(function (newCurrentTime) {\n            currentTime = newCurrentTime;\n            return this.parent.is_active();\n        }.bind(this)).then(function (is_active) {\n            if (!is_active) {\n                return;\n            }\n            \n            if (evt.keyCode === 37) { //LEFT\n                evt.preventDefault();\n                this.parent.seek(currentTime - 1.0);\n                this.update_scrubber();\n            } else if (evt.keyCode === 39) { // RIGHT\n                evt.preventDefault();\n                this.parent.seek(currentTime + 1.0);\n                this.update_scrubber();\n            }\n        });\n    };\n\n    /* Serves as a play/pause button for a connected VideoPlayer.\n     */\n    function VideoPlayer_mute(elem, parent) {\n        var that = this;\n        \n        Behaviors.init(VideoPlayer_mute, that, arguments);\n\n        that.parent = parent;\n\n        that.parent.ready().then(function () {\n            that.$elem.on(\"click touchend\", that.on_mute_intent.bind(that));\n\n            that.update_css_classes();\n        });\n    }\n\n    Behaviors.inherit(VideoPlayer_mute, Behaviors.Behavior);\n\n    VideoPlayer_mute.QUERY = \"[data-videoplayer-mute]\";\n\n    VideoPlayer_mute.prototype.update_css_classes = function () {\n        this.parent.is_muted().then(function (is_muted) {\n            if (is_muted) {\n                this.$elem.addClass(\"is-VideoPlayer--muted\");\n                this.$elem.removeClass(\"is-VideoPlayer--audible\");\n            } else {\n                this.$elem.removeClass(\"is-VideoPlayer--muted\");\n                this.$elem.addClass(\"is-VideoPlayer--audible\");\n            }\n        }.bind(this));\n    };\n\n    VideoPlayer_mute.prototype.toggle_mute = function () {\n        this.parent.is_muted().then(function (is_muted) {\n            if (is_muted) {\n                this.parent.unmute();\n            } else {\n                this.parent.mute();\n            }\n        }.bind(this));\n    };\n\n    VideoPlayer_mute.prototype.on_mute_intent = function () {\n        this.toggle_mute();\n        this.update_css_classes();\n    };\n\n    // Player API adaptations\n\n\n    /* Thin implementation for a VideoPlayer that consumes an HTML5 video\n     * directly. Also provides a good demonstration that the VideoPlayer APIs\n     * are a very thin wrapper over HTMLMediaElement.\n     */\n    function VideoPlayer__html5(elem) {\n        this.$video = $(elem).find(\"video\");\n\n        Behaviors.init(VideoPlayer__html5, this, arguments);\n    }\n\n    Behaviors.inherit(VideoPlayer__html5, VideoPlayer);\n\n    VideoPlayer__html5.QUERY = \"[data-videoplayer='html5']\";\n\n    /* Plays the video, if loaded.\n     */\n    VideoPlayer__html5.prototype.play = function () {\n        this.$video[0].play();\n    };\n\n    /* Pauses the video.\n     */\n    VideoPlayer__html5.prototype.pause = function () {\n        this.$video[0].pause();\n    };\n\n    /* Mute the video\n     */\n    VideoPlayer__html5.prototype.mute = function () {\n        this.$video[0].muted = true;\n    };\n\n    /* Unmute the video\n     */\n    VideoPlayer__html5.prototype.unmute = function () {\n        this.$video[0].muted = false;\n    };\n\n    /* Returns the current player position.\n     * \n     * This function returns a promise which resolves to the current time.\n     */\n    VideoPlayer__html5.prototype.get_current_time = function () {\n        return Promise.resolve(this.$video[0].currentTime);\n    };\n\n    /* Seek the video to the number of seconds indicated in time.\n     */\n    VideoPlayer__html5.prototype.seek = function (time) {\n        this.$video[0].currentTime = time;\n    };\n\n    /* Check the video's duration.\n     *\n     * Returns the media's length in seconds.\n     *\n     * NaN is returned if the duration is unknown (check with isNaN).\n     * Infinity is returned if this is a streaming video.\n     * \n     * This function returns a promise which resolves to the aformentioned\n     * return value.\n     */\n    VideoPlayer__html5.prototype.get_duration = function () {\n        return Promise.resolve(this.$video[0].duration);\n    };\n\n    /* Check if the video is paused.\n     * \n     * This function returns a promise which resolves to the aformentioned\n     * return value.\n     */\n    VideoPlayer__html5.prototype.is_paused = function () {\n        return Promise.resolve(this.$video[0].paused);\n    };\n\n    /* Check if the video is muted.\n     * \n     * This function returns a promise which resolves to the aformentioned\n     * return value.\n     */\n    VideoPlayer__html5.prototype.is_muted = function () {\n        return Promise.resolve(this.$video[0].muted);\n    };\n\n    /* Check the volume of the video.\n     * \n     * This function returns a promise which resolves to the aformentioned\n     * return value.\n     */\n    VideoPlayer__html5.prototype.get_volume = function () {\n        return Promise.resolve(this.$video[0].volume);\n    };\n\n    /* Register an event handler for changes to the video's playback state.\n     *\n     * This corresponds exactly to matching the playing, play, and pause events\n     * and other video service APIs should ensure their event handler triggers\n     * on similar conditions.\n     */\n    VideoPlayer__html5.prototype.add_statechange_listener = function (listen) {\n        this.$video.on(\"playing play pause\", listen);\n    };\n\n    /* Register an event handler for changes to the video's playback time.\n     *\n     * This corresponds to the timeupdate event on HTMLMediaElement. This event\n     * is permitted not to register an event if it returns FALSE, indicating\n     * that timeupdates are not provided by this player type.\n     */\n    VideoPlayer__html5.prototype.add_timeupdate_listener = function (listen) {\n        this.$video.on(\"timeupdate\", listen);\n    };\n\n    /* This VideoPlayer consumes a YouTube iframe using the YouTube API.\n     * See https://developers.google.com/youtube/iframe_api_reference\n     */\n    function VideoPlayer__youtube(elem) {\n        var that = this;\n\n        Behaviors.init(VideoPlayer__youtube, that, arguments);\n\n        this.$iframe = $(elem).find(\"iframe\");\n        this.id = this.$iframe.attr(\"id\");\n        if (this.id === undefined) {\n            //Randomly generate an ID if one was not provided.\n            this.id = \"VideoPlayer-random_id--\" + Math.random() * 1024 * 1024;\n            this.$iframe.attr(\"id\", this.id);\n        }\n\n        this.player_fully_loaded = false;\n    }\n\n    Behaviors.inherit(VideoPlayer__youtube, VideoPlayer);\n\n    VideoPlayer__youtube.QUERY = \"[data-videoplayer='youtube']\";\n\n    /* Install the YouTube API, if not already installed.\n     *\n     * This is an asynchronous operation, so we return a Promise that resolves\n     * when YouTube's API is available. Invocation works like so:\n     *\n     * VideoPlayer__youtube.api().then(function () {\n     *     //do stuff...\n     * })\n     */\n    VideoPlayer__youtube.api = function () {\n        if (VideoPlayer__youtube.install_promise === undefined) {\n            VideoPlayer__youtube.install_promise = new Promise(function (resolve, reject) {\n                var tag, firstScriptTag;\n\n                tag = document.createElement(\"script\");\n                tag.src = \"https://www.youtube.com/iframe_api\";\n                firstScriptTag = document.getElementsByTagName('script')[0];\n                firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);\n\n                window.onYouTubeIframeAPIReady = VideoPlayer__youtube.api_ready_handler(resolve, reject);\n            });\n        }\n\n        return VideoPlayer__youtube.install_promise;\n    };\n\n    /* Creates the function that gets called when the YouTube API is ready.\n     */\n    VideoPlayer__youtube.api_ready_handler = function (resolve, reject) {\n        return function () {\n            resolve();\n        };\n    };\n\n    /* Returns a promise which resolves when the player is ready to accept\n     * other API calls.\n     *\n     * Calling those other API calls outside of a then() block from the promise\n     * returned by this function is a good way to have a bad time.\n     */\n    VideoPlayer__youtube.prototype.ready = function () {\n        var that = this;\n        \n        if (that.ready_promise === undefined) {\n            that.ready_promise = VideoPlayer__youtube.api().then(function () {\n                that.player = new window.YT.Player(that.id, {\n                    \"playerVars\": {\n                        \"enablejsapi\": true\n                    }\n                });\n\n                return new Promise(function (resolve, reject) {\n                    if (that.player_fully_loaded) {\n                        resolve();\n                    } else {\n                        that.player.addEventListener(\"onReady\", function () {\n                            that.player_fully_loaded = true;\n                            resolve();\n                        });\n                    }\n                });\n            });\n        }\n        \n        return that.ready_promise;\n    };\n\n    /* Plays the video, if loaded.\n     */\n    VideoPlayer__youtube.prototype.play = function () {\n        this.ready().then(function () {\n            this.player.playVideo();\n        }.bind(this));\n    };\n\n    /* Pauses the video.\n     */\n    VideoPlayer__youtube.prototype.pause = function () {\n        this.ready().then(function () {\n            this.player.pauseVideo();\n        }.bind(this));\n    };\n\n    /* Mute the video\n     */\n    VideoPlayer__youtube.prototype.mute = function () {\n        this.ready().then(function () {\n            this.player.mute();\n        }.bind(this));\n    };\n\n    /* Unmute the video\n     */\n    VideoPlayer__youtube.prototype.unmute = function () {\n        this.ready().then(function () {\n            this.player.unMute();\n        }.bind(this));\n    };\n\n    /* Returns the current player position.\n     * \n     * This function returns a promise which resolves to the current time.\n     */\n    VideoPlayer__youtube.prototype.get_current_time = function () {\n        return this.ready().then(function () {\n            return this.player.getCurrentTime();\n        }.bind(this));\n    };\n\n    /* Seek the video to the number of seconds indicated in time.\n     *\n     * The seek_commit parameter should be FALSE if and only if the seek\n     * resulted from a mousedrag and you expect to get more seek operations.\n     */\n    VideoPlayer__youtube.prototype.seek = function (time, seek_commit) {\n        return this.ready().then(function () {\n            return this.player.seekTo(time, seek_commit);\n        }.bind(this));\n    };\n\n    /* Check the video's duration.\n     *\n     * Returns the media's length in seconds.\n     *\n     * NaN is returned if the duration is unknown (check with isNaN).\n     * Infinity is returned if this is a streaming video.\n     *\n     * SPEC VIOLATION: YouTube does not indicate if the player is playing a\n     * live event, so live-streaming players will have incorrect duration info.\n     * \n     * This function returns a promise which resolves to the aformentioned\n     * return value.\n     */\n    VideoPlayer__youtube.prototype.get_duration = function () {\n        return this.ready().then(function () {\n            var duration = this.player.getDuration();\n\n            if (duration === 0) {\n                return NaN;\n            }\n\n            return duration;\n        }.bind(this));\n    };\n\n    /* Check if the video is paused.\n     *\n     * TODO: We naively interpret YouTube's player state, does player state 2\n     * correspond to HTMLMediaElement/VideoPlayer__html5's .paused attribute?\n     * Or are there other player states that count as paused by HTML5?\n     * \n     * This function returns a promise which resolves to the aformentioned\n     * return value.\n     */\n    VideoPlayer__youtube.prototype.is_paused = function () {\n        return this.ready().then(function () {\n            var ps = this.player.getPlayerState();\n            return ps === 2 || ps === -1 || ps === 5;\n        }.bind(this));\n    };\n\n    /* Check if the video is muted.\n     * \n     * This function returns a promise which resolves to the aformentioned\n     * return value.\n     */\n    VideoPlayer__youtube.prototype.is_muted = function () {\n        return this.ready().then(function () {\n            return this.player.isMuted();\n        }.bind(this));\n    };\n\n    /* Check the volume of the video.\n     *\n     * YouTube works in percentage units for some reason.\n     * \n     * This function returns a promise which resolves to the aformentioned\n     * return value.\n     */\n    VideoPlayer__youtube.prototype.get_volume = function () {\n        return this.ready().then(function () {\n            return this.player.getVolume() / 100;\n        }.bind(this));\n    };\n\n    /* Register an event handler for changes to the video's playback state.\n     *\n     * This corresponds exactly to matching the playing, play, and pause events\n     * and other video service APIs should ensure their event handler triggers\n     * on similar conditions.\n     */\n    VideoPlayer__youtube.prototype.add_statechange_listener = function (listen) {\n        this.ready().then(function () {\n            this.player.addEventListener(\"onStateChange\", listen);\n        }.bind(this));\n    };\n\n    /* Register an event handler for changes to the video's playback time.\n     *\n     * YouTube doesn't have this event type for some reason.\n     */\n    VideoPlayer__youtube.prototype.add_timeupdate_listener = function (listen) {\n        return false;\n    };\n\n    VideoPlayer__youtube.content_ready = function ($context) {\n        var Class = this;\n\n        if ($context.find(Class.QUERY).length > 0) {\n            Class.api().then(function () {\n                Class.find_markup($context);\n            });\n        }\n    };\n    \n    /* This VideoPlayer consumes a Vimeo iframe using their player controller.\n     * See https://github.com/vimeo/player.js\n     */\n    function VideoPlayer__vimeo(elem) {\n        var that = this;\n\n        Behaviors.init(VideoPlayer__vimeo, that, arguments);\n        \n        this.ready();\n    }\n\n    VideoPlayer__vimeo.QUERY = \"[data-videoplayer='vimeo']\";\n    \n    Behaviors.inherit(VideoPlayer__vimeo, VideoPlayer);\n    \n    /* Install the Vimeo API, if not already installed.\n     *\n     * This is an asynchronous operation, so we return a Promise that resolves\n     * when Vimeo's API is available. Invocation works like so:\n     *\n     * VideoPlayer__vimeo.api().then(function () {\n     *     //do stuff...\n     * })\n     */\n    VideoPlayer__vimeo.api = function () {\n        if (VideoPlayer__vimeo.install_promise === undefined) {\n            VideoPlayer__vimeo.install_promise = new Promise(function (resolve, reject) {\n                var tag, firstScriptTag;\n\n                tag = document.createElement(\"script\");\n                tag.src = \"https://player.vimeo.com/api/player.js\";\n                tag.onload = VideoPlayer__vimeo.api_ready_handler(resolve, reject);\n                tag.async = true;\n                firstScriptTag = document.getElementsByTagName('script')[0];\n                firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);\n            });\n        }\n\n        return VideoPlayer__vimeo.install_promise;\n    };\n\n    /* Creates the function that gets called when the Vimeo API is ready.\n     */\n    VideoPlayer__vimeo.api_ready_handler = function (resolve, reject) {\n        function wait_for_vimeo() {\n            if (window.Vimeo !== undefined) {\n                resolve();\n            } else {\n                window.setTimeout(wait_for_vimeo, 10);\n            }\n        }\n        \n        return wait_for_vimeo;\n    };\n    \n    /* Returns a promise which resolves when the player is ready to accept\n     * other API calls.\n     *\n     * Calling those other API calls outside of a then() block from the promise\n     * returned by this function is a good way to have a bad time.\n     */\n    VideoPlayer__vimeo.prototype.ready = function () {\n        var that = this;\n        \n        if (this.ready_promise === undefined) {\n            this.ready_promise = VideoPlayer__vimeo.api().then(function () {\n                this.player = new window.Vimeo.Player(this.$elem);\n            }.bind(this));\n        }\n        \n        return this.ready_promise;\n    };\n\n    /* Plays the video, if loaded.\n     */\n    VideoPlayer__vimeo.prototype.play = function () {\n        return this.ready().then(function () {\n            this.player.play();\n        }.bind(this));\n    };\n\n    /* Pauses the video.\n     */\n    VideoPlayer__vimeo.prototype.pause = function () {\n        return this.ready().then(function () {\n            this.player.pause();\n        }.bind(this));\n    };\n\n    /* Mute the video\n     */\n    VideoPlayer__vimeo.prototype.mute = function () {\n        return this.ready().then(function () {\n            return this.player.getVolume();\n        }.bind(this)).then(function (volume) {\n            this.preMuteVolume = volume;\n            this.player.setVolume(0);\n        }.bind(this));\n    };\n\n    /* Unmute the video\n     */\n    VideoPlayer__vimeo.prototype.unmute = function () {\n        return this.ready().then(function () {\n            return this.player.setVolume(this.preMuteVolume || 1.0);\n        }.bind(this));\n    };\n\n    /* Returns the current player position.\n     * \n     * This function returns a promise which resolves to the current time.\n     */\n    VideoPlayer__vimeo.prototype.get_current_time = function () {\n        return this.ready().then(function () {\n            return this.player.getCurrentTime();\n        }.bind(this));\n    };\n\n    /* Seek the video to the number of seconds indicated in time.\n     *\n     * The seek_commit parameter should be FALSE if and only if the seek\n     * resulted from a mousedrag and you expect to get more seek operations.\n     * \n     * As a unique quirk of the Vimeo API, the returned promise will resolve\n     * to the actual seek time adopted by the player.\n     */\n    VideoPlayer__vimeo.prototype.seek = function (time, seek_commit) {\n        return this.ready().then(function () {\n            return this.player.setCurrentTime(time);\n        }.bind(this));\n    };\n\n    /* Check the video's duration.\n     *\n     * Returns the media's length in seconds.\n     *\n     * NaN is returned if the duration is unknown (check with isNaN).\n     * Infinity is returned if this is a streaming video.\n     * \n     * This function returns a promise which resolves to the aformentioned\n     * return value.\n     */\n    VideoPlayer__vimeo.prototype.get_duration = function () {\n        return this.ready().then(function () {\n            return this.player.getDuration();\n        }.bind(this));\n    };\n\n    /* Check if the video is paused.\n     * \n     * This function returns a promise which resolves to the aformentioned\n     * return value.\n     */\n    VideoPlayer__vimeo.prototype.is_paused = function () {\n        return this.ready().then(function () {\n            return this.player.getPaused();\n        }.bind(this));\n    };\n\n    /* Check if the video is muted.\n     * \n     * This function returns a promise which resolves to the aformentioned\n     * return value.\n     */\n    VideoPlayer__vimeo.prototype.is_muted = function () {\n        return this.ready().then(function () {\n            return this.get_volume();\n        }.bind(this)).then(function (volume) {\n            return volume === 0.0;\n        }.bind(this));\n    };\n\n    /* Check the volume of the video.\n     * \n     * This function returns a promise which resolves to the aformentioned\n     * return value.\n     */\n    VideoPlayer__vimeo.prototype.get_volume = function () {\n        return this.ready().then(function () {\n            return this.player.getVolume();\n        }.bind(this));\n    };\n\n    /* Register an event handler for changes to the video's playback state.\n     *\n     * This corresponds exactly to matching the playing, play, and pause events\n     * and other video service APIs should ensure their event handler triggers\n     * on similar conditions.\n     */\n    VideoPlayer__vimeo.prototype.add_statechange_listener = function (listen) {\n        return this.ready().then(function () {\n            this.player.on(\"play\", listen);\n            this.player.on(\"pause\", listen);\n            this.player.on(\"ended\", listen);\n        }.bind(this));\n    };\n\n    /* Register an event handler for changes to the video's playback time.\n     */\n    VideoPlayer__vimeo.prototype.add_timeupdate_listener = function (listen) {\n        return this.ready().then(function () {\n            return this.player.on(\"timeupdate\", listen);\n        }.bind(this));\n    };\n    \n    VideoPlayer__vimeo.content_ready = function ($context) {\n        var Class = this;\n\n        if ($context.find(Class.QUERY).length > 0) {\n            Class.api().then(function () {\n                Class.find_markup($context);\n            });\n        }\n    };\n\n    Behaviors.register_behavior(VideoPlayer__html5);\n    Behaviors.register_behavior(VideoPlayer__youtube);\n    Behaviors.register_behavior(VideoPlayer__vimeo);\n    \n    module.VideoPlayer = VideoPlayer;\n    module.VideoPlayer_playpause = VideoPlayer_playpause;\n    module.VideoPlayer_scrubber = VideoPlayer_scrubber;\n    module.VideoPlayer_mute = VideoPlayer_mute;\n    module.VideoPlayer_offcanvas = VideoPlayer_offcanvas;\n    module.VideoPlayer_hover = VideoPlayer_hover;\n    module.VideoPlayer__html5 = VideoPlayer__html5;\n    module.VideoPlayer__youtube = VideoPlayer__youtube;\n    module.VideoPlayer__vimeo = VideoPlayer__vimeo;\n    return module;\n}));\n"]}